{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _helperPluginUtils = require(\"@babel/helper-plugin-utils\");\nvar _pluginSyntaxPrivatePropertyInObject = require(\"@babel/plugin-syntax-private-property-in-object\");\nvar _helperCreateClassFeaturesPlugin = require(\"@babel/helper-create-class-features-plugin\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _default = (0, _helperPluginUtils.declare)((api, opt) => {\n  api.assertVersion(7);\n  const {\n    types: t,\n    template\n  } = api;\n  const {\n    loose\n  } = opt;\n  const classWeakSets = new WeakMap();\n  const fieldsWeakSets = new WeakMap();\n  function unshadow(name, targetScope, scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n  function injectToFieldInit(fieldPath, expr, before = false) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n  function injectInitialization(classPath, init) {\n    let firstFieldPath;\n    let constructorPath;\n    for (const el of classPath.get(\"body.body\")) {\n      if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node.static) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({\n        kind: \"constructor\"\n      })) {\n        constructorPath = el;\n      }\n    }\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, constructorPath, [t.expressionStatement(init)]);\n    }\n  }\n  function getWeakSetId(weakSets, outerClass, reference, name = \"\", inject) {\n    let id = weakSets.get(reference.node);\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      (0, _helperAnnotateAsPure.default)(newExpr);\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n    return t.cloneNode(id);\n  }\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits: _pluginSyntaxPrivatePropertyInObject.default,\n    pre() {\n      (0, _helperCreateClassFeaturesPlugin.enableFeature)(this.file, _helperCreateClassFeaturesPlugin.FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const {\n          node\n        } = path;\n        const {\n          file\n        } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n        const {\n          name\n        } = node.left.id;\n        let privateElement;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n          privateElement = path.get(\"body.body\").find(({\n            node\n          }) => t.isPrivate(node) && node.key.id.name === name);\n          return !!privateElement;\n        });\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(template.ast`(() => ${outerClass.node})()`);\n          return;\n        }\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)}\n              `);\n          } else {\n            var _outerClass$node$id;\n            const id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization);\n            path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n          }\n        } else {\n          const id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);\n          path.replaceWith(template.expression.ast`${id}.has(${(0, _helperCreateClassFeaturesPlugin.buildCheckInRHS)(node.right, file)})`);\n        }\n      }\n    }\n  };\n});\nexports.default = _default;","map":{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxPrivatePropertyInObject","_helperCreateClassFeaturesPlugin","_helperAnnotateAsPure","_default","declare","api","opt","assertVersion","types","t","template","loose","classWeakSets","WeakMap","fieldsWeakSets","unshadow","name","targetScope","scope","hasOwnBinding","rename","parent","injectToFieldInit","fieldPath","expr","before","node","value","get","insertBefore","insertAfter","set","unaryExpression","injectInitialization","classPath","init","firstFieldPath","constructorPath","el","isClassProperty","isClassPrivateProperty","static","isClassMethod","kind","expressionStatement","getWeakSetId","weakSets","outerClass","reference","inject","id","generateUidIdentifier","expression","ast","cloneNode","newExpr","newExpression","identifier","default","inherits","pre","enableFeature","file","FEATURES","privateIn","visitor","BinaryExpression","path","state","operator","isPrivateName","left","privateElement","findParent","isClass","find","isPrivate","key","parentPath","isPattern","replaceWith","type","buildCheckInRHS","right","_outerClass$node$id","exports"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/@babel/plugin-transform-private-property-in-object/src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxPlugin from \"@babel/plugin-syntax-private-property-in-object\";\nimport {\n  enableFeature,\n  FEATURES,\n  injectInitialization as injectConstructorInit,\n  buildCheckInRHS,\n} from \"@babel/helper-create-class-features-plugin\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\n\nexport interface Options {\n  loose?: boolean;\n}\nexport default declare((api, opt: Options) => {\n  api.assertVersion(7);\n  const { types: t, template } = api;\n  const { loose } = opt;\n\n  // NOTE: When using the class fields or private methods plugins,\n  // they will also take care of '#priv in obj' checks when visiting\n  // the ClassExpression or ClassDeclaration nodes.\n  // The visitor of this plugin is only effective when not compiling\n  // private fields and methods.\n\n  const classWeakSets: WeakMap<t.Class, t.Identifier> = new WeakMap();\n  const fieldsWeakSets: WeakMap<\n    t.ClassPrivateProperty | t.ClassPrivateMethod,\n    t.Identifier\n  > = new WeakMap();\n\n  function unshadow(name: string, targetScope: Scope, scope: Scope) {\n    while (scope !== targetScope) {\n      if (scope.hasOwnBinding(name)) scope.rename(name);\n      scope = scope.parent;\n    }\n  }\n\n  function injectToFieldInit(\n    fieldPath: NodePath<t.ClassPrivateProperty | t.ClassProperty>,\n    expr: t.Expression,\n    before = false,\n  ) {\n    if (fieldPath.node.value) {\n      const value = fieldPath.get(\"value\");\n      if (before) {\n        value.insertBefore(expr);\n      } else {\n        value.insertAfter(expr);\n      }\n    } else {\n      fieldPath.set(\"value\", t.unaryExpression(\"void\", expr));\n    }\n  }\n\n  function injectInitialization(\n    classPath: NodePath<t.Class>,\n    init: t.Expression,\n  ) {\n    let firstFieldPath;\n    let constructorPath;\n\n    for (const el of classPath.get(\"body.body\")) {\n      if (\n        (el.isClassProperty() || el.isClassPrivateProperty()) &&\n        !el.node.static\n      ) {\n        firstFieldPath = el;\n        break;\n      }\n      if (!constructorPath && el.isClassMethod({ kind: \"constructor\" })) {\n        constructorPath = el;\n      }\n    }\n\n    if (firstFieldPath) {\n      injectToFieldInit(firstFieldPath, init, true);\n    } else {\n      injectConstructorInit(classPath, constructorPath, [\n        t.expressionStatement(init),\n      ]);\n    }\n  }\n\n  function getWeakSetId<Ref extends t.Node>(\n    weakSets: WeakMap<Ref, t.Identifier>,\n    outerClass: NodePath<t.Class>,\n    reference: NodePath<Ref>,\n    name = \"\",\n    inject: (\n      reference: NodePath<Ref>,\n      expression: t.Expression,\n      before?: boolean,\n    ) => void,\n  ) {\n    let id = weakSets.get(reference.node);\n\n    if (!id) {\n      id = outerClass.scope.generateUidIdentifier(`${name || \"\"} brandCheck`);\n      weakSets.set(reference.node, id);\n\n      inject(reference, template.expression.ast`${t.cloneNode(id)}.add(this)`);\n\n      const newExpr = t.newExpression(t.identifier(\"WeakSet\"), []);\n      annotateAsPure(newExpr);\n\n      outerClass.insertBefore(template.ast`var ${id} = ${newExpr}`);\n    }\n\n    return t.cloneNode(id);\n  }\n\n  return {\n    name: \"transform-private-property-in-object\",\n    inherits: syntaxPlugin.default,\n    pre() {\n      // Enable this in @babel/helper-create-class-features-plugin, so that it\n      // can be handled by the private fields and methods transform.\n      enableFeature(this.file, FEATURES.privateIn, loose);\n    },\n    visitor: {\n      BinaryExpression(path, state) {\n        const { node } = path;\n        const { file } = state;\n        if (node.operator !== \"in\") return;\n        if (!t.isPrivateName(node.left)) return;\n\n        const { name } = node.left.id;\n\n        let privateElement: NodePath<\n          t.ClassPrivateMethod | t.ClassPrivateProperty\n        >;\n        const outerClass = path.findParent(path => {\n          if (!path.isClass()) return false;\n\n          privateElement = path.get(\"body.body\").find(\n            ({ node }) =>\n              // fixme: Support class accessor property\n              t.isPrivate(node) && node.key.id.name === name,\n          ) as NodePath<t.ClassPrivateMethod | t.ClassPrivateProperty>;\n\n          return !!privateElement;\n        }) as NodePath<t.Class>;\n\n        if (outerClass.parentPath.scope.path.isPattern()) {\n          outerClass.replaceWith(\n            template.ast`(() => ${outerClass.node})()` as t.Statement,\n          );\n          // The injected class will be queued and eventually transformed when visited\n          return;\n        }\n\n        if (privateElement.node.type === \"ClassPrivateMethod\") {\n          if (privateElement.node.static) {\n            if (outerClass.node.id) {\n              unshadow(outerClass.node.id.name, outerClass.scope, path.scope);\n            } else {\n              outerClass.set(\"id\", path.scope.generateUidIdentifier(\"class\"));\n            }\n            path.replaceWith(\n              template.expression.ast`\n                ${t.cloneNode(outerClass.node.id)} === ${buildCheckInRHS(\n                  node.right,\n                  file,\n                )}\n              `,\n            );\n          } else {\n            const id = getWeakSetId(\n              classWeakSets,\n              outerClass,\n              outerClass,\n              outerClass.node.id?.name,\n              injectInitialization,\n            );\n\n            path.replaceWith(\n              template.expression.ast`${id}.has(${buildCheckInRHS(\n                node.right,\n                file,\n              )})`,\n            );\n          }\n        } else {\n          // Private fields might not all be initialized: see the 'halfConstructed'\n          // example at https://v8.dev/features/private-brand-checks.\n\n          const id = getWeakSetId<t.ClassPrivateProperty>(\n            fieldsWeakSets,\n            outerClass,\n            privateElement as NodePath<t.ClassPrivateProperty>,\n            privateElement.node.key.id.name,\n            injectToFieldInit,\n          );\n\n          path.replaceWith(\n            template.expression.ast`${id}.has(${buildCheckInRHS(\n              node.right,\n              file,\n            )})`,\n          );\n        }\n      },\n    },\n  };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}