{"ast":null,"code":"// Import Express\nconst express = require('express');\n// Create an instance of an Express Router\nconst router = express.Router();\nconst jwt = require('jsonwebtoken');\nconst {\n  Role\n} = require('../models/RoleModel');\nconst {\n  Post\n} = require('../models/PostModel');\nconst {\n  verifyUserJWT,\n  decryptString\n} = require('./UserFunctions');\nconst {\n  User\n} = require('../models/UserModel');\nconst {\n  getAllPosts,\n  getPostById,\n  getPostsByAuthor,\n  createPost,\n  updatePost,\n  deletePost\n} = require('./PostFunctions');\n// Make sure the JWT available in the headers is valid,\n// and refresh it to keep the JWT usable for longer.\nconst verifyJwtHeader = async (request, response, next) => {\n  let rawJwtHeader = request.headers.jwt;\n  let jwtRefresh = await verifyUserJWT(rawJwtHeader);\n  request.headers.jwt = jwtRefresh;\n  next();\n};\nconst verifyJwtRole = async (request, response, next) => {\n  // Verify that the JWT is still valid.\n  let userJwtVerified = jwt.verify(request.headers.jwt, process.env.JWT_SECRET, {\n    complete: true\n  });\n  // Decrypt the encrypted payload.\n  let decryptedJwtPayload = decryptString(userJwtVerified.payload.data);\n  // Parse the decrypted data into an object.\n  let userData = JSON.parse(decryptedJwtPayload);\n\n  // Because the JWT doesn't include role info, we must find the full user document first:\n  let userDoc = await User.findById(userData.userID).exec();\n  let userRoleName = await Role.findById(userDoc.role).exec();\n\n  // Attach the role to the request for the backend to use.\n  // Note that the user's role will never be available on the front-end\n  // with this technique.\n  // This means they can't just manipulate the JWT to access admin stuff.\n  console.log(\"User role is: \" + userRoleName.name);\n  request.headers.userRole = userRoleName.name;\n  request.headers.userID = userDoc.id.toString();\n  next();\n};\n// The actual authorization middleware.\n// Throw to the error-handling middleware\n// if the user is not authorized.\n// Different middleware can be made for\n// different roles, just like this.\nconst onlyAllowAdminOrAuthor = async (request, response, next) => {\n  let postAuthor = await Post.findById(request.params.postID).exec().then(data => {\n    return data.author;\n  });\n  if (request.headers.userRole == \"admin\" || postAuthor == request.headers.userID) {\n    next();\n  } else {\n    next(new Error(\"User not authorized.\"));\n  }\n};\n// Show all posts\nrouter.get('/', async (request, response) => {\n  let allPosts = await getAllPosts();\n  response.json({\n    postsCount: allPosts.length,\n    postsArray: allPosts\n  });\n});\n\n// Show posts by specific user\nrouter.get('/author/:authorID', async (request, response) => {\n  let postsByAuthor = await getPostsByAuthor(request.params.authorID);\n  response.json({\n    postsCount: postsByAuthor.length,\n    postsArray: postsByAuthor\n  });\n});\n\n// Show specific post by ID\nrouter.get('/:postID', async (request, response) => {\n  response.json(await getPostById(request.params.postID));\n});\n\n// Create a post\nrouter.post('/', async (request, response) => {\n  response.json(await createPost(request.body.postDetails));\n});\n\n// Update a specific post\nrouter.put('/:postID', verifyJwtHeader, verifyJwtRole, onlyAllowAdminOrAuthor, async (request, response) => {\n  let postDetails = {\n    postID: request.params.postID,\n    updatedData: request.body.newPostData\n  };\n  response.json(await updatePost(postDetails));\n});\n\n// Delete a specific post\nrouter.delete('/:postID', async (request, response) => {\n  response.json(await deletePost(request.params.postID));\n});\n\n// Export the router so that other files can use it:\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","jwt","Role","Post","verifyUserJWT","decryptString","User","getAllPosts","getPostById","getPostsByAuthor","createPost","updatePost","deletePost","verifyJwtHeader","request","response","next","rawJwtHeader","headers","jwtRefresh","verifyJwtRole","userJwtVerified","verify","process","env","JWT_SECRET","complete","decryptedJwtPayload","payload","data","userData","JSON","parse","userDoc","findById","userID","exec","userRoleName","role","console","log","name","userRole","id","toString","onlyAllowAdminOrAuthor","postAuthor","params","postID","then","author","Error","get","allPosts","json","postsCount","length","postsArray","postsByAuthor","authorID","post","body","postDetails","put","updatedData","newPostData","delete","module","exports"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/src/controllers/PostRoutes.js"],"sourcesContent":["// Import Express\nconst express = require('express');\n// Create an instance of an Express Router\nconst router = express.Router();\nconst jwt = require('jsonwebtoken');\nconst { Role } = require('../models/RoleModel');\nconst { Post } = require('../models/PostModel');\nconst { verifyUserJWT, decryptString } = require('./UserFunctions');\nconst { User } = require('../models/UserModel');\n\nconst {\n    getAllPosts, getPostById, getPostsByAuthor, createPost, updatePost, deletePost\n} = require('./PostFunctions');\n// Make sure the JWT available in the headers is valid,\n// and refresh it to keep the JWT usable for longer.\nconst verifyJwtHeader = async (request, response, next) => {\n    let rawJwtHeader = request.headers.jwt;\n\n    let jwtRefresh = await verifyUserJWT(rawJwtHeader);\n\n    request.headers.jwt = jwtRefresh;\n\n    next();\n}\n\nconst verifyJwtRole = async (request, response, next) => {\n    // Verify that the JWT is still valid.\n    let userJwtVerified = jwt.verify(request.headers.jwt,process.env.JWT_SECRET, {complete: true});\n    // Decrypt the encrypted payload.\n    let decryptedJwtPayload = decryptString(userJwtVerified.payload.data);\n    // Parse the decrypted data into an object.\n    let userData = JSON.parse(decryptedJwtPayload);\n\n    // Because the JWT doesn't include role info, we must find the full user document first:\n    let userDoc = await User.findById(userData.userID).exec();\n    let userRoleName = await Role.findById(userDoc.role).exec();\n\n    // Attach the role to the request for the backend to use.\n    // Note that the user's role will never be available on the front-end\n    // with this technique.\n    // This means they can't just manipulate the JWT to access admin stuff.\n    console.log(\"User role is: \" + userRoleName.name);\n    request.headers.userRole = userRoleName.name;\n    request.headers.userID = userDoc.id.toString();\n\n    next();\n}\n// The actual authorization middleware.\n// Throw to the error-handling middleware\n// if the user is not authorized.\n// Different middleware can be made for\n// different roles, just like this.\nconst onlyAllowAdminOrAuthor = async (request, response, next) => {\n    let postAuthor = await Post.findById(request.params.postID).exec().then((data) => {return data.author});\n\n    if (request.headers.userRole == \"admin\" || postAuthor == request.headers.userID){\n        next();\n    } else {\n        next(new Error(\"User not authorized.\"));\n    }\n}\n// Show all posts\nrouter.get('/', async (request, response) => {\n    let allPosts = await getAllPosts();\n\n    response.json({\n        postsCount: allPosts.length,\n        postsArray: allPosts\n    });\n});\n\n// Show posts by specific user\nrouter.get('/author/:authorID', async (request, response) => {\n    let postsByAuthor = await getPostsByAuthor(request.params.authorID);\n\n    response.json({\n        postsCount: postsByAuthor.length,\n        postsArray: postsByAuthor\n    });\n});\n\n// Show specific post by ID\nrouter.get('/:postID', async (request, response) => {\n    response.json(await getPostById(request.params.postID));\n});\n\n// Create a post\nrouter.post('/', async (request, response) => {\n    response.json(await createPost(request.body.postDetails));\n});\n\n// Update a specific post\nrouter.put('/:postID',verifyJwtHeader, verifyJwtRole, onlyAllowAdminOrAuthor, async (request, response) => {\n    let postDetails = {\n        postID: request.params.postID,\n        updatedData: request.body.newPostData\n    };\n\n    response.json(await updatePost(postDetails));\n});\n\n// Delete a specific post\nrouter.delete('/:postID', async (request, response) => {\n    response.json(await deletePost(request.params.postID));\n});\n\n\n// Export the router so that other files can use it:\nmodule.exports = router;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}