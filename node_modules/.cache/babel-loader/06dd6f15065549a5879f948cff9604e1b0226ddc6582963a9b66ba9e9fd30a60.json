{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildCheckInRHS = buildCheckInRHS;\nexports.buildFieldsInitNodes = buildFieldsInitNodes;\nexports.buildPrivateNamesMap = buildPrivateNamesMap;\nexports.buildPrivateNamesNodes = buildPrivateNamesNodes;\nexports.transformPrivateNamesUsage = transformPrivateNamesUsage;\nvar _core = require(\"@babel/core\");\nvar _helperReplaceSupers = require(\"@babel/helper-replace-supers\");\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\nvar _helperAnnotateAsPure = require(\"@babel/helper-annotate-as-pure\");\nvar _helperSkipTransparentExpressionWrappers = require(\"@babel/helper-skip-transparent-expression-wrappers\");\nvar ts = require(\"./typescript\");\nfunction buildPrivateNamesMap(props) {\n  const privateNamesMap = new Map();\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const {\n        name\n      } = prop.node.key.id;\n      const update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {\n        id: prop.scope.generateUidIdentifier(name),\n        static: prop.node.static,\n        method: !prop.isProperty()\n      };\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n        } else if (prop.node.kind === \"set\") {\n          update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\nfunction buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, privateFieldsAsSymbols, state) {\n  const initNodes = [];\n  for (const [name, value] of privateNamesMap) {\n    const {\n      static: isStatic,\n      method: isMethod,\n      getId,\n      setId\n    } = value;\n    const isAccessor = getId || setId;\n    const id = _core.types.cloneNode(value.id);\n    let init;\n    if (privateFieldsAsProperties) {\n      init = _core.types.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [_core.types.stringLiteral(name)]);\n    } else if (privateFieldsAsSymbols) {\n      init = _core.types.callExpression(_core.types.identifier(\"Symbol\"), [_core.types.stringLiteral(name)]);\n    } else if (!isStatic) {\n      init = _core.types.newExpression(_core.types.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"), []);\n    }\n    if (init) {\n      (0, _helperAnnotateAsPure.default)(init);\n      initNodes.push(_core.template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n  return initNodes;\n}\nfunction privateNameVisitorFactory(visitor) {\n  const nestedVisitor = _core.traverse.visitors.merge([Object.assign({}, visitor), _helperEnvironmentVisitor.default]);\n  const privateNameVisitor = Object.assign({}, visitor, {\n    Class(path) {\n      const {\n        privateNamesMap\n      } = this;\n      const body = path.get(\"body.body\");\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const {\n          name\n        } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n      if (!redeclared.length) {\n        return;\n      }\n      path.get(\"body\").traverse(nestedVisitor, Object.assign({}, this, {\n        redeclared\n      }));\n      path.traverse(privateNameVisitor, Object.assign({}, this, {\n        privateNamesMap: visiblePrivateNames\n      }));\n      path.skipKey(\"body\");\n    }\n  });\n  return privateNameVisitor;\n}\nconst privateNameVisitor = privateNameVisitorFactory({\n  PrivateName(path, {\n    noDocumentAll\n  }) {\n    const {\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      property: node\n    }) && !parentPath.isOptionalMemberExpression({\n      property: node\n    })) {\n      return;\n    }\n    const {\n      name\n    } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    this.handle(parentPath, noDocumentAll);\n  }\n});\nfunction unshadow(name, scope, innerBinding) {\n  while ((_scope = scope) != null && _scope.hasBinding(name) && !scope.bindingIdentifierEquals(name, innerBinding)) {\n    var _scope;\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\nfunction buildCheckInRHS(rhs, file, inRHSIsObject) {\n  if (inRHSIsObject || !(file.availableHelper != null && file.availableHelper(\"checkInRHS\"))) return rhs;\n  return _core.types.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\nconst privateInVisitor = privateNameVisitorFactory({\n  BinaryExpression(path, {\n    file\n  }) {\n    const {\n      operator,\n      left,\n      right\n    } = path.node;\n    if (operator !== \"in\") return;\n    if (!_core.types.isPrivateName(left)) return;\n    const {\n      privateFieldsAsProperties,\n      privateNamesMap,\n      redeclared\n    } = this;\n    const {\n      name\n    } = left.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n    if (privateFieldsAsProperties) {\n      const {\n        id\n      } = privateNamesMap.get(name);\n      path.replaceWith(_core.template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(right, file)}, ${_core.types.cloneNode(id)})\n      `);\n      return;\n    }\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n    if (isStatic) {\n      path.replaceWith(_core.template.expression.ast`${buildCheckInRHS(right, file)} === ${_core.types.cloneNode(this.classRef)}`);\n      return;\n    }\n    path.replaceWith(_core.template.expression.ast`${_core.types.cloneNode(id)}.has(${buildCheckInRHS(right, file)})`);\n  }\n});\nconst privateNameHandlerSpec = {\n  memoise(member, count) {\n    const {\n      scope\n    } = member;\n    const {\n      object\n    } = member.node;\n    const memo = scope.maybeGenerateMemoised(object);\n    if (!memo) {\n      return;\n    }\n    this.memoiser.set(object, memo, count);\n  },\n  receiver(member) {\n    const {\n      object\n    } = member.node;\n    if (this.memoiser.has(object)) {\n      return _core.types.cloneNode(this.memoiser.get(object));\n    }\n    return _core.types.cloneNode(object);\n  },\n  get(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file,\n      innerBinding\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      methodId,\n      getId,\n      setId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodGet\" : \"classStaticPrivateFieldSpecGet\";\n      unshadow(classRef.name, member.scope, innerBinding);\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]);\n    }\n    if (isMethod) {\n      if (isAccessor) {\n        if (!getId && setId) {\n          if (file.availableHelper(\"writeOnlyError\")) {\n            return _core.types.sequenceExpression([this.receiver(member), _core.types.callExpression(file.addHelper(\"writeOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n          }\n          console.warn(`@babel/helpers is outdated, update it to silence this warning.`);\n        }\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n      }\n      return _core.types.callExpression(file.addHelper(\"classPrivateMethodGet\"), [this.receiver(member), _core.types.cloneNode(id), _core.types.cloneNode(methodId)]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldGet\"), [this.receiver(member), _core.types.cloneNode(id)]);\n  },\n  boundGet(member) {\n    this.memoise(member, 1);\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [this.receiver(member)]);\n  },\n  set(member, value) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic,\n      method: isMethod,\n      setId,\n      getId\n    } = privateNamesMap.get(name);\n    const isAccessor = getId || setId;\n    if (isStatic) {\n      const helperName = isMethod && !isAccessor ? \"classStaticPrivateMethodSet\" : \"classStaticPrivateFieldSpecSet\";\n      return _core.types.callExpression(file.addHelper(helperName), [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id), value]);\n    }\n    if (isMethod) {\n      if (setId) {\n        return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n      }\n      return _core.types.sequenceExpression([this.receiver(member), value, _core.types.callExpression(file.addHelper(\"readOnlyError\"), [_core.types.stringLiteral(`#${name}`)])]);\n    }\n    return _core.types.callExpression(file.addHelper(\"classPrivateFieldSet\"), [this.receiver(member), _core.types.cloneNode(id), value]);\n  },\n  destructureSet(member) {\n    const {\n      classRef,\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      name\n    } = member.node.property.id;\n    const {\n      id,\n      static: isStatic\n    } = privateNamesMap.get(name);\n    if (isStatic) {\n      try {\n        var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n      } catch (_unused) {\n        throw new Error(\"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" + \"please update @babel/helpers to the latest version.\");\n      }\n      return _core.types.memberExpression(_core.types.callExpression(helper, [this.receiver(member), _core.types.cloneNode(classRef), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n    }\n    return _core.types.memberExpression(_core.types.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [this.receiver(member), _core.types.cloneNode(id)]), _core.types.identifier(\"value\"));\n  },\n  call(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, false);\n  },\n  optionalCall(member, args) {\n    this.memoise(member, 1);\n    return (0, _helperOptimiseCallExpression.default)(this.get(member), this.receiver(member), args, true);\n  },\n  delete() {\n    throw new Error(\"Internal Babel error: deleting private elements is a parsing error.\");\n  }\n};\nconst privateNameHandlerLoose = {\n  get(member) {\n    const {\n      privateNamesMap,\n      file\n    } = this;\n    const {\n      object\n    } = member.node;\n    const {\n      name\n    } = member.node.property.id;\n    return _core.template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: _core.types.cloneNode(object),\n      PROP: _core.types.cloneNode(privateNamesMap.get(name).id)\n    });\n  },\n  set() {\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n  boundGet(member) {\n    return _core.types.callExpression(_core.types.memberExpression(this.get(member), _core.types.identifier(\"bind\")), [_core.types.cloneNode(member.node.object)]);\n  },\n  simpleSet(member) {\n    return this.get(member);\n  },\n  destructureSet(member) {\n    return this.get(member);\n  },\n  call(member, args) {\n    return _core.types.callExpression(this.get(member), args);\n  },\n  optionalCall(member, args) {\n    return _core.types.optionalCallExpression(this.get(member), args, true);\n  },\n  delete() {\n    throw new Error(\"Internal Babel error: deleting private elements is a parsing error.\");\n  }\n};\nfunction transformPrivateNamesUsage(ref, path, privateNamesMap, {\n  privateFieldsAsProperties,\n  noDocumentAll,\n  innerBinding\n}, state) {\n  if (!privateNamesMap.size) return;\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;\n  (0, _helperMemberExpressionToFunctions.default)(body, privateNameVisitor, Object.assign({\n    privateNamesMap,\n    classRef: ref,\n    file: state\n  }, handler, {\n    noDocumentAll,\n    innerBinding\n  }));\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding\n  });\n}\nfunction buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${_core.types.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    `, prop);\n}\nfunction buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap, state) {\n  const {\n    id\n  } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`${_core.types.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })`, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)},\n      {\n        writable: true,\n        value: ${value}\n      },\n    )`, prop);\n}\nfunction buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  const isAccessor = getId || setId;\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        var ${_core.types.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        }\n      `, prop);\n  }\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.template.statement.ast`\n      var ${_core.types.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      };\n    `, prop);\n}\nfunction buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    methodId,\n    id,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  if (methodId) {\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `, prop);\n  }\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      `, prop);\n  }\n}\nfunction buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state);\n  }\n  return buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state);\n}\nfunction buildPrivateAccessorInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    getId,\n    setId\n  } = privateName;\n  privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n    initAdded: true\n  }));\n  {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        `, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )`, prop);\n}\nfunction buildPrivateInstanceMethodInitialization(ref, prop, privateNamesMap, state) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id\n  } = privateName;\n  {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return inheritPropComments(_core.template.statement.ast`${id}.add(${ref})`, prop);\n    }\n  }\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return inheritPropComments(_core.template.statement.ast`${helper}(\n      ${_core.types.thisExpression()},\n      ${_core.types.cloneNode(id)}\n    )`, prop);\n}\nfunction buildPublicFieldInitLoose(ref, prop) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.assignmentExpression(\"=\", _core.types.memberExpression(ref, key, computed || _core.types.isLiteral(key)), value)), prop);\n}\nfunction buildPublicFieldInitSpec(ref, prop, state) {\n  const {\n    key,\n    computed\n  } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(_core.types.expressionStatement(_core.types.callExpression(state.addHelper(\"defineProperty\"), [ref, computed || _core.types.isLiteral(key) ? key : _core.types.stringLiteral(key.name), value])), prop);\n}\nfunction buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    initAdded\n  } = privateName;\n  if (initAdded) return;\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      initAdded: true\n    }));\n    return inheritPropComments(_core.template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `, prop);\n  }\n  return inheritPropComments(_core.template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `, prop);\n}\nfunction buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties = false) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic\n  } = privateName;\n  const {\n    params,\n    body,\n    generator,\n    async\n  } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n  let declId = methodId;\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      getterDeclared: true\n    }));\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {\n      setterDeclared: true\n    }));\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n  return inheritPropComments(_core.types.functionDeclaration(_core.types.cloneNode(declId), params, body, generator, async), prop);\n}\nconst thisContextVisitor = _core.traverse.visitors.merge([{\n  UnaryExpression(path) {\n    const {\n      node\n    } = path;\n    if (node.operator === \"delete\") {\n      const argument = (0, _helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes)(node.argument);\n      if (_core.types.isThisExpression(argument)) {\n        path.replaceWith(_core.types.booleanLiteral(true));\n      }\n    }\n  },\n  ThisExpression(path, state) {\n    state.needsClassRef = true;\n    path.replaceWith(_core.types.cloneNode(state.classRef));\n  },\n  MetaProperty(path) {\n    const {\n      node,\n      scope\n    } = path;\n    if (node.meta.name === \"new\" && node.property.name === \"target\") {\n      path.replaceWith(scope.buildUndefinedNode());\n    }\n  }\n}, _helperEnvironmentVisitor.default]);\nconst innerReferencesVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  }\n};\nfunction replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {\n  var _state$classRef;\n  const state = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef\n  };\n  const replacer = new _helperReplaceSupers.default({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n    getObjectRef() {\n      state.needsClassRef = true;\n      return _core.types.isStaticBlock != null && _core.types.isStaticBlock(path.node) || path.node.static ? ref : _core.types.memberExpression(ref, _core.types.identifier(\"prototype\"));\n    }\n  });\n  replacer.replace();\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n  if (innerBindingRef != null && (_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n  return state.needsClassRef;\n}\nfunction isNameOrLength({\n  key,\n  computed\n}) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\nfunction inheritPropComments(node, prop) {\n  _core.types.inheritLeadingComments(node, prop.node);\n  _core.types.inheritInnerComments(node, prop.node);\n  return node;\n}\nfunction buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {\n  let needsClassRef = false;\n  let injectSuperRef;\n  const staticNodes = [];\n  const instanceNodes = [];\n  const pureStaticNodes = [];\n  const getSuperRef = _core.types.isIdentifier(superRef) ? () => superRef : () => {\n    var _injectSuperRef;\n    (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n    return injectSuperRef;\n  };\n  for (const prop of props) {\n    prop.isClassProperty() && ts.assertFieldTransformed(prop);\n    const isStatic = !(_core.types.isStaticBlock != null && _core.types.isStaticBlock(prop.node)) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();\n    if (isStatic || isMethod && isPrivate || isStaticBlock) {\n      const replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);\n      needsClassRef = needsClassRef || replaced;\n    }\n    switch (true) {\n      case isStaticBlock:\n        {\n          const blockBody = prop.node.body;\n          if (blockBody.length === 1 && _core.types.isExpressionStatement(blockBody[0])) {\n            staticNodes.push(inheritPropComments(blockBody[0], prop));\n          } else {\n            staticNodes.push(_core.types.inheritsComments(_core.template.statement.ast`(() => { ${blockBody} })()`, prop.node));\n          }\n          break;\n        }\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateFieldInitLoose(_core.types.cloneNode(ref), prop, privateNamesMap));\n        break;\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          staticNodes.push(buildPublicFieldInitLoose(_core.types.cloneNode(ref), prop));\n          break;\n        }\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(buildPublicFieldInitSpec(_core.types.cloneNode(ref), prop, state));\n        break;\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateFieldInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        break;\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(buildPrivateInstanceFieldInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        break;\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateMethodInitLoose(_core.types.thisExpression(), prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(_core.types.thisExpression(), prop, privateNamesMap, state));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(buildPrivateStaticMethodInitLoose(_core.types.cloneNode(ref), prop, state, privateNamesMap));\n        pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitLoose(_core.types.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(buildPublicFieldInitSpec(_core.types.thisExpression(), prop, state));\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    wrapClass(path) {\n      for (const prop of props) {\n        prop.node.leadingComments = null;\n        prop.remove();\n      }\n      if (injectSuperRef) {\n        path.scope.push({\n          id: _core.types.cloneNode(injectSuperRef)\n        });\n        path.set(\"superClass\", _core.types.assignmentExpression(\"=\", injectSuperRef, path.node.superClass));\n      }\n      if (!needsClassRef) return path;\n      if (path.isClassExpression()) {\n        path.scope.push({\n          id: ref\n        });\n        path.replaceWith(_core.types.assignmentExpression(\"=\", _core.types.cloneNode(ref), path.node));\n      } else if (!path.node.id) {\n        path.node.id = ref;\n      }\n      return path;\n    }\n  };\n}","map":{"version":3,"names":["_core","require","_helperReplaceSupers","_helperEnvironmentVisitor","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","_helperAnnotateAsPure","_helperSkipTransparentExpressionWrappers","ts","buildPrivateNamesMap","props","privateNamesMap","Map","prop","isPrivate","name","node","key","id","update","has","get","scope","generateUidIdentifier","static","method","isProperty","isClassPrivateMethod","kind","getId","setId","methodId","set","buildPrivateNamesNodes","privateFieldsAsProperties","privateFieldsAsSymbols","state","initNodes","value","isStatic","isMethod","isAccessor","types","cloneNode","init","callExpression","addHelper","stringLiteral","identifier","newExpression","default","push","template","statement","ast","privateNameVisitorFactory","visitor","nestedVisitor","traverse","visitors","merge","Object","assign","privateNameVisitor","Class","path","body","visiblePrivateNames","redeclared","delete","length","skipKey","PrivateName","noDocumentAll","parentPath","isMemberExpression","property","isOptionalMemberExpression","includes","handle","unshadow","innerBinding","_scope","hasBinding","bindingIdentifierEquals","rename","parent","buildCheckInRHS","rhs","file","inRHSIsObject","availableHelper","privateInVisitor","BinaryExpression","operator","left","right","isPrivateName","classRef","replaceWith","expression","privateNameHandlerSpec","memoise","member","count","object","memo","maybeGenerateMemoised","memoiser","receiver","helperName","sequenceExpression","console","warn","boundGet","memberExpression","destructureSet","helper","_unused","Error","call","args","optionalCall","privateNameHandlerLoose","BASE","REF","PROP","simpleSet","optionalCallExpression","transformPrivateNamesUsage","ref","size","handler","buildPrivateFieldInitLoose","buildUndefinedNode","inheritPropComments","buildPrivateInstanceFieldInitSpec","thisExpression","buildPrivateStaticFieldInitSpec","privateName","initAdded","buildPrivateMethodInitLoose","buildPrivateInstanceMethodInitSpec","buildPrivateAccessorInitialization","buildPrivateInstanceMethodInitialization","buildPublicFieldInitLoose","computed","expressionStatement","assignmentExpression","isLiteral","buildPublicFieldInitSpec","buildPrivateStaticMethodInitLoose","buildPrivateMethodDeclaration","getterDeclared","setterDeclared","params","generator","async","isGetter","isSetter","declId","functionDeclaration","thisContextVisitor","UnaryExpression","argument","skipTransparentExprWrapperNodes","isThisExpression","booleanLiteral","ThisExpression","needsClassRef","MetaProperty","meta","innerReferencesVisitor","ReferencedIdentifier","replaceThisContext","getSuperRef","isStaticBlock","constantSuper","innerBindingRef","_state$classRef","replacer","methodPath","refToPreserve","getObjectRef","replace","isNameOrLength","type","inheritLeadingComments","inheritInnerComments","buildFieldsInitNodes","superRef","setPublicClassFields","injectSuperRef","staticNodes","instanceNodes","pureStaticNodes","isIdentifier","_injectSuperRef","generateUidIdentifierBasedOnNode","isClassProperty","assertFieldTransformed","isInstance","isPublic","isField","replaced","blockBody","isExpressionStatement","inheritsComments","unshift","filter","Boolean","wrapClass","leadingComments","remove","superClass","isClassExpression"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/@babel/helper-create-class-features-plugin/src/fields.ts"],"sourcesContent":["import { template, traverse, types as t } from \"@babel/core\";\nimport type { File } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/traverse\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport memberExpressionToFunctions from \"@babel/helper-member-expression-to-functions\";\nimport type {\n  Handler,\n  HandlerState,\n} from \"@babel/helper-member-expression-to-functions\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\nimport { skipTransparentExprWrapperNodes } from \"@babel/helper-skip-transparent-expression-wrappers\";\n\nimport * as ts from \"./typescript\";\n\ninterface PrivateNameMetadata {\n  id: t.Identifier;\n  static: boolean;\n  method: boolean;\n  getId?: t.Identifier;\n  setId?: t.Identifier;\n  methodId?: t.Identifier;\n  initAdded?: boolean;\n  getterDeclared?: boolean;\n  setterDeclared?: boolean;\n}\n\ntype PrivateNamesMap = Map<string, PrivateNameMetadata>;\n\nexport function buildPrivateNamesMap(props: PropPath[]) {\n  const privateNamesMap: PrivateNamesMap = new Map();\n  for (const prop of props) {\n    if (prop.isPrivate()) {\n      const { name } = prop.node.key.id;\n      const update: PrivateNameMetadata = privateNamesMap.has(name)\n        ? privateNamesMap.get(name)\n        : {\n            id: prop.scope.generateUidIdentifier(name),\n            static: prop.node.static,\n            method: !prop.isProperty(),\n          };\n      if (prop.isClassPrivateMethod()) {\n        if (prop.node.kind === \"get\") {\n          update.getId = prop.scope.generateUidIdentifier(`get_${name}`);\n        } else if (prop.node.kind === \"set\") {\n          update.setId = prop.scope.generateUidIdentifier(`set_${name}`);\n        } else if (prop.node.kind === \"method\") {\n          update.methodId = prop.scope.generateUidIdentifier(name);\n        }\n      }\n      privateNamesMap.set(name, update);\n    }\n  }\n  return privateNamesMap;\n}\n\nexport function buildPrivateNamesNodes(\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties: boolean,\n  privateFieldsAsSymbols: boolean,\n  state: File,\n) {\n  const initNodes: t.Statement[] = [];\n\n  for (const [name, value] of privateNamesMap) {\n    // - When the privateFieldsAsProperties assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   secret non-enumerable property. Hence, we also need to generate that\n    //   key (using the classPrivateFieldLooseKey helper).\n    // - When the privateFieldsAsSymbols assumption is enabled,\n    //   both static and instance fields are transpiled using a\n    //   unique Symbol to define a non-enumerable property.\n    // - In spec mode, only instance fields need a \"private name\" initializer\n    //   because static fields are directly assigned to a variable in the\n    //   buildPrivateStaticFieldInitSpec function.\n    const { static: isStatic, method: isMethod, getId, setId } = value;\n    const isAccessor = getId || setId;\n    const id = t.cloneNode(value.id);\n\n    let init: t.Expression;\n\n    if (privateFieldsAsProperties) {\n      init = t.callExpression(state.addHelper(\"classPrivateFieldLooseKey\"), [\n        t.stringLiteral(name),\n      ]);\n    } else if (privateFieldsAsSymbols) {\n      init = t.callExpression(t.identifier(\"Symbol\"), [t.stringLiteral(name)]);\n    } else if (!isStatic) {\n      init = t.newExpression(\n        t.identifier(!isMethod || isAccessor ? \"WeakMap\" : \"WeakSet\"),\n        [],\n      );\n    }\n\n    if (init) {\n      annotateAsPure(init);\n      initNodes.push(template.statement.ast`var ${id} = ${init}`);\n    }\n  }\n\n  return initNodes;\n}\n\ninterface PrivateNameVisitorState {\n  privateNamesMap: PrivateNamesMap;\n  privateFieldsAsProperties: boolean;\n  redeclared?: string[];\n}\n\n// Traverses the class scope, handling private name references. If an inner\n// class redeclares the same private name, it will hand off traversal to the\n// restricted visitor (which doesn't traverse the inner class's inner scope).\nfunction privateNameVisitorFactory<S>(\n  visitor: Visitor<PrivateNameVisitorState & S>,\n) {\n  // Traverses the outer portion of a class, without touching the class's inner\n  // scope, for private names.\n  const nestedVisitor = traverse.visitors.merge([\n    {\n      ...visitor,\n    },\n    environmentVisitor,\n  ]);\n\n  const privateNameVisitor: Visitor<PrivateNameVisitorState & S> = {\n    ...visitor,\n\n    Class(path) {\n      const { privateNamesMap } = this;\n      const body = path.get(\"body.body\");\n\n      const visiblePrivateNames = new Map(privateNamesMap);\n      const redeclared = [];\n      for (const prop of body) {\n        if (!prop.isPrivate()) continue;\n        const { name } = prop.node.key.id;\n        visiblePrivateNames.delete(name);\n        redeclared.push(name);\n      }\n\n      // If the class doesn't redeclare any private fields, we can continue with\n      // our overall traversal.\n      if (!redeclared.length) {\n        return;\n      }\n\n      // This class redeclares some private field. We need to process the outer\n      // environment with access to all the outer privates, then we can process\n      // the inner environment with only the still-visible outer privates.\n      path.get(\"body\").traverse(nestedVisitor, {\n        ...this,\n        redeclared,\n      });\n      path.traverse(privateNameVisitor, {\n        ...this,\n        privateNamesMap: visiblePrivateNames,\n      });\n\n      // We'll eventually hit this class node again with the overall Class\n      // Features visitor, which'll process the redeclared privates.\n      path.skipKey(\"body\");\n    },\n  };\n\n  return privateNameVisitor;\n}\n\ninterface PrivateNameState {\n  privateNamesMap: PrivateNamesMap;\n  classRef: t.Identifier;\n  file: File;\n  noDocumentAll: boolean;\n  innerBinding?: t.Identifier;\n}\n\nconst privateNameVisitor = privateNameVisitorFactory<\n  HandlerState<PrivateNameState> & PrivateNameState\n>({\n  PrivateName(path, { noDocumentAll }) {\n    const { privateNamesMap, redeclared } = this;\n    const { node, parentPath } = path;\n\n    if (\n      !parentPath.isMemberExpression({ property: node }) &&\n      !parentPath.isOptionalMemberExpression({ property: node })\n    ) {\n      return;\n    }\n    const { name } = node.id;\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    this.handle(parentPath, noDocumentAll);\n  },\n});\n\n// rename all bindings that shadows innerBinding\nfunction unshadow(\n  name: string,\n  scope: Scope,\n  innerBinding: t.Identifier | undefined,\n) {\n  // in some cases, scope.getBinding(name) === undefined\n  // so we check hasBinding to avoid keeping looping\n  // see: https://github.com/babel/babel/pull/13656#discussion_r686030715\n  while (\n    scope?.hasBinding(name) &&\n    !scope.bindingIdentifierEquals(name, innerBinding)\n  ) {\n    scope.rename(name);\n    scope = scope.parent;\n  }\n}\n\nexport function buildCheckInRHS(\n  rhs: t.Expression,\n  file: File,\n  inRHSIsObject?: boolean,\n) {\n  if (inRHSIsObject || !file.availableHelper?.(\"checkInRHS\")) return rhs;\n  return t.callExpression(file.addHelper(\"checkInRHS\"), [rhs]);\n}\n\nconst privateInVisitor = privateNameVisitorFactory<{\n  classRef: t.Identifier;\n  file: File;\n  innerBinding?: t.Identifier;\n}>({\n  BinaryExpression(path, { file }) {\n    const { operator, left, right } = path.node;\n    if (operator !== \"in\") return;\n    if (!t.isPrivateName(left)) return;\n\n    const { privateFieldsAsProperties, privateNamesMap, redeclared } = this;\n\n    const { name } = left.id;\n\n    if (!privateNamesMap.has(name)) return;\n    if (redeclared && redeclared.includes(name)) return;\n\n    // if there are any local variable shadowing classRef, unshadow it\n    // see #12960\n    unshadow(this.classRef.name, path.scope, this.innerBinding);\n\n    if (privateFieldsAsProperties) {\n      const { id } = privateNamesMap.get(name);\n      path.replaceWith(template.expression.ast`\n        Object.prototype.hasOwnProperty.call(${buildCheckInRHS(\n          right,\n          file,\n        )}, ${t.cloneNode(id)})\n      `);\n      return;\n    }\n\n    const { id, static: isStatic } = privateNamesMap.get(name);\n\n    if (isStatic) {\n      path.replaceWith(\n        template.expression.ast`${buildCheckInRHS(\n          right,\n          file,\n        )} === ${t.cloneNode(this.classRef)}`,\n      );\n      return;\n    }\n\n    path.replaceWith(\n      template.expression.ast`${t.cloneNode(id)}.has(${buildCheckInRHS(\n        right,\n        file,\n      )})`,\n    );\n  },\n});\n\ninterface Receiver {\n  receiver(\n    this: HandlerState<PrivateNameState> & PrivateNameState,\n    member: NodePath<t.MemberExpression | t.OptionalMemberExpression>,\n  ): t.Expression;\n}\n\nconst privateNameHandlerSpec: Handler<PrivateNameState & Receiver> & Receiver =\n  {\n    memoise(member, count) {\n      const { scope } = member;\n      const { object } = member.node as { object: t.Expression };\n\n      const memo = scope.maybeGenerateMemoised(object);\n      if (!memo) {\n        return;\n      }\n\n      this.memoiser.set(object, memo, count);\n    },\n\n    receiver(member) {\n      const { object } = member.node as { object: t.Expression };\n\n      if (this.memoiser.has(object)) {\n        return t.cloneNode(this.memoiser.get(object));\n      }\n\n      return t.cloneNode(object);\n    },\n\n    get(member) {\n      const { classRef, privateNamesMap, file, innerBinding } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        methodId,\n        getId,\n        setId,\n      } = privateNamesMap.get(name);\n      const isAccessor = getId || setId;\n\n      if (isStatic) {\n        // NOTE: This package has a peerDependency on @babel/core@^7.0.0, but these\n        // helpers have been introduced in @babel/helpers@7.1.0.\n        const helperName =\n          isMethod && !isAccessor\n            ? \"classStaticPrivateMethodGet\"\n            : \"classStaticPrivateFieldSpecGet\";\n\n        // if there are any local variable shadowing classRef, unshadow it\n        // see #12960\n        unshadow(classRef.name, member.scope, innerBinding);\n\n        return t.callExpression(file.addHelper(helperName), [\n          this.receiver(member),\n          t.cloneNode(classRef),\n          t.cloneNode(id),\n        ]);\n      }\n\n      if (isMethod) {\n        if (isAccessor) {\n          if (!getId && setId) {\n            if (file.availableHelper(\"writeOnlyError\")) {\n              return t.sequenceExpression([\n                this.receiver(member),\n                t.callExpression(file.addHelper(\"writeOnlyError\"), [\n                  t.stringLiteral(`#${name}`),\n                ]),\n              ]);\n            }\n            console.warn(\n              `@babel/helpers is outdated, update it to silence this warning.`,\n            );\n          }\n          return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n          ]);\n        }\n        return t.callExpression(file.addHelper(\"classPrivateMethodGet\"), [\n          this.receiver(member),\n          t.cloneNode(id),\n          t.cloneNode(methodId),\n        ]);\n      }\n      return t.callExpression(file.addHelper(\"classPrivateFieldGet\"), [\n        this.receiver(member),\n        t.cloneNode(id),\n      ]);\n    },\n\n    boundGet(member) {\n      this.memoise(member, 1);\n\n      return t.callExpression(\n        t.memberExpression(this.get(member), t.identifier(\"bind\")),\n        [this.receiver(member)],\n      );\n    },\n\n    set(member, value) {\n      const { classRef, privateNamesMap, file } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const {\n        id,\n        static: isStatic,\n        method: isMethod,\n        setId,\n        getId,\n      } = privateNamesMap.get(name);\n      const isAccessor = getId || setId;\n\n      if (isStatic) {\n        const helperName =\n          isMethod && !isAccessor\n            ? \"classStaticPrivateMethodSet\"\n            : \"classStaticPrivateFieldSpecSet\";\n\n        return t.callExpression(file.addHelper(helperName), [\n          this.receiver(member),\n          t.cloneNode(classRef),\n          t.cloneNode(id),\n          value,\n        ]);\n      }\n      if (isMethod) {\n        if (setId) {\n          return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n            this.receiver(member),\n            t.cloneNode(id),\n            value,\n          ]);\n        }\n        return t.sequenceExpression([\n          this.receiver(member),\n          value,\n          t.callExpression(file.addHelper(\"readOnlyError\"), [\n            t.stringLiteral(`#${name}`),\n          ]),\n        ]);\n      }\n      return t.callExpression(file.addHelper(\"classPrivateFieldSet\"), [\n        this.receiver(member),\n        t.cloneNode(id),\n        value,\n      ]);\n    },\n\n    destructureSet(member) {\n      const { classRef, privateNamesMap, file } = this;\n      const { name } = (member.node.property as t.PrivateName).id;\n      const { id, static: isStatic } = privateNamesMap.get(name);\n      if (isStatic) {\n        try {\n          // classStaticPrivateFieldDestructureSet was introduced in 7.13.10\n          // eslint-disable-next-line no-var\n          var helper = file.addHelper(\"classStaticPrivateFieldDestructureSet\");\n        } catch {\n          throw new Error(\n            \"Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \\n\" +\n              \"please update @babel/helpers to the latest version.\",\n          );\n        }\n        return t.memberExpression(\n          t.callExpression(helper, [\n            this.receiver(member),\n            t.cloneNode(classRef),\n            t.cloneNode(id),\n          ]),\n          t.identifier(\"value\"),\n        );\n      }\n\n      return t.memberExpression(\n        t.callExpression(file.addHelper(\"classPrivateFieldDestructureSet\"), [\n          this.receiver(member),\n          t.cloneNode(id),\n        ]),\n        t.identifier(\"value\"),\n      );\n    },\n\n    call(member, args: (t.Expression | t.SpreadElement)[]) {\n      // The first access (the get) should do the memo assignment.\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, false);\n    },\n\n    optionalCall(member, args: (t.Expression | t.SpreadElement)[]) {\n      this.memoise(member, 1);\n\n      return optimiseCall(this.get(member), this.receiver(member), args, true);\n    },\n\n    delete() {\n      throw new Error(\n        \"Internal Babel error: deleting private elements is a parsing error.\",\n      );\n    },\n  };\n\nconst privateNameHandlerLoose: Handler<PrivateNameState> = {\n  get(member) {\n    const { privateNamesMap, file } = this;\n    const { object } = member.node;\n    const { name } = (member.node.property as t.PrivateName).id;\n\n    return template.expression`BASE(REF, PROP)[PROP]`({\n      BASE: file.addHelper(\"classPrivateFieldLooseBase\"),\n      REF: t.cloneNode(object),\n      PROP: t.cloneNode(privateNamesMap.get(name).id),\n    });\n  },\n\n  set() {\n    // noop\n    throw new Error(\"private name handler with loose = true don't need set()\");\n  },\n\n  boundGet(member) {\n    return t.callExpression(\n      t.memberExpression(this.get(member), t.identifier(\"bind\")),\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      [t.cloneNode(member.node.object as t.Expression)],\n    );\n  },\n\n  simpleSet(member) {\n    return this.get(member);\n  },\n\n  destructureSet(member) {\n    return this.get(member);\n  },\n\n  call(member, args) {\n    return t.callExpression(this.get(member), args);\n  },\n\n  optionalCall(member, args) {\n    return t.optionalCallExpression(this.get(member), args, true);\n  },\n\n  delete() {\n    throw new Error(\n      \"Internal Babel error: deleting private elements is a parsing error.\",\n    );\n  },\n};\n\nexport function transformPrivateNamesUsage(\n  ref: t.Identifier,\n  path: NodePath<t.Class>,\n  privateNamesMap: PrivateNamesMap,\n  {\n    privateFieldsAsProperties,\n    noDocumentAll,\n    innerBinding,\n  }: {\n    privateFieldsAsProperties: boolean;\n    noDocumentAll: boolean;\n    innerBinding: t.Identifier;\n  },\n  state: File,\n) {\n  if (!privateNamesMap.size) return;\n\n  const body = path.get(\"body\");\n  const handler = privateFieldsAsProperties\n    ? privateNameHandlerLoose\n    : privateNameHandlerSpec;\n\n  memberExpressionToFunctions<PrivateNameState>(body, privateNameVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    ...handler,\n    noDocumentAll,\n    innerBinding,\n  });\n  body.traverse(privateInVisitor, {\n    privateNamesMap,\n    classRef: ref,\n    file: state,\n    privateFieldsAsProperties,\n    innerBinding,\n  });\n}\n\nfunction buildPrivateFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${t.cloneNode(id)}, {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      });\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateInstanceFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const { id } = privateNamesMap.get(prop.node.key.id.name);\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`${t.cloneNode(id)}.set(${ref}, {\n          // configurable is always false for private elements\n          // enumerable is always false for private elements\n          writable: true,\n          value: ${value},\n        })`,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)},\n      {\n        writable: true,\n        value: ${value}\n      },\n    )`,\n    prop,\n  );\n}\n\nfunction buildPrivateStaticFieldInitSpec(\n  prop: NodePath<t.ClassPrivateProperty>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId, initAdded } = privateName;\n  const isAccessor = getId || setId;\n\n  if (!prop.isProperty() && (initAdded || !isAccessor)) return;\n\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        var ${t.cloneNode(id)} = {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        }\n      `,\n      prop,\n    );\n  }\n\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n  return inheritPropComments(\n    template.statement.ast`\n      var ${t.cloneNode(id)} = {\n        // configurable is false by default\n        // enumerable is false by default\n        writable: true,\n        value: ${value}\n      };\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { methodId, id, getId, setId, initAdded } = privateName;\n  if (initAdded) return;\n\n  if (methodId) {\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ${methodId.name}\n        });\n      `,\n      prop,\n    );\n  }\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        });\n      `,\n      prop,\n    );\n  }\n}\n\nfunction buildPrivateInstanceMethodInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    return buildPrivateAccessorInitialization(\n      ref,\n      prop,\n      privateNamesMap,\n      state,\n    );\n  }\n\n  return buildPrivateInstanceMethodInitialization(\n    ref,\n    prop,\n    privateNamesMap,\n    state,\n  );\n}\n\nfunction buildPrivateAccessorInitialization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, getId, setId } = privateName;\n\n  privateNamesMap.set(prop.node.key.id.name, {\n    ...privateName,\n    initAdded: true,\n  });\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateFieldInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`\n          ${id}.set(${ref}, {\n            get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n            set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n          });\n        `,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateFieldInitSpec\");\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)},\n      {\n        get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n        set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n      },\n    )`,\n    prop,\n  );\n}\n\nfunction buildPrivateInstanceMethodInitialization(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id } = privateName;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    if (!state.availableHelper(\"classPrivateMethodInitSpec\")) {\n      return inheritPropComments(\n        template.statement.ast`${id}.add(${ref})`,\n        prop,\n      );\n    }\n  }\n\n  const helper = state.addHelper(\"classPrivateMethodInitSpec\");\n  return inheritPropComments(\n    template.statement.ast`${helper}(\n      ${t.thisExpression()},\n      ${t.cloneNode(id)}\n    )`,\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.assignmentExpression(\n        \"=\",\n        t.memberExpression(ref, key, computed || t.isLiteral(key)),\n        value,\n      ),\n    ),\n    prop,\n  );\n}\n\nfunction buildPublicFieldInitSpec(\n  ref: t.Expression,\n  prop: NodePath<t.ClassProperty>,\n  state: File,\n) {\n  const { key, computed } = prop.node;\n  const value = prop.node.value || prop.scope.buildUndefinedNode();\n\n  return inheritPropComments(\n    t.expressionStatement(\n      t.callExpression(state.addHelper(\"defineProperty\"), [\n        ref,\n        computed || t.isLiteral(key)\n          ? key\n          : t.stringLiteral((key as t.Identifier).name),\n        value,\n      ]),\n    ),\n    prop,\n  );\n}\n\nfunction buildPrivateStaticMethodInitLoose(\n  ref: t.Expression,\n  prop: NodePath<t.ClassPrivateMethod>,\n  state: File,\n  privateNamesMap: PrivateNamesMap,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const { id, methodId, getId, setId, initAdded } = privateName;\n\n  if (initAdded) return;\n\n  const isAccessor = getId || setId;\n  if (isAccessor) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      initAdded: true,\n    });\n\n    return inheritPropComments(\n      template.statement.ast`\n        Object.defineProperty(${ref}, ${id}, {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          get: ${getId ? getId.name : prop.scope.buildUndefinedNode()},\n          set: ${setId ? setId.name : prop.scope.buildUndefinedNode()}\n        })\n      `,\n      prop,\n    );\n  }\n\n  return inheritPropComments(\n    template.statement.ast`\n      Object.defineProperty(${ref}, ${id}, {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        value: ${methodId.name}\n      });\n    `,\n    prop,\n  );\n}\n\nfunction buildPrivateMethodDeclaration(\n  prop: NodePath<t.ClassPrivateMethod>,\n  privateNamesMap: PrivateNamesMap,\n  privateFieldsAsProperties = false,\n) {\n  const privateName = privateNamesMap.get(prop.node.key.id.name);\n  const {\n    id,\n    methodId,\n    getId,\n    setId,\n    getterDeclared,\n    setterDeclared,\n    static: isStatic,\n  } = privateName;\n  const { params, body, generator, async } = prop.node;\n  const isGetter = getId && !getterDeclared && params.length === 0;\n  const isSetter = setId && !setterDeclared && params.length > 0;\n\n  let declId = methodId;\n\n  if (isGetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      getterDeclared: true,\n    });\n    declId = getId;\n  } else if (isSetter) {\n    privateNamesMap.set(prop.node.key.id.name, {\n      ...privateName,\n      setterDeclared: true,\n    });\n    declId = setId;\n  } else if (isStatic && !privateFieldsAsProperties) {\n    declId = id;\n  }\n\n  return inheritPropComments(\n    t.functionDeclaration(\n      t.cloneNode(declId),\n      // @ts-expect-error params for ClassMethod has TSParameterProperty\n      params,\n      body,\n      generator,\n      async,\n    ),\n    prop,\n  );\n}\n\ntype ReplaceThisState = {\n  classRef: t.Identifier;\n  needsClassRef: boolean;\n  innerBinding: t.Identifier | null;\n};\n\nconst thisContextVisitor = traverse.visitors.merge<ReplaceThisState>([\n  {\n    UnaryExpression(path) {\n      // Replace `delete this` with `true`\n      const { node } = path;\n      if (node.operator === \"delete\") {\n        const argument = skipTransparentExprWrapperNodes(node.argument);\n        if (t.isThisExpression(argument)) {\n          path.replaceWith(t.booleanLiteral(true));\n        }\n      }\n    },\n    ThisExpression(path, state) {\n      state.needsClassRef = true;\n      path.replaceWith(t.cloneNode(state.classRef));\n    },\n    MetaProperty(path) {\n      const { node, scope } = path;\n      // if there are `new.target` in static field\n      // we should replace it with `undefined`\n      if (node.meta.name === \"new\" && node.property.name === \"target\") {\n        path.replaceWith(scope.buildUndefinedNode());\n      }\n    },\n  },\n  environmentVisitor,\n]);\n\nconst innerReferencesVisitor: Visitor<ReplaceThisState> = {\n  ReferencedIdentifier(path, state) {\n    if (\n      path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)\n    ) {\n      state.needsClassRef = true;\n      path.node.name = state.classRef.name;\n    }\n  },\n};\n\nfunction replaceThisContext(\n  path: PropPath,\n  ref: t.Identifier,\n  getSuperRef: () => t.Identifier,\n  file: File,\n  isStaticBlock: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier | null,\n) {\n  const state: ReplaceThisState = {\n    classRef: ref,\n    needsClassRef: false,\n    innerBinding: innerBindingRef,\n  };\n\n  const replacer = new ReplaceSupers({\n    methodPath: path,\n    constantSuper,\n    file,\n    refToPreserve: ref,\n    getSuperRef,\n    getObjectRef() {\n      state.needsClassRef = true;\n      // @ts-expect-error: TS doesn't infer that path.node is not a StaticBlock\n      return t.isStaticBlock?.(path.node) || path.node.static\n        ? ref\n        : t.memberExpression(ref, t.identifier(\"prototype\"));\n    },\n  });\n  replacer.replace();\n  if (isStaticBlock || path.isProperty()) {\n    path.traverse(thisContextVisitor, state);\n  }\n\n  // todo: use innerBinding.referencePaths to avoid full traversal\n  if (\n    innerBindingRef != null &&\n    state.classRef?.name &&\n    state.classRef.name !== innerBindingRef?.name\n  ) {\n    path.traverse(innerReferencesVisitor, state);\n  }\n\n  return state.needsClassRef;\n}\n\nexport type PropNode =\n  | t.ClassProperty\n  | t.ClassPrivateMethod\n  | t.ClassPrivateProperty\n  | t.StaticBlock;\nexport type PropPath = NodePath<PropNode>;\n\nfunction isNameOrLength({ key, computed }: t.ClassProperty) {\n  if (key.type === \"Identifier\") {\n    return !computed && (key.name === \"name\" || key.name === \"length\");\n  }\n  if (key.type === \"StringLiteral\") {\n    return key.value === \"name\" || key.value === \"length\";\n  }\n  return false;\n}\n\n/**\n * Inherit comments from class members. This is a reduced version of\n * t.inheritsComments: the trailing comments are not inherited because\n * for most class members except the last one, their trailing comments are\n * the next sibling's leading comments.\n *\n * @template T transformed class member type\n * @param {T} node transformed class member\n * @param {PropPath} prop class member\n * @returns transformed class member type with comments inherited\n */\nfunction inheritPropComments<T extends t.Node>(node: T, prop: PropPath) {\n  t.inheritLeadingComments(node, prop.node);\n  t.inheritInnerComments(node, prop.node);\n  return node;\n}\n\nexport function buildFieldsInitNodes(\n  ref: t.Identifier,\n  superRef: t.Expression | undefined,\n  props: PropPath[],\n  privateNamesMap: PrivateNamesMap,\n  state: File,\n  setPublicClassFields: boolean,\n  privateFieldsAsProperties: boolean,\n  constantSuper: boolean,\n  innerBindingRef: t.Identifier,\n) {\n  let needsClassRef = false;\n  let injectSuperRef: t.Identifier;\n  const staticNodes: t.Statement[] = [];\n  const instanceNodes: t.Statement[] = [];\n  // These nodes are pure and can be moved to the closest statement position\n  const pureStaticNodes: t.FunctionDeclaration[] = [];\n\n  const getSuperRef = t.isIdentifier(superRef)\n    ? () => superRef\n    : () => {\n        injectSuperRef ??=\n          props[0].scope.generateUidIdentifierBasedOnNode(superRef);\n        return injectSuperRef;\n      };\n\n  for (const prop of props) {\n    prop.isClassProperty() && ts.assertFieldTransformed(prop);\n\n    // @ts-expect-error: TS doesn't infer that prop.node is not a StaticBlock\n    const isStatic = !t.isStaticBlock?.(prop.node) && prop.node.static;\n    const isInstance = !isStatic;\n    const isPrivate = prop.isPrivate();\n    const isPublic = !isPrivate;\n    const isField = prop.isProperty();\n    const isMethod = !isField;\n    const isStaticBlock = prop.isStaticBlock?.();\n\n    if (isStatic || (isMethod && isPrivate) || isStaticBlock) {\n      const replaced = replaceThisContext(\n        prop,\n        ref,\n        getSuperRef,\n        state,\n        isStaticBlock,\n        constantSuper,\n        innerBindingRef,\n      );\n      needsClassRef = needsClassRef || replaced;\n    }\n\n    // TODO(ts): there are so many `ts-expect-error` inside cases since\n    // ts can not infer type from pre-computed values (or a case test)\n    // even change `isStaticBlock` to `t.isStaticBlock(prop)` will not make prop\n    // a `NodePath<t.StaticBlock>`\n    // this maybe a bug for ts\n    switch (true) {\n      case isStaticBlock: {\n        const blockBody = (prop.node as t.StaticBlock).body;\n        // We special-case the single expression case to avoid the iife, since\n        // it's common.\n        if (blockBody.length === 1 && t.isExpressionStatement(blockBody[0])) {\n          staticNodes.push(inheritPropComments(blockBody[0], prop));\n        } else {\n          staticNodes.push(\n            t.inheritsComments(\n              template.statement.ast`(() => { ${blockBody} })()`,\n              prop.node,\n            ),\n          );\n        }\n        break;\n      }\n      case isStatic && isPrivate && isField && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.cloneNode(ref), prop, privateNamesMap),\n        );\n        break;\n      case isStatic && isPrivate && isField && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        break;\n      case isStatic && isPublic && isField && setPublicClassFields:\n        // Functions always have non-writable .name and .length properties,\n        // so we must always use [[Define]] for them.\n        // It might still be possible to a computed static fields whose resulting\n        // key is \"name\" or \"length\", but the assumption is telling us that it's\n        // not going to happen.\n        // @ts-expect-error checked in switch\n        if (!isNameOrLength(prop.node)) {\n          needsClassRef = true;\n          // @ts-expect-error checked in switch\n          staticNodes.push(buildPublicFieldInitLoose(t.cloneNode(ref), prop));\n          break;\n        }\n      // falls through\n      case isStatic && isPublic && isField && !setPublicClassFields:\n        needsClassRef = true;\n        staticNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.cloneNode(ref), prop, state),\n        );\n        break;\n      case isInstance && isPrivate && isField && privateFieldsAsProperties:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPrivateFieldInitLoose(t.thisExpression(), prop, privateNamesMap),\n        );\n        break;\n      case isInstance && isPrivate && isField && !privateFieldsAsProperties:\n        instanceNodes.push(\n          buildPrivateInstanceFieldInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        break;\n      case isInstance && isPrivate && isMethod && privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateMethodInitLoose(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:\n        instanceNodes.unshift(\n          buildPrivateInstanceMethodInitSpec(\n            t.thisExpression(),\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            state,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          // @ts-expect-error checked in switch\n          buildPrivateStaticFieldInitSpec(prop, privateNamesMap),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isStatic && isPrivate && isMethod && privateFieldsAsProperties:\n        needsClassRef = true;\n        staticNodes.unshift(\n          buildPrivateStaticMethodInitLoose(\n            t.cloneNode(ref),\n            // @ts-expect-error checked in switch\n            prop,\n            state,\n            privateNamesMap,\n          ),\n        );\n        pureStaticNodes.push(\n          buildPrivateMethodDeclaration(\n            // @ts-expect-error checked in switch\n            prop,\n            privateNamesMap,\n            privateFieldsAsProperties,\n          ),\n        );\n        break;\n      case isInstance && isPublic && isField && setPublicClassFields:\n        // @ts-expect-error checked in switch\n        instanceNodes.push(buildPublicFieldInitLoose(t.thisExpression(), prop));\n        break;\n      case isInstance && isPublic && isField && !setPublicClassFields:\n        instanceNodes.push(\n          // @ts-expect-error checked in switch\n          buildPublicFieldInitSpec(t.thisExpression(), prop, state),\n        );\n        break;\n      default:\n        throw new Error(\"Unreachable.\");\n    }\n  }\n\n  return {\n    staticNodes: staticNodes.filter(Boolean),\n    instanceNodes: instanceNodes.filter(Boolean),\n    pureStaticNodes: pureStaticNodes.filter(Boolean),\n    wrapClass(path: NodePath<t.Class>) {\n      for (const prop of props) {\n        // Delete leading comments so that they don't get attached as\n        // trailing comments of the previous sibling.\n        // When transforming props, we explicitly attach their leading\n        // comments to the transformed node with `inheritPropComments`\n        // above.\n        prop.node.leadingComments = null;\n        prop.remove();\n      }\n\n      if (injectSuperRef) {\n        path.scope.push({ id: t.cloneNode(injectSuperRef) });\n        path.set(\n          \"superClass\",\n          t.assignmentExpression(\"=\", injectSuperRef, path.node.superClass),\n        );\n      }\n\n      if (!needsClassRef) return path;\n\n      if (path.isClassExpression()) {\n        path.scope.push({ id: ref });\n        path.replaceWith(\n          t.assignmentExpression(\"=\", t.cloneNode(ref), path.node),\n        );\n      } else if (!path.node.id) {\n        // Anonymous class declaration\n        path.node.id = ref;\n      }\n\n      return path;\n    },\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}