{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar helperPluginUtils = require('@babel/helper-plugin-utils');\nvar syntaxObjectRestSpread = require('@babel/plugin-syntax-object-rest-spread');\nvar core = require('@babel/core');\nvar pluginTransformParameters = require('@babel/plugin-transform-parameters');\nvar helperCompilationTargets = require('@babel/helper-compilation-targets');\nvar compatData = require('@babel/compat-data/corejs2-built-ins');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar compatData__default = /*#__PURE__*/_interopDefaultLegacy(compatData);\nconst {\n  isObjectProperty: isObjectProperty$1,\n  isArrayPattern,\n  isObjectPattern,\n  isAssignmentPattern: isAssignmentPattern$1,\n  isRestElement,\n  isIdentifier\n} = core.types;\nfunction shouldStoreRHSInTemporaryVariable(node) {\n  if (isArrayPattern(node)) {\n    const nonNullElements = node.elements.filter(element => element !== null);\n    if (nonNullElements.length > 1) return true;else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (isObjectPattern(node)) {\n    const {\n      properties\n    } = node;\n    if (properties.length > 1) return true;else if (properties.length === 0) return false;else {\n      const firstProperty = properties[0];\n      if (isObjectProperty$1(firstProperty)) {\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (isAssignmentPattern$1(node)) {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (isRestElement(node)) {\n    if (isIdentifier(node.argument)) return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    return false;\n  }\n}\nconst {\n  isAssignmentPattern,\n  isObjectProperty\n} = core.types;\n{\n  const node = core.types.identifier(\"a\");\n  const property = core.types.objectProperty(core.types.identifier(\"key\"), node);\n  const pattern = core.types.objectPattern([property]);\n  var ZERO_REFS = core.types.isReferenced(node, property, pattern) ? 1 : 0;\n}\nvar index = helperPluginUtils.declare((api, opts) => {\n  var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;\n  api.assertVersion(7);\n  const targets = api.targets();\n  const supportsObjectAssign = !helperCompilationTargets.isRequired(\"es6.object.assign\", targets, {\n    compatData: compatData__default[\"default\"]\n  });\n  const {\n    useBuiltIns = supportsObjectAssign,\n    loose = false\n  } = opts;\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n  const ignoreFunctionLength = (_api$assumption = api.assumption(\"ignoreFunctionLength\")) != null ? _api$assumption : loose;\n  const objectRestNoSymbols = (_api$assumption2 = api.assumption(\"objectRestNoSymbols\")) != null ? _api$assumption2 : loose;\n  const pureGetters = (_api$assumption3 = api.assumption(\"pureGetters\")) != null ? _api$assumption3 : loose;\n  const setSpreadProperties = (_api$assumption4 = api.assumption(\"setSpreadProperties\")) != null ? _api$assumption4 : loose;\n  function getExtendsHelper(file) {\n    return useBuiltIns ? core.types.memberExpression(core.types.identifier(\"Object\"), core.types.identifier(\"assign\")) : file.addHelper(\"extends\");\n  }\n  function hasRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n  function hasObjectPatternRestElement(path) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n  function visitRestElements(path, visitor) {\n    path.traverse({\n      Expression(path) {\n        const {\n          parent,\n          key\n        } = path;\n        if (isAssignmentPattern(parent) && key === \"right\" || isObjectProperty(parent) && parent.computed && key === \"key\") {\n          path.skip();\n        }\n      },\n      RestElement: visitor\n    });\n  }\n  function hasSpread(node) {\n    for (const prop of node.properties) {\n      if (core.types.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function extractNormalizedKeys(node) {\n    const props = node.properties;\n    const keys = [];\n    let allLiteral = true;\n    let hasTemplateLiteral = false;\n    for (const prop of props) {\n      if (core.types.isIdentifier(prop.key) && !prop.computed) {\n        keys.push(core.types.stringLiteral(prop.key.name));\n      } else if (core.types.isTemplateLiteral(prop.key)) {\n        keys.push(core.types.cloneNode(prop.key));\n        hasTemplateLiteral = true;\n      } else if (core.types.isLiteral(prop.key)) {\n        keys.push(core.types.stringLiteral(String(prop.key.value)));\n      } else {\n        keys.push(core.types.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n    return {\n      keys,\n      allLiteral,\n      hasTemplateLiteral\n    };\n  }\n  function replaceImpureComputedKeys(properties, scope) {\n    const impureComputedPropertyDeclarators = [];\n    for (const propPath of properties) {\n      const key = propPath.get(\"key\");\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n        const declarator = core.types.variableDeclarator(core.types.identifier(name), key.node);\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(core.types.identifier(name));\n      }\n    }\n    return impureComputedPropertyDeclarators;\n  }\n  function removeUnusedExcludedKeys(path) {\n    const bindings = path.getOuterBindingIdentifierPaths();\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n  function createObjectRest(path, file, objRef) {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    core.types.assertRestElement(last.node);\n    const restElement = core.types.cloneNode(last.node);\n    last.remove();\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get(\"properties\"), path.scope);\n    const {\n      keys,\n      allLiteral,\n      hasTemplateLiteral\n    } = extractNormalizedKeys(path.node);\n    if (keys.length === 0) {\n      return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(getExtendsHelper(file), [core.types.objectExpression([]), core.types.sequenceExpression([core.types.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [core.types.cloneNode(objRef)]), core.types.cloneNode(objRef)])])];\n    }\n    let keyExpression;\n    if (!allLiteral) {\n      keyExpression = core.types.callExpression(core.types.memberExpression(core.types.arrayExpression(keys), core.types.identifier(\"map\")), [file.addHelper(\"toPropertyKey\")]);\n    } else {\n      keyExpression = core.types.arrayExpression(keys);\n      if (!hasTemplateLiteral && !core.types.isProgram(path.scope.block)) {\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\"\n        });\n        keyExpression = core.types.cloneNode(id);\n      }\n    }\n    return [impureComputedPropertyDeclarators, restElement.argument, core.types.callExpression(file.addHelper(`objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`), [core.types.cloneNode(objRef), keyExpression])];\n  }\n  function replaceRestElement(parentPath, paramPath, container) {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n      const declar = core.types.variableDeclaration(\"let\", [core.types.variableDeclarator(paramPath.node, uid)]);\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n      paramPath.replaceWith(core.types.cloneNode(uid));\n    }\n  }\n  return {\n    name: \"transform-object-rest-spread\",\n    inherits: syntaxObjectRestSpread.default,\n    visitor: {\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n        let idInRest = false;\n        const IdentifierHandler = function (path, functionScope) {\n          const name = path.node.name;\n          if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n        let i;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse({\n                \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler\n              }, path.scope);\n            }\n          }\n        }\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = idx => idx >= i - 1 || paramsWithRestElement.has(idx);\n          pluginTransformParameters.convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);\n        }\n      },\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n        let insertionPath = path;\n        const originalPath = path;\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n          if (shouldStoreRHSInTemporaryVariable(originalPath.node.id) && !core.types.isIdentifier(originalPath.node.init)) {\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, \"ref\");\n            originalPath.insertBefore(core.types.variableDeclarator(initRef, originalPath.node.init));\n            originalPath.replaceWith(core.types.variableDeclarator(originalPath.node.id, core.types.cloneNode(initRef)));\n            return;\n          }\n          let ref = originalPath.node.init;\n          const refPropertyPath = [];\n          let kind;\n          path.findParent(path => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);\n          refPropertyPath.forEach(prop => {\n            const {\n              node\n            } = prop;\n            ref = core.types.memberExpression(ref, core.types.cloneNode(node.key), node.computed || core.types.isLiteral(node.key));\n          });\n          const objectPatternPath = path.findParent(path => path.isObjectPattern());\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(objectPatternPath, file, ref);\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n          core.types.assertIdentifier(argument);\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n          insertionPath = insertionPath.insertAfter(core.types.variableDeclarator(argument, callExpression))[0];\n          path.scope.registerBinding(kind, insertionPath);\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath.findParent(path => path.isObjectProperty() || path.isVariableDeclarator()).remove();\n          }\n        });\n      },\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n        const hasRest = declaration.get(\"declarations\").some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n        const specifiers = [];\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(true))) {\n          specifiers.push(core.types.exportSpecifier(core.types.identifier(name), core.types.identifier(name)));\n        }\n        path.replaceWith(declaration.node);\n        path.insertAfter(core.types.exportNamedDeclaration(null, specifiers));\n      },\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n          const refName = path.scope.generateUidBasedOnNode(path.node.right, \"ref\");\n          nodes.push(core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(core.types.identifier(refName), path.node.right)]));\n          const [impureComputedPropertyDeclarators, argument, callExpression] = createObjectRest(leftPath, file, core.types.identifier(refName));\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(core.types.variableDeclaration(\"var\", impureComputedPropertyDeclarators));\n          }\n          const nodeWithoutSpread = core.types.cloneNode(path.node);\n          nodeWithoutSpread.right = core.types.identifier(refName);\n          nodes.push(core.types.expressionStatement(nodeWithoutSpread));\n          nodes.push(core.types.expressionStatement(core.types.assignmentExpression(\"=\", argument, callExpression)));\n          nodes.push(core.types.expressionStatement(core.types.identifier(refName)));\n          path.replaceWithMultiple(nodes);\n        }\n      },\n      ForXStatement(path) {\n        const {\n          node,\n          scope\n        } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n        if (!core.types.isVariableDeclaration(left)) {\n          const temp = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(\"var\", [core.types.variableDeclarator(temp)]);\n          path.ensureBlock();\n          const body = path.node.body;\n          if (body.body.length === 0 && path.isCompletionRecord()) {\n            body.body.unshift(core.types.expressionStatement(scope.buildUndefinedNode()));\n          }\n          body.body.unshift(core.types.expressionStatement(core.types.assignmentExpression(\"=\", left, core.types.cloneNode(temp))));\n        } else {\n          const pattern = left.declarations[0].id;\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = core.types.variableDeclaration(left.kind, [core.types.variableDeclarator(key, null)]);\n          path.ensureBlock();\n          const body = node.body;\n          body.body.unshift(core.types.variableDeclaration(node.left.kind, [core.types.variableDeclarator(pattern, core.types.cloneNode(key))]));\n        }\n      },\n      ArrayPattern(path) {\n        const objectPatterns = [];\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            return;\n          }\n          const objectPattern = path.parentPath;\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(core.types.variableDeclarator(objectPattern.node, uid));\n          objectPattern.replaceWith(core.types.cloneNode(uid));\n          path.skip();\n        });\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          const statementNode = statementPath.node;\n          const kind = statementNode.type === \"VariableDeclaration\" ? statementNode.kind : \"var\";\n          statementPath.insertAfter(core.types.variableDeclaration(kind, objectPatterns));\n        }\n      },\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n        let helper;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch (_unused) {\n            this.file.declarations[\"objectSpread2\"] = null;\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n        let exp = null;\n        let props = [];\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = core.types.objectExpression(props);\n          props = [];\n          if (!exp) {\n            exp = core.types.callExpression(helper, [obj]);\n            return;\n          }\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n          exp = core.types.callExpression(core.types.cloneNode(helper), [exp, ...(hadProps ? [core.types.objectExpression([]), obj] : [])]);\n        }\n        for (const prop of path.node.properties) {\n          if (core.types.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n        if (props.length) make();\n        path.replaceWith(exp);\n      }\n    }\n  };\n});\nexports[\"default\"] = index;","map":{"version":3,"names":["isObjectProperty$1","isArrayPattern","isObjectPattern","isAssignmentPattern$1","isRestElement","isIdentifier","core","types","shouldStoreRHSInTemporaryVariable","node","nonNullElements","elements","filter","element","length","properties","firstProperty","value","left","argument","isAssignmentPattern","isObjectProperty","identifier","property","objectProperty","pattern","objectPattern","ZERO_REFS","isReferenced","index","helperPluginUtils","declare","api","opts","_api$assumption","_api$assumption2","_api$assumption3","_api$assumption4","assertVersion","targets","supportsObjectAssign","helperCompilationTargets","isRequired","compatData","compatData__default","useBuiltIns","loose","Error","ignoreFunctionLength","assumption","objectRestNoSymbols","pureGetters","setSpreadProperties","getExtendsHelper","file","memberExpression","addHelper","hasRestElement","path","foundRestElement","visitRestElements","restElement","stop","hasObjectPatternRestElement","parentPath","visitor","traverse","Expression","parent","key","computed","skip","RestElement","hasSpread","prop","isSpreadElement","extractNormalizedKeys","props","keys","allLiteral","hasTemplateLiteral","push","stringLiteral","name","isTemplateLiteral","cloneNode","isLiteral","String","replaceImpureComputedKeys","scope","impureComputedPropertyDeclarators","propPath","get","isPure","generateUidBasedOnNode","declarator","variableDeclarator","replaceWith","removeUnusedExcludedKeys","bindings","getOuterBindingIdentifierPaths","Object","forEach","bindingName","bindingParentPath","getBinding","references","remove","createObjectRest","objRef","last","assertRestElement","callExpression","objectExpression","sequenceExpression","keyExpression","arrayExpression","isProgram","block","program","findParent","id","generateUidIdentifier","init","kind","replaceRestElement","paramPath","container","i","uid","declar","variableDeclaration","ensureBlock","unshiftContainer","inherits","syntaxObjectRestSpread","default","Function","params","paramsWithRestElement","Set","idsInRestParams","param","add","getBindingIdentifiers","idInRest","IdentifierHandler","functionScope","has","isReferencedIdentifier","isBindingIdentifier","shouldTransformParam","idx","pluginTransformParameters","convertFunctionParams","VariableDeclarator","insertionPath","originalPath","initRef","generateUidIdentifierBasedOnNode","insertBefore","ref","refPropertyPath","unshift","isVariableDeclarator","impureObjRefComputedDeclarators","objectPatternPath","assertIdentifier","insertAfter","registerBinding","ExportNamedDeclaration","declaration","isVariableDeclaration","hasRest","some","specifiers","getOuterBindingIdentifiers","exportSpecifier","exportNamedDeclaration","CatchClause","AssignmentExpression","leftPath","nodes","refName","right","nodeWithoutSpread","expressionStatement","assignmentExpression","replaceWithMultiple","ForXStatement","temp","body","isCompletionRecord","buildUndefinedNode","declarations","ArrayPattern","objectPatterns","statementPath","getStatementParent","statementNode","type","ObjectExpression","helper","_unused","exp","make","hadProps","obj","arguments"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/@babel/plugin-transform-object-rest-spread/src/shouldStoreRHSInTemporaryVariable.ts","/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/@babel/plugin-transform-object-rest-spread/src/index.ts"],"sourcesContent":["import { types as t } from \"@babel/core\";\n\nconst {\n  isObjectProperty,\n  isArrayPattern,\n  isObjectPattern,\n  isAssignmentPattern,\n  isRestElement,\n  isIdentifier,\n} = t;\n/**\n * This is a helper function to determine if we should create an intermediate variable\n * such that the RHS of an assignment is not duplicated.\n *\n * See https://github.com/babel/babel/pull/13711#issuecomment-914388382 for discussion\n * on further optimizations.\n */\nexport default function shouldStoreRHSInTemporaryVariable(\n  node: t.LVal,\n): boolean {\n  if (isArrayPattern(node)) {\n    const nonNullElements = node.elements.filter(element => element !== null);\n    if (nonNullElements.length > 1) return true;\n    else return shouldStoreRHSInTemporaryVariable(nonNullElements[0]);\n  } else if (isObjectPattern(node)) {\n    const { properties } = node;\n    if (properties.length > 1) return true;\n    else if (properties.length === 0) return false;\n    else {\n      const firstProperty = properties[0];\n      if (isObjectProperty(firstProperty)) {\n        // the value of the property must be an LVal\n        return shouldStoreRHSInTemporaryVariable(firstProperty.value as t.LVal);\n      } else {\n        return shouldStoreRHSInTemporaryVariable(firstProperty);\n      }\n    }\n  } else if (isAssignmentPattern(node)) {\n    return shouldStoreRHSInTemporaryVariable(node.left);\n  } else if (isRestElement(node)) {\n    if (isIdentifier(node.argument)) return true;\n    return shouldStoreRHSInTemporaryVariable(node.argument);\n  } else {\n    // node is Identifier or MemberExpression\n    return false;\n  }\n}\n","import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxObjectRestSpread from \"@babel/plugin-syntax-object-rest-spread\";\nimport { types as t } from \"@babel/core\";\nimport type { PluginPass } from \"@babel/core\";\nimport type { NodePath, Scope } from \"@babel/traverse\";\nimport { convertFunctionParams } from \"@babel/plugin-transform-parameters\";\nimport { isRequired } from \"@babel/helper-compilation-targets\";\nimport compatData from \"@babel/compat-data/corejs2-built-ins\";\nimport shouldStoreRHSInTemporaryVariable from \"./shouldStoreRHSInTemporaryVariable\";\n\nconst { isAssignmentPattern, isObjectProperty } = t;\n// @babel/types <=7.3.3 counts FOO as referenced in var { x: FOO }.\n// We need to detect this bug to know if \"unused\" means 0 or 1 references.\nif (!process.env.BABEL_8_BREAKING) {\n  const node = t.identifier(\"a\");\n  const property = t.objectProperty(t.identifier(\"key\"), node);\n  const pattern = t.objectPattern([property]);\n\n  // eslint-disable-next-line no-var\n  var ZERO_REFS = t.isReferenced(node, property, pattern) ? 1 : 0;\n}\n\ntype Param = NodePath<t.Function[\"params\"][number]>;\nexport interface Options {\n  useBuiltIns?: boolean;\n  loose?: boolean;\n}\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const targets = api.targets();\n  const supportsObjectAssign = !isRequired(\"es6.object.assign\", targets, {\n    compatData,\n  });\n\n  const { useBuiltIns = supportsObjectAssign, loose = false } = opts;\n\n  if (typeof loose !== \"boolean\") {\n    throw new Error(\".loose must be a boolean, or undefined\");\n  }\n\n  const ignoreFunctionLength = api.assumption(\"ignoreFunctionLength\") ?? loose;\n  const objectRestNoSymbols = api.assumption(\"objectRestNoSymbols\") ?? loose;\n  const pureGetters = api.assumption(\"pureGetters\") ?? loose;\n  const setSpreadProperties = api.assumption(\"setSpreadProperties\") ?? loose;\n\n  function getExtendsHelper(\n    file: PluginPass,\n  ): t.MemberExpression | t.Identifier {\n    return useBuiltIns\n      ? t.memberExpression(t.identifier(\"Object\"), t.identifier(\"assign\"))\n      : file.addHelper(\"extends\");\n  }\n\n  function hasRestElement(path: Param) {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      foundRestElement = true;\n      restElement.stop();\n    });\n    return foundRestElement;\n  }\n\n  function hasObjectPatternRestElement(path: NodePath): boolean {\n    let foundRestElement = false;\n    visitRestElements(path, restElement => {\n      if (restElement.parentPath.isObjectPattern()) {\n        foundRestElement = true;\n        restElement.stop();\n      }\n    });\n    return foundRestElement;\n  }\n\n  function visitRestElements(\n    path: NodePath,\n    visitor: (path: NodePath<t.RestElement>) => any,\n  ) {\n    path.traverse({\n      Expression(path) {\n        const { parent, key } = path;\n        if (\n          (isAssignmentPattern(parent) && key === \"right\") ||\n          (isObjectProperty(parent) && parent.computed && key === \"key\")\n        ) {\n          path.skip();\n        }\n      },\n      RestElement: visitor,\n    });\n  }\n\n  function hasSpread(node: t.ObjectExpression): boolean {\n    for (const prop of node.properties) {\n      if (t.isSpreadElement(prop)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // returns an array of all keys of an object, and a status flag indicating if all extracted keys\n  // were converted to stringLiterals or not\n  // e.g. extracts {keys: [\"a\", \"b\", \"3\", ++x], allLiteral: false }\n  // from ast of {a: \"foo\", b, 3: \"bar\", [++x]: \"baz\"}\n  function extractNormalizedKeys(node: t.ObjectPattern) {\n    // RestElement has been removed in createObjectRest\n    const props = node.properties as t.ObjectProperty[];\n    const keys: t.Expression[] = [];\n    let allLiteral = true;\n    let hasTemplateLiteral = false;\n\n    for (const prop of props) {\n      if (t.isIdentifier(prop.key) && !prop.computed) {\n        // since a key {a: 3} is equivalent to {\"a\": 3}, use the latter\n        keys.push(t.stringLiteral(prop.key.name));\n      } else if (t.isTemplateLiteral(prop.key)) {\n        keys.push(t.cloneNode(prop.key));\n        hasTemplateLiteral = true;\n      } else if (t.isLiteral(prop.key)) {\n        keys.push(\n          t.stringLiteral(\n            String(\n              // @ts-expect-error prop.key can not be a NullLiteral\n              prop.key.value,\n            ),\n          ),\n        );\n      } else {\n        // @ts-expect-error private name has been handled by destructuring-private\n        keys.push(t.cloneNode(prop.key));\n        allLiteral = false;\n      }\n    }\n\n    return { keys, allLiteral, hasTemplateLiteral };\n  }\n\n  // replaces impure computed keys with new identifiers\n  // and returns variable declarators of these new identifiers\n  function replaceImpureComputedKeys(\n    properties: NodePath<t.ObjectProperty>[],\n    scope: Scope,\n  ) {\n    const impureComputedPropertyDeclarators: t.VariableDeclarator[] = [];\n    for (const propPath of properties) {\n      // PrivateName is handled in destructuring-private plugin\n      const key = propPath.get(\"key\") as NodePath<t.Expression>;\n      if (propPath.node.computed && !key.isPure()) {\n        const name = scope.generateUidBasedOnNode(key.node);\n        const declarator = t.variableDeclarator(t.identifier(name), key.node);\n        impureComputedPropertyDeclarators.push(declarator);\n        key.replaceWith(t.identifier(name));\n      }\n    }\n    return impureComputedPropertyDeclarators;\n  }\n\n  function removeUnusedExcludedKeys(path: NodePath<t.ObjectPattern>): void {\n    const bindings = path.getOuterBindingIdentifierPaths();\n\n    Object.keys(bindings).forEach(bindingName => {\n      const bindingParentPath = bindings[bindingName].parentPath;\n      if (\n        path.scope.getBinding(bindingName).references >\n          (process.env.BABEL_8_BREAKING ? 0 : ZERO_REFS) ||\n        !bindingParentPath.isObjectProperty()\n      ) {\n        return;\n      }\n      bindingParentPath.remove();\n    });\n  }\n\n  //expects path to an object pattern\n  function createObjectRest(\n    path: NodePath<t.ObjectPattern>,\n    file: PluginPass,\n    objRef: t.Identifier | t.MemberExpression,\n  ): [t.VariableDeclarator[], t.LVal, t.CallExpression] {\n    const props = path.get(\"properties\");\n    const last = props[props.length - 1];\n    t.assertRestElement(last.node);\n    const restElement = t.cloneNode(last.node);\n    last.remove();\n\n    const impureComputedPropertyDeclarators = replaceImpureComputedKeys(\n      path.get(\"properties\") as NodePath<t.ObjectProperty>[],\n      path.scope,\n    );\n    const { keys, allLiteral, hasTemplateLiteral } = extractNormalizedKeys(\n      path.node,\n    );\n\n    if (keys.length === 0) {\n      return [\n        impureComputedPropertyDeclarators,\n        restElement.argument,\n        t.callExpression(getExtendsHelper(file), [\n          t.objectExpression([]),\n          t.sequenceExpression([\n            t.callExpression(file.addHelper(\"objectDestructuringEmpty\"), [\n              t.cloneNode(objRef),\n            ]),\n            t.cloneNode(objRef),\n          ]),\n        ]),\n      ];\n    }\n\n    let keyExpression;\n    if (!allLiteral) {\n      // map to toPropertyKey to handle the possible non-string values\n      keyExpression = t.callExpression(\n        t.memberExpression(t.arrayExpression(keys), t.identifier(\"map\")),\n        [file.addHelper(\"toPropertyKey\")],\n      );\n    } else {\n      keyExpression = t.arrayExpression(keys);\n\n      if (!hasTemplateLiteral && !t.isProgram(path.scope.block)) {\n        // Hoist definition of excluded keys, so that it's not created each time.\n        const program = path.findParent(path => path.isProgram());\n        const id = path.scope.generateUidIdentifier(\"excluded\");\n\n        program.scope.push({\n          id,\n          init: keyExpression,\n          kind: \"const\",\n        });\n\n        keyExpression = t.cloneNode(id);\n      }\n    }\n\n    return [\n      impureComputedPropertyDeclarators,\n      restElement.argument,\n      t.callExpression(\n        file.addHelper(\n          `objectWithoutProperties${objectRestNoSymbols ? \"Loose\" : \"\"}`,\n        ),\n        [t.cloneNode(objRef), keyExpression],\n      ),\n    ];\n  }\n\n  function replaceRestElement(\n    parentPath: NodePath<t.Function | t.CatchClause>,\n    paramPath: NodePath<\n      t.Function[\"params\"][number] | t.AssignmentPattern[\"left\"]\n    >,\n    container?: t.VariableDeclaration[],\n  ): void {\n    if (paramPath.isAssignmentPattern()) {\n      replaceRestElement(parentPath, paramPath.get(\"left\"), container);\n      return;\n    }\n\n    if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {\n      const elements = paramPath.get(\"elements\");\n\n      for (let i = 0; i < elements.length; i++) {\n        replaceRestElement(parentPath, elements[i], container);\n      }\n    }\n\n    if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {\n      const uid = parentPath.scope.generateUidIdentifier(\"ref\");\n\n      const declar = t.variableDeclaration(\"let\", [\n        t.variableDeclarator(paramPath.node, uid),\n      ]);\n\n      if (container) {\n        container.push(declar);\n      } else {\n        parentPath.ensureBlock();\n        parentPath.get(\"body\").unshiftContainer(\"body\", declar);\n      }\n      paramPath.replaceWith(t.cloneNode(uid));\n    }\n  }\n\n  return {\n    name: \"transform-object-rest-spread\",\n    inherits: syntaxObjectRestSpread.default,\n\n    visitor: {\n      // function a({ b, ...c }) {}\n      Function(path) {\n        const params = path.get(\"params\");\n        const paramsWithRestElement = new Set<number>();\n        const idsInRestParams = new Set();\n        for (let i = 0; i < params.length; ++i) {\n          const param = params[i];\n          if (hasRestElement(param)) {\n            paramsWithRestElement.add(i);\n            for (const name of Object.keys(param.getBindingIdentifiers())) {\n              idsInRestParams.add(name);\n            }\n          }\n        }\n\n        // if true, a parameter exists that has an id in its initializer\n        // that is also an id bound in a rest parameter\n        // example: f({...R}, a = R)\n        let idInRest = false;\n\n        const IdentifierHandler = function (\n          path: NodePath<t.Identifier>,\n          functionScope: Scope,\n        ) {\n          const name = path.node.name;\n          if (\n            path.scope.getBinding(name) === functionScope.getBinding(name) &&\n            idsInRestParams.has(name)\n          ) {\n            idInRest = true;\n            path.stop();\n          }\n        };\n\n        let i: number;\n        for (i = 0; i < params.length && !idInRest; ++i) {\n          const param = params[i];\n          if (!paramsWithRestElement.has(i)) {\n            if (param.isReferencedIdentifier() || param.isBindingIdentifier()) {\n              IdentifierHandler(param, path.scope);\n            } else {\n              param.traverse(\n                {\n                  \"Scope|TypeAnnotation|TSTypeAnnotation\": path => path.skip(),\n                  \"ReferencedIdentifier|BindingIdentifier\": IdentifierHandler,\n                },\n                path.scope,\n              );\n            }\n          }\n        }\n\n        if (!idInRest) {\n          for (let i = 0; i < params.length; ++i) {\n            const param = params[i];\n            if (paramsWithRestElement.has(i)) {\n              replaceRestElement(path, param);\n            }\n          }\n        } else {\n          const shouldTransformParam = (idx: number) =>\n            idx >= i - 1 || paramsWithRestElement.has(idx);\n          convertFunctionParams(\n            path,\n            ignoreFunctionLength,\n            shouldTransformParam,\n            replaceRestElement,\n          );\n        }\n      },\n\n      // adapted from transform-destructuring/src/index.js#pushObjectRest\n      // const { a, ...b } = c;\n      VariableDeclarator(path, file) {\n        if (!path.get(\"id\").isObjectPattern()) {\n          return;\n        }\n\n        let insertionPath = path;\n        const originalPath = path;\n\n        visitRestElements(path.get(\"id\"), path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          if (\n            // skip single-property case, e.g.\n            // const { ...x } = foo();\n            // since the RHS will not be duplicated\n            shouldStoreRHSInTemporaryVariable(originalPath.node.id) &&\n            !t.isIdentifier(originalPath.node.init)\n          ) {\n            // const { a, ...b } = foo();\n            // to avoid calling foo() twice, as a first step convert it to:\n            // const _foo = foo(),\n            //       { a, ...b } = _foo;\n            const initRef = path.scope.generateUidIdentifierBasedOnNode(\n              originalPath.node.init,\n              \"ref\",\n            );\n            // insert _foo = foo()\n            originalPath.insertBefore(\n              t.variableDeclarator(initRef, originalPath.node.init),\n            );\n            // replace foo() with _foo\n            originalPath.replaceWith(\n              t.variableDeclarator(originalPath.node.id, t.cloneNode(initRef)),\n            );\n\n            return;\n          }\n\n          let ref = originalPath.node.init;\n          const refPropertyPath: NodePath<t.ObjectProperty>[] = [];\n          let kind;\n\n          path.findParent((path: NodePath): boolean => {\n            if (path.isObjectProperty()) {\n              refPropertyPath.unshift(path);\n            } else if (path.isVariableDeclarator()) {\n              kind = path.parentPath.node.kind;\n              return true;\n            }\n          });\n\n          const impureObjRefComputedDeclarators = replaceImpureComputedKeys(\n            refPropertyPath,\n            path.scope,\n          );\n          refPropertyPath.forEach(prop => {\n            const { node } = prop;\n            ref = t.memberExpression(\n              ref,\n              t.cloneNode(node.key),\n              node.computed || t.isLiteral(node.key),\n            );\n          });\n\n          //@ts-expect-error: findParent can not apply assertions on result shape\n          const objectPatternPath: NodePath<t.ObjectPattern> = path.findParent(\n            path => path.isObjectPattern(),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(\n              objectPatternPath,\n              file,\n              ref as t.MemberExpression,\n            );\n\n          if (pureGetters) {\n            removeUnusedExcludedKeys(objectPatternPath);\n          }\n\n          t.assertIdentifier(argument);\n\n          insertionPath.insertBefore(impureComputedPropertyDeclarators);\n\n          insertionPath.insertBefore(impureObjRefComputedDeclarators);\n\n          insertionPath = insertionPath.insertAfter(\n            t.variableDeclarator(argument, callExpression),\n          )[0] as NodePath<t.VariableDeclarator>;\n\n          path.scope.registerBinding(kind, insertionPath);\n\n          if (objectPatternPath.node.properties.length === 0) {\n            objectPatternPath\n              .findParent(\n                path => path.isObjectProperty() || path.isVariableDeclarator(),\n              )\n              .remove();\n          }\n        });\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      // export var { a, ...b } = c;\n      ExportNamedDeclaration(path) {\n        const declaration = path.get(\"declaration\");\n        if (!declaration.isVariableDeclaration()) return;\n\n        const hasRest = declaration\n          .get(\"declarations\")\n          .some(path => hasObjectPatternRestElement(path.get(\"id\")));\n        if (!hasRest) return;\n\n        const specifiers = [];\n\n        for (const name of Object.keys(path.getOuterBindingIdentifiers(true))) {\n          specifiers.push(\n            t.exportSpecifier(t.identifier(name), t.identifier(name)),\n          );\n        }\n\n        // Split the declaration and export list into two declarations so that the variable\n        // declaration can be split up later without needing to worry about not being a\n        // top-level statement.\n        path.replaceWith(declaration.node);\n        path.insertAfter(t.exportNamedDeclaration(null, specifiers));\n      },\n\n      // try {} catch ({a, ...b}) {}\n      CatchClause(path) {\n        const paramPath = path.get(\"param\");\n        replaceRestElement(path, paramPath);\n      },\n\n      // ({a, ...b} = c);\n      AssignmentExpression(path, file) {\n        const leftPath = path.get(\"left\");\n        if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {\n          const nodes = [];\n\n          const refName = path.scope.generateUidBasedOnNode(\n            path.node.right,\n            \"ref\",\n          );\n\n          nodes.push(\n            t.variableDeclaration(\"var\", [\n              t.variableDeclarator(t.identifier(refName), path.node.right),\n            ]),\n          );\n\n          const [impureComputedPropertyDeclarators, argument, callExpression] =\n            createObjectRest(leftPath, file, t.identifier(refName));\n\n          if (impureComputedPropertyDeclarators.length > 0) {\n            nodes.push(\n              t.variableDeclaration(\"var\", impureComputedPropertyDeclarators),\n            );\n          }\n\n          const nodeWithoutSpread = t.cloneNode(path.node);\n          nodeWithoutSpread.right = t.identifier(refName);\n          nodes.push(t.expressionStatement(nodeWithoutSpread));\n          nodes.push(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", argument, callExpression),\n            ),\n          );\n          nodes.push(t.expressionStatement(t.identifier(refName)));\n\n          path.replaceWithMultiple(nodes);\n        }\n      },\n\n      // taken from transform-destructuring/src/index.js#visitor\n      ForXStatement(path: NodePath<t.ForXStatement>) {\n        const { node, scope } = path;\n        const leftPath = path.get(\"left\");\n        const left = node.left;\n\n        if (!hasObjectPatternRestElement(leftPath)) {\n          return;\n        }\n\n        if (!t.isVariableDeclaration(left)) {\n          // for ({a, ...b} of []) {}\n          const temp = scope.generateUidIdentifier(\"ref\");\n\n          node.left = t.variableDeclaration(\"var\", [\n            t.variableDeclarator(temp),\n          ]);\n\n          path.ensureBlock();\n          const body = path.node.body;\n\n          if (body.body.length === 0 && path.isCompletionRecord()) {\n            body.body.unshift(\n              t.expressionStatement(scope.buildUndefinedNode()),\n            );\n          }\n\n          body.body.unshift(\n            t.expressionStatement(\n              t.assignmentExpression(\"=\", left, t.cloneNode(temp)),\n            ),\n          );\n        } else {\n          // for (var {a, ...b} of []) {}\n          const pattern = left.declarations[0].id;\n\n          const key = scope.generateUidIdentifier(\"ref\");\n          node.left = t.variableDeclaration(left.kind, [\n            t.variableDeclarator(key, null),\n          ]);\n\n          path.ensureBlock();\n          const body = node.body as t.BlockStatement;\n\n          body.body.unshift(\n            t.variableDeclaration(node.left.kind, [\n              t.variableDeclarator(pattern, t.cloneNode(key)),\n            ]),\n          );\n        }\n      },\n\n      // [{a, ...b}] = c;\n      ArrayPattern(path) {\n        const objectPatterns: t.VariableDeclarator[] = [];\n\n        visitRestElements(path, path => {\n          if (!path.parentPath.isObjectPattern()) {\n            // Return early if the parent is not an ObjectPattern, but\n            // (for example) an ArrayPattern or Function, because that\n            // means this RestElement is an not an object property.\n            return;\n          }\n\n          const objectPattern = path.parentPath;\n\n          const uid = path.scope.generateUidIdentifier(\"ref\");\n          objectPatterns.push(t.variableDeclarator(objectPattern.node, uid));\n\n          objectPattern.replaceWith(t.cloneNode(uid));\n          path.skip();\n        });\n\n        if (objectPatterns.length > 0) {\n          const statementPath = path.getStatementParent();\n          const statementNode = statementPath.node;\n          const kind =\n            statementNode.type === \"VariableDeclaration\"\n              ? statementNode.kind\n              : \"var\";\n          statementPath.insertAfter(\n            t.variableDeclaration(kind, objectPatterns),\n          );\n        }\n      },\n\n      // var a = { ...b, ...c }\n      ObjectExpression(path, file) {\n        if (!hasSpread(path.node)) return;\n\n        let helper: t.Identifier | t.MemberExpression;\n        if (setSpreadProperties) {\n          helper = getExtendsHelper(file);\n        } else {\n          try {\n            helper = file.addHelper(\"objectSpread2\");\n          } catch {\n            // TODO: This is needed to workaround https://github.com/babel/babel/issues/10187\n            // and https://github.com/babel/babel/issues/10179 for older @babel/core versions\n            // where #10187 isn't fixed.\n            this.file.declarations[\"objectSpread2\"] = null;\n\n            // objectSpread2 has been introduced in v7.5.0\n            // We have to maintain backward compatibility.\n            helper = file.addHelper(\"objectSpread\");\n          }\n        }\n\n        let exp: t.CallExpression = null;\n        let props: t.ObjectMember[] = [];\n\n        function make() {\n          const hadProps = props.length > 0;\n          const obj = t.objectExpression(props);\n          props = [];\n\n          if (!exp) {\n            exp = t.callExpression(helper, [obj]);\n            return;\n          }\n\n          // When we can assume that getters are pure and don't depend on\n          // the order of evaluation, we can avoid making multiple calls.\n          if (pureGetters) {\n            if (hadProps) {\n              exp.arguments.push(obj);\n            }\n            return;\n          }\n\n          exp = t.callExpression(t.cloneNode(helper), [\n            exp,\n            // If we have static props, we need to insert an empty object\n            // because the odd arguments are copied with [[Get]], not\n            // [[GetOwnProperty]]\n            ...(hadProps ? [t.objectExpression([]), obj] : []),\n          ]);\n        }\n\n        for (const prop of path.node.properties) {\n          if (t.isSpreadElement(prop)) {\n            make();\n            exp.arguments.push(prop.argument);\n          } else {\n            props.push(prop);\n          }\n        }\n\n        if (props.length) make();\n\n        path.replaceWith(exp);\n      },\n    },\n  };\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}