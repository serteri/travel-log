{"ast":null,"code":"// Import Express\nconst express = require('express');\n// Create an instance of an Express Router\nconst router = express.Router();\nconst jwt = require('jsonwebtoken');\nconst {\n  Role\n} = require('../models/RoleModel');\nconst {\n  User\n} = require('../models/UserModel');\nconst {\n  encryptString,\n  decryptString,\n  decryptObject,\n  hashString,\n  validateHashedData,\n  generateJWT,\n  generateUserJWT,\n  verifyUserJWT,\n  getAllUsers,\n  getSpecificUser,\n  createUser,\n  updateUser,\n  deleteUser\n} = require('./UserFunctions');\n\n// Validate user email uniqueness\nconst uniqueEmailCheck = async (request, response, next) => {\n  let isEmailInUse = await User.exists({\n    email: request.body.email\n  }).exec();\n  if (isEmailInUse) {\n    next(new Error(\"An account with this email address already exists.\"));\n  } else {\n    next();\n  }\n};\n\n// Make sure the JWT available in the headers is valid,\n// and refresh it to keep the JWT usable for longer.\nconst verifyJwtHeader = async (request, response, next) => {\n  let rawJwtHeader = request.headers.jwt;\n  let jwtRefresh = await verifyUserJWT(rawJwtHeader);\n  request.headers.jwt = jwtRefresh;\n  next();\n};\nconst verifyJwtRole = async (request, response, next) => {\n  // Verify that the JWT is still valid.\n  let userJwtVerified = jwt.verify(request.headers.jwt, process.env.JWT_SECRET, {\n    complete: true\n  });\n  // Decrypt the encrypted payload.\n  let decryptedJwtPayload = decryptString(userJwtVerified.payload.data);\n  // Parse the decrypted data into an object.\n  let userData = JSON.parse(decryptedJwtPayload);\n\n  // Because the JWT doesn't include role info, we must find the full user document first:\n  let userDoc = await User.findById(userData.userID).exec();\n  let userRoleName = await Role.findById(userDoc.role).exec();\n\n  // Attach the role to the request for the backend to use.\n  // Note that the user's role will never be available on the front-end\n  // with this technique.\n  // This means they can't just manipulate the JWT to access admin stuff.\n  console.log(\"User role is: \" + userRoleName.name);\n  request.headers.userRole = userRoleName.name;\n  next();\n};\n// The actual authorization middleware.\n// Throw to the error-handling middleware\n// if the user is not authorized.\n// Different middleware can be made for\n// different roles, just like this.\nconst onlyAllowAdmins = (request, response, next) => {\n  if (request.headers.userRole == \"admin\") {\n    next();\n  } else {\n    next(new Error(\"User not authorized.\"));\n  }\n};\n// If any errors are detected, end the route early\n// and respond with the error message\nconst handleErrors = async (error, request, response, next) => {\n  if (error) {\n    response.status(500).json({\n      error: error.message\n    });\n  } else {\n    next();\n  }\n};\n\n// Sign-up a new user\nrouter.post('/sign-up', uniqueEmailCheck, handleErrors, async (request, response) => {\n  let userDetails = {\n    email: request.body.email,\n    password: request.body.password,\n    username: request.body.username,\n    address: request.body.address,\n    phonenumber: request.body.phonenumber,\n    roleID: request.body.roleID\n  };\n  let newUserDoc = await createUser(userDetails);\n  response.json({\n    user: newUserDoc\n  });\n});\n\n// Sign-in an existing user\nrouter.post('/sign-in', async (request, response) => {\n  let targetUser = await User.findOne({\n    email: request.body.email\n  }).exec();\n  if (await validateHashedData(request.body.password, targetUser.password)) {\n    let encryptedUserJwt = await generateUserJWT({\n      userID: targetUser.id,\n      email: targetUser.email,\n      password: targetUser.password\n    });\n    response.json(encryptedUserJwt);\n  } else {\n    response.status(400).json({\n      message: \"Invalid user details provided.\"\n    });\n  }\n});\n\n// Extend a user's JWT validity\nrouter.post('/token-refresh', async (request, response) => {\n  let oldToken = request.body.jwt;\n  let refreshResult = await verifyUserJWT(oldToken).catch(error => {\n    return {\n      error: error.message\n    };\n  });\n  response.json(refreshResult);\n});\n\n// Update a user\nrouter.put('/:userID', async (request, response) => {\n  let userDetails = {\n    userID: request.params.userID,\n    updatedData: request.body.newUserData\n  };\n  response.json(await updateUser(userDetails));\n});\n\n// Delete a user\nrouter.delete('/:userID', async (request, response) => {\n  response.json(await deleteUser(request.params.userID));\n});\n\n// List all users\nrouter.get('/', async (request, response) => {\n  let allUsers = await getAllUsers();\n  response.json({\n    userCount: allUsers.length,\n    usersArray: allUsers\n  });\n});\n\n// Show a specific user\nrouter.get('/:userID', async (request, response) => {\n  response.json(await getSpecificUser(request.params.userID));\n});\n\n// All involved middleware must be attached to either\n// the app (Express instance), or the router (Express router instance)\n// or the specific route.\nrouter.get('/someProtectedRoute', verifyJwtHeader, verifyJwtRole, onlyAllowAdmins, (request, response) => {\n  // No actual functionality here - focus on the middleware!\n  response.json({\n    message: \"Hello authorized world!\"\n  });\n});\n\n// Export the router so that other files can use it:\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","jwt","Role","User","encryptString","decryptString","decryptObject","hashString","validateHashedData","generateJWT","generateUserJWT","verifyUserJWT","getAllUsers","getSpecificUser","createUser","updateUser","deleteUser","uniqueEmailCheck","request","response","next","isEmailInUse","exists","email","body","exec","Error","verifyJwtHeader","rawJwtHeader","headers","jwtRefresh","verifyJwtRole","userJwtVerified","verify","process","env","JWT_SECRET","complete","decryptedJwtPayload","payload","data","userData","JSON","parse","userDoc","findById","userID","userRoleName","role","console","log","name","userRole","onlyAllowAdmins","handleErrors","error","status","json","message","post","userDetails","password","username","address","phonenumber","roleID","newUserDoc","user","targetUser","findOne","encryptedUserJwt","id","oldToken","refreshResult","catch","put","params","updatedData","newUserData","delete","get","allUsers","userCount","length","usersArray","module","exports"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/src/controllers/UserRoutes.js"],"sourcesContent":["// Import Express\nconst express = require('express');\n// Create an instance of an Express Router\nconst router = express.Router();\nconst jwt = require('jsonwebtoken');\nconst { Role } = require('../models/RoleModel');\nconst { User } = require('../models/UserModel');\n\nconst {\n    encryptString, decryptString, decryptObject, hashString, validateHashedData,\n    generateJWT, generateUserJWT, verifyUserJWT,\n    getAllUsers, getSpecificUser, createUser, updateUser, deleteUser\n} = require('./UserFunctions');\n\n// Validate user email uniqueness\nconst uniqueEmailCheck = async (request, response, next) => {\n    let isEmailInUse = await User.exists({email: request.body.email}).exec();\n    if (isEmailInUse){\n        next(new Error(\"An account with this email address already exists.\"));\n    } else {\n        next();\n    }\n\n}\n\n// Make sure the JWT available in the headers is valid,\n// and refresh it to keep the JWT usable for longer.\nconst verifyJwtHeader = async (request, response, next) => {\n    let rawJwtHeader = request.headers.jwt;\n\n    let jwtRefresh = await verifyUserJWT(rawJwtHeader);\n\n    request.headers.jwt = jwtRefresh;\n\n    next();\n}\nconst verifyJwtRole = async (request, response, next) => {\n    // Verify that the JWT is still valid.\n    let userJwtVerified = jwt.verify(request.headers.jwt,process.env.JWT_SECRET, {complete: true});\n    // Decrypt the encrypted payload.\n    let decryptedJwtPayload = decryptString(userJwtVerified.payload.data);\n    // Parse the decrypted data into an object.\n    let userData = JSON.parse(decryptedJwtPayload);\n\n    // Because the JWT doesn't include role info, we must find the full user document first:\n    let userDoc = await User.findById(userData.userID).exec();\n    let userRoleName = await Role.findById(userDoc.role).exec();\n\n    // Attach the role to the request for the backend to use.\n    // Note that the user's role will never be available on the front-end\n    // with this technique.\n    // This means they can't just manipulate the JWT to access admin stuff.\n    console.log(\"User role is: \" + userRoleName.name);\n    request.headers.userRole = userRoleName.name;\n\n    next();\n}\n// The actual authorization middleware.\n// Throw to the error-handling middleware\n// if the user is not authorized.\n// Different middleware can be made for\n// different roles, just like this.\nconst onlyAllowAdmins = (request, response, next) => {\n    if (request.headers.userRole == \"admin\"){\n        next();\n    } else {\n        next(new Error(\"User not authorized.\"));\n    }\n}\n// If any errors are detected, end the route early\n// and respond with the error message\nconst handleErrors = async (error, request, response, next) => {\n    if (error) {\n        response.status(500).json({\n            error: error.message\n        });\n    } else {\n        next();\n    }\n}\n\n\n\n// Sign-up a new user\nrouter.post('/sign-up',uniqueEmailCheck, handleErrors, async (request, response) => {\n    let userDetails = {\n        email: request.body.email,\n        password: request.body.password,\n        username: request.body.username,\n        address: request.body.address,\n        phonenumber: request.body.phonenumber,\n        roleID: request.body.roleID\n    }\n    let newUserDoc = await createUser(userDetails);\n\n    response.json({\n        user: newUserDoc\n    });\n\n});\n\n// Sign-in an existing user\nrouter.post('/sign-in', async (request, response) => {\n    let targetUser = await User.findOne({email: request.body.email}).exec();\n\n    if (await validateHashedData(request.body.password, targetUser.password)){\n        let encryptedUserJwt = await generateUserJWT(\n            {\n                userID: targetUser.id,\n                email: targetUser.email,\n                password: targetUser.password\n            }\n        );\n\n        response.json(encryptedUserJwt);\n\n    } else {\n        response.status(400).json({message:\"Invalid user details provided.\"});\n    }\n});\n\n// Extend a user's JWT validity\nrouter.post('/token-refresh', async(request, response) => {\n    let oldToken = request.body.jwt;\n    let refreshResult = await verifyUserJWT(oldToken).catch(error => {return {error: error.message}})\n    response.json(refreshResult);\n});\n\n// Update a user\nrouter.put('/:userID', async (request, response) => {\n    let userDetails = {\n        userID: request.params.userID,\n        updatedData: request.body.newUserData\n    };\n\n    response.json(await updateUser(userDetails));\n});\n\n// Delete a user\nrouter.delete('/:userID', async (request, response) => {\n    response.json(await deleteUser(request.params.userID));\n});\n\n// List all users\nrouter.get('/', async (request, response) => {\n    let allUsers = await getAllUsers();\n\n    response.json({\n        userCount: allUsers.length,\n        usersArray: allUsers\n    });\n});\n\n// Show a specific user\nrouter.get('/:userID', async (request, response) => {\n    response.json(await getSpecificUser(request.params.userID));\n});\n\n\n// All involved middleware must be attached to either\n// the app (Express instance), or the router (Express router instance)\n// or the specific route.\nrouter.get('/someProtectedRoute', verifyJwtHeader, verifyJwtRole, onlyAllowAdmins, (request, response) => {\n\n    // No actual functionality here - focus on the middleware!\n    response.json({message: \"Hello authorized world!\"});\n});\n\n// Export the router so that other files can use it:\nmodule.exports = router;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}