{"ast":null,"code":"/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _hoist = require(\"./hoist\");\nvar _emit = require(\"./emit\");\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\nvar util = _interopRequireWildcard(require(\"./util\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]);\n\n      // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n      node.async = false;\n      node.generator = false;\n\n      // Unwrap the wrapper IIFE's environment so super and this and such still work.\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return;\n\n        // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n        var outerFnExpr = getOuterFnExpr(path);\n        // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\");\n\n        // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody);\n        // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n        var wasGeneratorFunction = node.generator;\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n        if (node.async) {\n          node.async = false;\n        }\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        });\n\n        // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n        path.requeue();\n      })\n    }\n  };\n};\n\n// Check if a node should be transformed by regenerator\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n}\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n  if (node.generator &&\n  // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n  return t.clone(node.id);\n}\nvar markInfo = new WeakMap();\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n  return markInfo.get(node);\n}\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n  if (!blockPath) {\n    return node.id;\n  }\n  var block = blockPath.node;\n  _assert[\"default\"].ok(Array.isArray(block.body));\n  var info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes();\n\n    // Convert await expressions to yield expressions.\n    var argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};","map":{"version":3,"names":["_interopRequireDefault","require","_assert","_hoist","_emit","_replaceShorthandObjectMethod","util","_interopRequireWildcard","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","exports","getVisitor","_ref","t","types","Method","path","state","node","shouldRegenerate","container","functionExpression","cloneNode","body","generator","async","returnStatement","callExpression","unwrapFunctionEnvironment","Function","exit","wrapWithTypes","contextId","scope","generateUidIdentifier","argsId","ensureBlock","bodyBlockPath","traverse","awaitVisitor","functionSentVisitor","context","outerBody","innerBody","forEach","childPath","isExpressionStatement","isStringLiteral","expression","push","_blockHoist","length","outerFnExpr","getOuterFnExpr","assertIdentifier","id","innerFnId","identifier","name","vars","hoist","usesThis","usesArguments","getArgsId","clone","argumentsThisVisitor","variableDeclaration","declarations","variableDeclarator","emitter","Emitter","explode","wrapArgs","getContextFunction","tryLocsList","getTryLocsList","nullLiteral","thisExpression","currentScope","hasOwnBinding","rename","parent","wrapCall","runtimeProperty","blockStatement","p","registerDeclaration","oldDirectives","directives","wasGeneratorFunction","isExpression","replaceWithOrRemove","addComment","insertedLocs","getInsertedLocs","NumericLiteral","replaceWith","numericLiteral","value","requeue","opts","asyncGenerators","generators","funPath","getTypes","assertFunction","isFunctionDeclaration","getMarkedFunctionId","markInfo","getMarkInfo","blockPath","findParent","isProgram","isBlockStatement","block","ok","Array","isArray","info","decl","unshiftContainer","declPath","strictEqual","markedId","markCallExp","index","markCallExpPath","FunctionExpressionFunctionDeclarationMethod","skip","Identifier","isReference","ThisExpression","MetaProperty","meta","property","memberExpression","AwaitExpression","argument","yieldExpression"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/regenerator-transform/lib/visit.js"],"sourcesContent":["/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _hoist = require(\"./hoist\");\nvar _emit = require(\"./emit\");\nvar _replaceShorthandObjectMethod = _interopRequireDefault(require(\"./replaceShorthandObjectMethod\"));\nvar util = _interopRequireWildcard(require(\"./util\"));\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { \"default\": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj[\"default\"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\nexports.getVisitor = function (_ref) {\n  var t = _ref.types;\n  return {\n    Method: function Method(path, state) {\n      var node = path.node;\n      if (!shouldRegenerate(node, state)) return;\n      var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);\n      path.get(\"body\").set(\"body\", [t.returnStatement(t.callExpression(container, []))]);\n\n      // Regardless of whether or not the wrapped function is a an async method\n      // or generator the outer function should not be\n      node.async = false;\n      node.generator = false;\n\n      // Unwrap the wrapper IIFE's environment so super and this and such still work.\n      path.get(\"body.body.0.argument.callee\").unwrapFunctionEnvironment();\n    },\n    Function: {\n      exit: util.wrapWithTypes(t, function (path, state) {\n        var node = path.node;\n        if (!shouldRegenerate(node, state)) return;\n\n        // if this is an ObjectMethod, we need to convert it to an ObjectProperty\n        path = (0, _replaceShorthandObjectMethod[\"default\"])(path);\n        node = path.node;\n        var contextId = path.scope.generateUidIdentifier(\"context\");\n        var argsId = path.scope.generateUidIdentifier(\"args\");\n        path.ensureBlock();\n        var bodyBlockPath = path.get(\"body\");\n        if (node.async) {\n          bodyBlockPath.traverse(awaitVisitor);\n        }\n        bodyBlockPath.traverse(functionSentVisitor, {\n          context: contextId\n        });\n        var outerBody = [];\n        var innerBody = [];\n        bodyBlockPath.get(\"body\").forEach(function (childPath) {\n          var node = childPath.node;\n          if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {\n            // Babylon represents directives like \"use strict\" as elements\n            // of a bodyBlockPath.node.directives array, but they could just\n            // as easily be represented (by other parsers) as traditional\n            // string-literal-valued expression statements, so we need to\n            // handle that here. (#248)\n            outerBody.push(node);\n          } else if (node && node._blockHoist != null) {\n            outerBody.push(node);\n          } else {\n            innerBody.push(node);\n          }\n        });\n        if (outerBody.length > 0) {\n          // Only replace the inner body if we actually hoisted any statements\n          // to the outer body.\n          bodyBlockPath.node.body = innerBody;\n        }\n        var outerFnExpr = getOuterFnExpr(path);\n        // Note that getOuterFnExpr has the side-effect of ensuring that the\n        // function has a name (so node.id will always be an Identifier), even\n        // if a temporary name has to be synthesized.\n        t.assertIdentifier(node.id);\n        var innerFnId = t.identifier(node.id.name + \"$\");\n\n        // Turn all declarations into vars, and replace the original\n        // declarations with equivalent assignment expressions.\n        var vars = (0, _hoist.hoist)(path);\n        var context = {\n          usesThis: false,\n          usesArguments: false,\n          getArgsId: function getArgsId() {\n            return t.clone(argsId);\n          }\n        };\n        path.traverse(argumentsThisVisitor, context);\n        if (context.usesArguments) {\n          vars = vars || t.variableDeclaration(\"var\", []);\n          vars.declarations.push(t.variableDeclarator(t.clone(argsId), t.identifier(\"arguments\")));\n        }\n        var emitter = new _emit.Emitter(contextId);\n        emitter.explode(path.get(\"body\"));\n        if (vars && vars.declarations.length > 0) {\n          outerBody.push(vars);\n        }\n        var wrapArgs = [emitter.getContextFunction(innerFnId)];\n        var tryLocsList = emitter.getTryLocsList();\n        if (node.generator) {\n          wrapArgs.push(outerFnExpr);\n        } else if (context.usesThis || tryLocsList || node.async) {\n          // Async functions that are not generators don't care about the\n          // outer function because they don't need it to be marked and don't\n          // inherit from its .prototype.\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (context.usesThis) {\n          wrapArgs.push(t.thisExpression());\n        } else if (tryLocsList || node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (tryLocsList) {\n          wrapArgs.push(tryLocsList);\n        } else if (node.async) {\n          wrapArgs.push(t.nullLiteral());\n        }\n        if (node.async) {\n          // Rename any locally declared \"Promise\" variable,\n          // to use the global one.\n          var currentScope = path.scope;\n          do {\n            if (currentScope.hasOwnBinding(\"Promise\")) currentScope.rename(\"Promise\");\n          } while (currentScope = currentScope.parent);\n          wrapArgs.push(t.identifier(\"Promise\"));\n        }\n        var wrapCall = t.callExpression(util.runtimeProperty(node.async ? \"async\" : \"wrap\"), wrapArgs);\n        outerBody.push(t.returnStatement(wrapCall));\n        node.body = t.blockStatement(outerBody);\n        // We injected a few new variable declarations (for every hoisted var),\n        // so we need to add them to the scope.\n        path.get(\"body.body\").forEach(function (p) {\n          return p.scope.registerDeclaration(p);\n        });\n        var oldDirectives = bodyBlockPath.node.directives;\n        if (oldDirectives) {\n          // Babylon represents directives like \"use strict\" as elements of\n          // a bodyBlockPath.node.directives array. (#248)\n          node.body.directives = oldDirectives;\n        }\n        var wasGeneratorFunction = node.generator;\n        if (wasGeneratorFunction) {\n          node.generator = false;\n        }\n        if (node.async) {\n          node.async = false;\n        }\n        if (wasGeneratorFunction && t.isExpression(node)) {\n          util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty(\"mark\"), [node]));\n          path.addComment(\"leading\", \"#__PURE__\");\n        }\n        var insertedLocs = emitter.getInsertedLocs();\n        path.traverse({\n          NumericLiteral: function NumericLiteral(path) {\n            if (!insertedLocs.has(path.node)) {\n              return;\n            }\n            path.replaceWith(t.numericLiteral(path.node.value));\n          }\n        });\n\n        // Generators are processed in 'exit' handlers so that regenerator only has to run on\n        // an ES5 AST, but that means traversal will not pick up newly inserted references\n        // to things like 'regeneratorRuntime'. To avoid this, we explicitly requeue.\n        path.requeue();\n      })\n    }\n  };\n};\n\n// Check if a node should be transformed by regenerator\nfunction shouldRegenerate(node, state) {\n  if (node.generator) {\n    if (node.async) {\n      // Async generator\n      return state.opts.asyncGenerators !== false;\n    } else {\n      // Plain generator\n      return state.opts.generators !== false;\n    }\n  } else if (node.async) {\n    // Async function\n    return state.opts.async !== false;\n  } else {\n    // Not a generator or async function.\n    return false;\n  }\n}\n\n// Given a NodePath for a Function, return an Expression node that can be\n// used to refer reliably to the function object from inside the function.\n// This expression is essentially a replacement for arguments.callee, with\n// the key advantage that it works in strict mode.\nfunction getOuterFnExpr(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertFunction(node);\n  if (!node.id) {\n    // Default-exported function declarations, and function expressions may not\n    // have a name to reference, so we explicitly add one.\n    node.id = funPath.scope.parent.generateUidIdentifier(\"callee\");\n  }\n  if (node.generator &&\n  // Non-generator functions don't need to be marked.\n  t.isFunctionDeclaration(node)) {\n    // Return the identifier returned by runtime.mark(<node.id>).\n    return getMarkedFunctionId(funPath);\n  }\n  return t.clone(node.id);\n}\nvar markInfo = new WeakMap();\nfunction getMarkInfo(node) {\n  if (!markInfo.has(node)) {\n    markInfo.set(node, {});\n  }\n  return markInfo.get(node);\n}\nfunction getMarkedFunctionId(funPath) {\n  var t = util.getTypes();\n  var node = funPath.node;\n  t.assertIdentifier(node.id);\n  var blockPath = funPath.findParent(function (path) {\n    return path.isProgram() || path.isBlockStatement();\n  });\n  if (!blockPath) {\n    return node.id;\n  }\n  var block = blockPath.node;\n  _assert[\"default\"].ok(Array.isArray(block.body));\n  var info = getMarkInfo(block);\n  if (!info.decl) {\n    info.decl = t.variableDeclaration(\"var\", []);\n    blockPath.unshiftContainer(\"body\", info.decl);\n    info.declPath = blockPath.get(\"body.0\");\n  }\n  _assert[\"default\"].strictEqual(info.declPath.node, info.decl);\n\n  // Get a new unique identifier for our marked variable.\n  var markedId = blockPath.scope.generateUidIdentifier(\"marked\");\n  var markCallExp = t.callExpression(util.runtimeProperty(\"mark\"), [t.clone(node.id)]);\n  var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;\n  var markCallExpPath = info.declPath.get(\"declarations.\" + index + \".init\");\n  _assert[\"default\"].strictEqual(markCallExpPath.node, markCallExp);\n  markCallExpPath.addComment(\"leading\", \"#__PURE__\");\n  return t.clone(markedId);\n}\nvar argumentsThisVisitor = {\n  \"FunctionExpression|FunctionDeclaration|Method\": function FunctionExpressionFunctionDeclarationMethod(path) {\n    path.skip();\n  },\n  Identifier: function Identifier(path, state) {\n    if (path.node.name === \"arguments\" && util.isReference(path)) {\n      util.replaceWithOrRemove(path, state.getArgsId());\n      state.usesArguments = true;\n    }\n  },\n  ThisExpression: function ThisExpression(path, state) {\n    state.usesThis = true;\n  }\n};\nvar functionSentVisitor = {\n  MetaProperty: function MetaProperty(path) {\n    var node = path.node;\n    if (node.meta.name === \"function\" && node.property.name === \"sent\") {\n      var t = util.getTypes();\n      util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier(\"_sent\")));\n    }\n  }\n};\nvar awaitVisitor = {\n  Function: function Function(path) {\n    path.skip(); // Don't descend into nested function scopes.\n  },\n\n  AwaitExpression: function AwaitExpression(path) {\n    var t = util.getTypes();\n\n    // Convert await expressions to yield expressions.\n    var argument = path.node.argument;\n\n    // Transforming `await x` to `yield regeneratorRuntime.awrap(x)`\n    // causes the argument to be wrapped in such a way that the runtime\n    // can distinguish between awaited and merely yielded values.\n    util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty(\"awrap\"), [argument]), false));\n  }\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}