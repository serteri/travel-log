{"ast":null,"code":"'use strict';\n\nconst generate = require('@babel/regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\nfunction flatMap(array, callback) {\n  const result = [];\n  array.forEach(item => {\n    const res = callback(item);\n    if (Array.isArray(res)) {\n      result.push.apply(result, res);\n    } else {\n      result.push(res);\n    }\n  });\n  return result;\n}\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\nconst ASTRAL_SET = regenerate().addRange(0x10000, 0x10FFFF);\nconst NEWLINE_SET = regenerate().add(\n// `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n0x000A,\n// Line Feed <LF>\n0x000D,\n// Carriage Return <CR>\n0x2028,\n// Line Separator <LS>\n0x2029 // Paragraph Separator <PS>\n);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n.remove(NEWLINE_SET);\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n  if (unicode) {\n    if (ignoreCase) {\n      return ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n    }\n    return ESCAPE_SETS.UNICODE.get(character);\n  }\n  return ESCAPE_SETS.REGULAR.get(character);\n};\nconst getUnicodeDotSet = dotAll => {\n  return dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\nconst getUnicodePropertyValueSet = (property, value) => {\n  const path = value ? `${property}/${value}` : `Binary_Property/${property}`;\n  try {\n    return require(`regenerate-unicode-properties/${path}.js`);\n  } catch (exception) {\n    throw new Error(`Failed to recognize value \\`${value}\\` for property ` + `\\`${property}\\`.`);\n  }\n};\nconst handleLoneUnicodePropertyNameOrValue = value => {\n  // It could be a `General_Category` value or a binary property.\n  // Note: `unicodeMatchPropertyValue` throws on invalid values.\n  try {\n    const property = 'General_Category';\n    const category = unicodeMatchPropertyValue(property, value);\n    return getUnicodePropertyValueSet(property, category);\n  } catch (exception) {}\n  // It’s not a `General_Category` value, so check if it’s a property\n  // of strings.\n  try {\n    return getUnicodePropertyValueSet('Property_of_Strings', value);\n  } catch (exception) {}\n  // Lastly, check if it’s a binary property of single code points.\n  // Note: `unicodeMatchProperty` throws on invalid properties.\n  const property = unicodeMatchProperty(value);\n  return getUnicodePropertyValueSet(property);\n};\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n  const parts = value.split('=');\n  const firstPart = parts[0];\n  let set;\n  if (parts.length == 1) {\n    set = handleLoneUnicodePropertyNameOrValue(firstPart);\n  } else {\n    // The pattern consists of two parts, i.e. `Property=Value`.\n    const property = unicodeMatchProperty(firstPart);\n    const value = unicodeMatchPropertyValue(property, parts[1]);\n    set = getUnicodePropertyValueSet(property, value);\n  }\n  if (isNegative) {\n    if (set.strings) {\n      throw new Error('Cannot negate Unicode property of strings');\n    }\n    return {\n      characters: UNICODE_SET.clone().remove(set.characters),\n      strings: new Set()\n    };\n  }\n  return {\n    characters: set.characters.clone(),\n    strings: set.strings\n    // We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n    ? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1'))) : new Set()\n  };\n};\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n  const set = getUnicodePropertyEscapeSet(property, isNegative);\n  const data = getCharacterClassEmptyData();\n  data.singleChars = set.characters;\n  if (set.strings.size > 0) {\n    data.longStrings = set.strings;\n    data.maybeIncludesStrings = true;\n  }\n  return data;\n};\nfunction configNeedCaseFoldAscii() {\n  return !!config.modifiersData.i;\n}\nfunction configNeedCaseFoldUnicode() {\n  // config.modifiersData.i : undefined | false\n  if (config.modifiersData.i === false) return false;\n  if (!config.transform.unicodeFlag) return false;\n  return Boolean(config.modifiersData.i || config.flags.ignoreCase);\n}\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function (min, max) {\n  const $this = this;\n  do {\n    const folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n    if (folded) {\n      $this.add(folded);\n    }\n  } while (++min <= max);\n  return $this;\n};\nregenerate.prototype.iuRemoveRange = function (min, max) {\n  const $this = this;\n  do {\n    const folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n    if (folded) {\n      $this.remove(folded);\n    }\n  } while (++min <= max);\n  return $this;\n};\nconst update = (item, pattern) => {\n  let tree = parse(pattern, config.useUnicodeFlag ? 'u' : '', {\n    lookbehind: true,\n    namedGroups: true,\n    unicodePropertyEscape: true,\n    unicodeSet: true,\n    modifiers: true\n  });\n  switch (tree.type) {\n    case 'characterClass':\n    case 'group':\n    case 'value':\n      // No wrapping needed.\n      break;\n    default:\n      // Wrap the pattern in a non-capturing group.\n      tree = wrap(tree, pattern);\n  }\n  Object.assign(item, tree);\n};\nconst wrap = (tree, pattern) => {\n  // Wrap the pattern in a non-capturing group.\n  return {\n    'type': 'group',\n    'behavior': 'ignore',\n    'body': [tree],\n    'raw': `(?:${pattern})`\n  };\n};\nconst caseFold = (codePoint, includeAscii, includeUnicode) => {\n  let folded = (includeUnicode ? iuMappings.get(codePoint) : undefined) || [];\n  if (typeof folded === 'number') folded = [folded];\n  if (includeAscii) {\n    if (codePoint >= 0x41 && codePoint <= 0x5A) {\n      folded.push(codePoint + 0x20);\n    } else if (codePoint >= 0x61 && codePoint <= 0x7A) {\n      folded.push(codePoint - 0x20);\n    }\n  }\n  return folded.length == 0 ? false : folded;\n};\nconst buildHandler = action => {\n  switch (action) {\n    case 'union':\n      return {\n        single: (data, cp) => {\n          data.singleChars.add(cp);\n        },\n        regSet: (data, set2) => {\n          data.singleChars.add(set2);\n        },\n        range: (data, start, end) => {\n          data.singleChars.addRange(start, end);\n        },\n        iuRange: (data, start, end) => {\n          data.singleChars.iuAddRange(start, end);\n        },\n        nested: (data, nestedData) => {\n          data.singleChars.add(nestedData.singleChars);\n          for (const str of nestedData.longStrings) data.longStrings.add(str);\n          if (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n        }\n      };\n    case 'union-negative':\n      {\n        const regSet = (data, set2) => {\n          data.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n        };\n        return {\n          single: (data, cp) => {\n            const unicode = UNICODE_SET.clone();\n            data.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n          },\n          iuRange: (data, start, end) => {\n            data.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n          }\n        };\n      }\n    case 'intersection':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars = set2;else data.singleChars.intersection(set2);\n        };\n        return {\n          single: (data, cp) => {\n            data.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          regSet: (data, set) => {\n            regSet(data, set);\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.intersection(regenerate().addRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.intersection(regenerate().iuAddRange(start, end));\n            data.longStrings.clear();\n            data.maybeIncludesStrings = false;\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n              if (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n            }\n          }\n        };\n      }\n    case 'subtraction':\n      {\n        const regSet = (data, set2) => {\n          if (data.first) data.singleChars.add(set2);else data.singleChars.remove(set2);\n        };\n        return {\n          single: (data, cp) => {\n            if (data.first) data.singleChars.add(cp);else data.singleChars.remove(cp);\n          },\n          regSet: regSet,\n          range: (data, start, end) => {\n            if (data.first) data.singleChars.addRange(start, end);else data.singleChars.removeRange(start, end);\n          },\n          iuRange: (data, start, end) => {\n            if (data.first) data.singleChars.iuAddRange(start, end);else data.singleChars.iuRemoveRange(start, end);\n          },\n          nested: (data, nestedData) => {\n            regSet(data, nestedData.singleChars);\n            if (data.first) {\n              data.longStrings = nestedData.longStrings;\n              data.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n            } else {\n              for (const str of data.longStrings) {\n                if (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n              }\n            }\n          }\n        };\n      }\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown set action: ${characterClassItem.kind}`);\n  }\n};\nconst getCharacterClassEmptyData = () => ({\n  transformed: config.transform.unicodeFlag,\n  singleChars: regenerate(),\n  longStrings: new Set(),\n  hasEmptyString: false,\n  first: true,\n  maybeIncludesStrings: false\n});\nconst maybeFold = codePoint => {\n  const caseFoldAscii = configNeedCaseFoldAscii();\n  const caseFoldUnicode = configNeedCaseFoldUnicode();\n  if (caseFoldAscii || caseFoldUnicode) {\n    const folded = caseFold(codePoint, caseFoldAscii, caseFoldUnicode);\n    if (folded) {\n      return [codePoint, folded];\n    }\n  }\n  return [codePoint];\n};\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n  const caseFoldAscii = configNeedCaseFoldAscii();\n  const caseFoldUnicode = configNeedCaseFoldUnicode();\n  for (const string of classStrings.strings) {\n    if (string.characters.length === 1) {\n      maybeFold(string.characters[0].codePoint).forEach(cp => {\n        data.singleChars.add(cp);\n      });\n    } else {\n      let stringifiedString;\n      if (caseFoldUnicode || caseFoldAscii) {\n        stringifiedString = '';\n        for (const ch of string.characters) {\n          let set = regenerate(ch.codePoint);\n          const folded = maybeFold(ch.codePoint);\n          if (folded) set.add(folded);\n          stringifiedString += set.toString(regenerateOptions);\n        }\n      } else {\n        stringifiedString = string.characters.map(ch => generate(ch)).join('');\n      }\n      data.longStrings.add(stringifiedString);\n      data.maybeIncludesStrings = true;\n    }\n  }\n  return data;\n};\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n  let data = getCharacterClassEmptyData();\n  let handlePositive;\n  let handleNegative;\n  switch (characterClassItem.kind) {\n    case 'union':\n      handlePositive = buildHandler('union');\n      handleNegative = buildHandler('union-negative');\n      break;\n    case 'intersection':\n      handlePositive = buildHandler('intersection');\n      handleNegative = buildHandler('subtraction');\n      if (config.transform.unicodeSetsFlag) data.transformed = true;\n      break;\n    case 'subtraction':\n      handlePositive = buildHandler('subtraction');\n      handleNegative = buildHandler('intersection');\n      if (config.transform.unicodeSetsFlag) data.transformed = true;\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown character class kind: ${characterClassItem.kind}`);\n  }\n  const caseFoldAscii = configNeedCaseFoldAscii();\n  const caseFoldUnicode = configNeedCaseFoldUnicode();\n  for (const item of characterClassItem.body) {\n    switch (item.type) {\n      case 'value':\n        maybeFold(item.codePoint).forEach(cp => {\n          handlePositive.single(data, cp);\n        });\n        break;\n      case 'characterClassRange':\n        const min = item.min.codePoint;\n        const max = item.max.codePoint;\n        handlePositive.range(data, min, max);\n        if (caseFoldAscii || caseFoldUnicode) {\n          handlePositive.iuRange(data, min, max);\n          data.transformed = true;\n        }\n        break;\n      case 'characterClassEscape':\n        handlePositive.regSet(data, getCharacterClassEscapeSet(item.value, config.flags.unicode, config.flags.ignoreCase));\n        break;\n      case 'unicodePropertyEscape':\n        const nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n        handlePositive.nested(data, nestedData);\n        data.transformed = data.transformed || config.transform.unicodePropertyEscapes || config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings;\n        break;\n      case 'characterClass':\n        const handler = item.negative ? handleNegative : handlePositive;\n        const res = computeCharacterClass(item, regenerateOptions);\n        handler.nested(data, res);\n        data.transformed = true;\n        break;\n      case 'classStrings':\n        handlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n        data.transformed = true;\n        break;\n      // The `default` clause is only here as a safeguard; it should never be\n      // reached. Code coverage tools should ignore it.\n      /* istanbul ignore next */\n      default:\n        throw new Error(`Unknown term type: ${item.type}`);\n    }\n    data.first = false;\n  }\n  if (characterClassItem.negative && data.maybeIncludesStrings) {\n    throw new SyntaxError('Cannot negate set containing strings');\n  }\n  return data;\n};\nconst processCharacterClass = (characterClassItem, regenerateOptions, computed = computeCharacterClass(characterClassItem, regenerateOptions)) => {\n  const negative = characterClassItem.negative;\n  const {\n    singleChars,\n    transformed,\n    longStrings\n  } = computed;\n  if (transformed) {\n    const setStr = singleChars.toString(regenerateOptions);\n    if (negative) {\n      if (config.useUnicodeFlag) {\n        update(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`);\n      } else {\n        if (config.flags.unicode) {\n          if (config.flags.ignoreCase) {\n            const astralCharsSet = singleChars.clone().intersection(ASTRAL_SET);\n            // Assumption: singleChars do not contain lone surrogates.\n            // Regex like /[^\\ud800]/u is not supported\n            const surrogateOrBMPSetStr = singleChars.clone().remove(astralCharsSet).addRange(0xd800, 0xdfff).toString({\n              bmpOnly: true\n            });\n            // Don't generate negative lookahead for astral characters\n            // because the case folding is not working anyway as we break\n            // code points into surrogate pairs.\n            const astralNegativeSetStr = ASTRAL_SET.clone().remove(astralCharsSet).toString(regenerateOptions);\n            // The transform here does not support lone surrogates.\n            update(characterClassItem, `(?!${surrogateOrBMPSetStr})[\\\\s\\\\S]|${astralNegativeSetStr}`);\n          } else {\n            // Generate negative set directly when case folding is not involved.\n            update(characterClassItem, UNICODE_SET.clone().remove(singleChars).toString(regenerateOptions));\n          }\n        } else {\n          update(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`);\n        }\n      }\n    } else {\n      const hasEmptyString = longStrings.has('');\n      const pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n      if (setStr !== '[]' || longStrings.size === 0) {\n        pieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n      }\n      update(characterClassItem, pieces.join('|'));\n    }\n  }\n  return characterClassItem;\n};\nconst assertNoUnmatchedReferences = groups => {\n  const unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n  if (unmatchedReferencesNames.length > 0) {\n    throw new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n  }\n};\nconst processModifiers = (item, regenerateOptions, groups) => {\n  const enabling = item.modifierFlags.enabling;\n  const disabling = item.modifierFlags.disabling;\n  delete item.modifierFlags;\n  item.behavior = 'ignore';\n  const oldData = Object.assign({}, config.modifiersData);\n  enabling.split('').forEach(flag => {\n    config.modifiersData[flag] = true;\n  });\n  disabling.split('').forEach(flag => {\n    config.modifiersData[flag] = false;\n  });\n  item.body = item.body.map(term => {\n    return processTerm(term, regenerateOptions, groups);\n  });\n  config.modifiersData = oldData;\n  return item;\n};\nconst processTerm = (item, regenerateOptions, groups) => {\n  switch (item.type) {\n    case 'dot':\n      if (config.transform.unicodeFlag) {\n        update(item, getUnicodeDotSet(config.flags.dotAll || config.modifiersData.s).toString(regenerateOptions));\n      } else if (config.transform.dotAllFlag || config.modifiersData.s) {\n        // TODO: consider changing this at the regenerate level.\n        update(item, '[\\\\s\\\\S]');\n      }\n      break;\n    case 'characterClass':\n      item = processCharacterClass(item, regenerateOptions);\n      break;\n    case 'unicodePropertyEscape':\n      const data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n      if (data.maybeIncludesStrings) {\n        if (!config.flags.unicodeSets) {\n          throw new Error('Properties of strings are only supported when using the unicodeSets (v) flag.');\n        }\n        if (config.transform.unicodeSetsFlag) {\n          data.transformed = true;\n          item = processCharacterClass(item, regenerateOptions, data);\n        }\n      } else if (config.transform.unicodePropertyEscapes) {\n        update(item, data.singleChars.toString(regenerateOptions));\n      }\n      break;\n    case 'characterClassEscape':\n      if (config.transform.unicodeFlag) {\n        update(item, getCharacterClassEscapeSet(item.value, /* config.transform.unicodeFlag implies config.flags.unicode */true, config.flags.ignoreCase).toString(regenerateOptions));\n      }\n      break;\n    case 'group':\n      if (item.behavior == 'normal') {\n        groups.lastIndex++;\n      }\n      if (item.name) {\n        const name = item.name.value;\n        if (groups.namesConflicts[name]) {\n          throw new Error(`Group '${name}' has already been defined in this context.`);\n        }\n        groups.namesConflicts[name] = true;\n        if (config.transform.namedGroups) {\n          delete item.name;\n        }\n        const index = groups.lastIndex;\n        if (!groups.names[name]) {\n          groups.names[name] = [];\n        }\n        groups.names[name].push(index);\n        if (groups.onNamedGroup) {\n          groups.onNamedGroup.call(null, name, index);\n        }\n        if (groups.unmatchedReferences[name]) {\n          delete groups.unmatchedReferences[name];\n        }\n      }\n      if (item.modifierFlags && config.transform.modifiers) {\n        return processModifiers(item, regenerateOptions, groups);\n      }\n    /* falls through */\n    case 'quantifier':\n      item.body = item.body.map(term => {\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n    case 'disjunction':\n      const outerNamesConflicts = groups.namesConflicts;\n      item.body = item.body.map(term => {\n        groups.namesConflicts = Object.create(outerNamesConflicts);\n        return processTerm(term, regenerateOptions, groups);\n      });\n      break;\n    case 'alternative':\n      item.body = flatMap(item.body, term => {\n        const res = processTerm(term, regenerateOptions, groups);\n        // Alternatives cannot contain alternatives; flatten them.\n        return res.type === 'alternative' ? res.body : res;\n      });\n      break;\n    case 'value':\n      const codePoint = item.codePoint;\n      const set = regenerate(codePoint);\n      const folded = maybeFold(codePoint);\n      set.add(folded);\n      update(item, set.toString(regenerateOptions));\n      break;\n    case 'reference':\n      if (item.name) {\n        const name = item.name.value;\n        const indexes = groups.names[name];\n        if (!indexes) {\n          groups.unmatchedReferences[name] = true;\n        }\n        if (config.transform.namedGroups) {\n          if (indexes) {\n            const body = indexes.map(index => ({\n              'type': 'reference',\n              'matchIndex': index,\n              'raw': '\\\\' + index\n            }));\n            if (body.length === 1) {\n              return body[0];\n            }\n            return {\n              'type': 'alternative',\n              'body': body,\n              'raw': body.map(term => term.raw).join('')\n            };\n          }\n\n          // This named reference comes before the group where it’s defined,\n          // so it’s always an empty match.\n          return {\n            'type': 'group',\n            'behavior': 'ignore',\n            'body': [],\n            'raw': '(?:)'\n          };\n        }\n      }\n      break;\n    case 'anchor':\n      if (config.modifiersData.m) {\n        if (item.kind == 'start') {\n          update(item, `(?:^|(?<=${NEWLINE_SET.toString()}))`);\n        } else if (item.kind == 'end') {\n          update(item, `(?:$|(?=${NEWLINE_SET.toString()}))`);\n        }\n      }\n    case 'empty':\n      // Nothing to do here.\n      break;\n    // The `default` clause is only here as a safeguard; it should never be\n    // reached. Code coverage tools should ignore it.\n    /* istanbul ignore next */\n    default:\n      throw new Error(`Unknown term type: ${item.type}`);\n  }\n  return item;\n};\nconst config = {\n  'flags': {\n    'ignoreCase': false,\n    'unicode': false,\n    'unicodeSets': false,\n    'dotAll': false,\n    'multiline': false\n  },\n  'transform': {\n    'dotAllFlag': false,\n    'unicodeFlag': false,\n    'unicodeSetsFlag': false,\n    'unicodePropertyEscapes': false,\n    'namedGroups': false,\n    'modifiers': false\n  },\n  'modifiersData': {\n    'i': undefined,\n    's': undefined,\n    'm': undefined\n  },\n  get useUnicodeFlag() {\n    return (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n  }\n};\nconst validateOptions = options => {\n  if (!options) return;\n  for (const key of Object.keys(options)) {\n    const value = options[key];\n    switch (key) {\n      case 'dotAllFlag':\n      case 'unicodeFlag':\n      case 'unicodePropertyEscapes':\n      case 'namedGroups':\n        if (value != null && value !== false && value !== 'transform') {\n          throw new Error(`.${key} must be false (default) or 'transform'.`);\n        }\n        break;\n      case 'modifiers':\n      case 'unicodeSetsFlag':\n        if (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n          throw new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n        }\n        break;\n      case 'onNamedGroup':\n      case 'onNewFlags':\n        if (value != null && typeof value !== 'function') {\n          throw new Error(`.${key} must be a function.`);\n        }\n        break;\n      default:\n        throw new Error(`.${key} is not a valid regexpu-core option.`);\n    }\n  }\n};\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\nconst rewritePattern = (pattern, flags, options) => {\n  validateOptions(options);\n  config.flags.unicode = hasFlag(flags, 'u');\n  config.flags.unicodeSets = hasFlag(flags, 'v');\n  config.flags.ignoreCase = hasFlag(flags, 'i');\n  config.flags.dotAll = hasFlag(flags, 's');\n  config.flags.multiline = hasFlag(flags, 'm');\n  config.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n  config.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n  config.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n  // unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n  config.transform.unicodePropertyEscapes = config.flags.unicode && (transform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes'));\n  config.transform.namedGroups = transform(options, 'namedGroups');\n  config.transform.modifiers = transform(options, 'modifiers');\n  config.modifiersData.i = undefined;\n  config.modifiersData.s = undefined;\n  config.modifiersData.m = undefined;\n  const regjsparserFeatures = {\n    'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n    'modifiers': Boolean(options && options.modifiers),\n    // Enable every stable RegExp feature by default\n    'unicodePropertyEscape': true,\n    'namedGroups': true,\n    'lookbehind': true\n  };\n  const regenerateOptions = {\n    'hasUnicodeFlag': config.useUnicodeFlag,\n    'bmpOnly': !config.flags.unicode\n  };\n  const groups = {\n    'onNamedGroup': options && options.onNamedGroup,\n    'lastIndex': 0,\n    'names': Object.create(null),\n    // { [name]: Array<index> }\n    'namesConflicts': Object.create(null),\n    // { [name]: true }\n    'unmatchedReferences': Object.create(null) // { [name]: true }\n  };\n\n  const tree = parse(pattern, flags, regjsparserFeatures);\n  if (config.transform.modifiers) {\n    if (/\\(\\?[a-z]*-[a-z]+:/.test(pattern)) {\n      // the pattern _likely_ contain inline disabled modifiers\n      // we need to traverse to make sure that they are actually modifiers and to collect them\n      const allDisabledModifiers = Object.create(null);\n      const itemStack = [tree];\n      let node;\n      while (node = itemStack.pop(), node != undefined) {\n        if (Array.isArray(node)) {\n          Array.prototype.push.apply(itemStack, node);\n        } else if (typeof node == 'object' && node != null) {\n          for (const key of Object.keys(node)) {\n            const value = node[key];\n            if (key == 'modifierFlags') {\n              if (value.disabling.length > 0) {\n                value.disabling.split('').forEach(flag => {\n                  allDisabledModifiers[flag] = true;\n                });\n              }\n            } else if (typeof value == 'object' && value != null) {\n              itemStack.push(value);\n            }\n          }\n        }\n      }\n      for (const flag of Object.keys(allDisabledModifiers)) {\n        config.modifiersData[flag] = true;\n      }\n    }\n  }\n\n  // Note: `processTerm` mutates `tree` and `groups`.\n  processTerm(tree, regenerateOptions, groups);\n  assertNoUnmatchedReferences(groups);\n  const onNewFlags = options && options.onNewFlags;\n  if (onNewFlags) {\n    let newFlags = flags.split('').filter(flag => !config.modifiersData[flag]).join('');\n    if (config.transform.unicodeSetsFlag) {\n      newFlags = newFlags.replace('v', 'u');\n    }\n    if (config.transform.unicodeFlag) {\n      newFlags = newFlags.replace('u', '');\n    }\n    if (config.transform.dotAllFlag === 'transform') {\n      newFlags = newFlags.replace('s', '');\n    }\n    onNewFlags(newFlags);\n  }\n  return generate(tree);\n};\nmodule.exports = rewritePattern;","map":{"version":3,"names":["generate","require","parse","regenerate","unicodeMatchProperty","unicodeMatchPropertyValue","iuMappings","ESCAPE_SETS","flatMap","array","callback","result","forEach","item","res","Array","isArray","push","apply","SPECIAL_CHARS","UNICODE_SET","addRange","ASTRAL_SET","NEWLINE_SET","add","DOT_SET_UNICODE","clone","remove","getCharacterClassEscapeSet","character","unicode","ignoreCase","UNICODE_IGNORE_CASE","get","UNICODE","REGULAR","getUnicodeDotSet","dotAll","getUnicodePropertyValueSet","property","value","path","exception","Error","handleLoneUnicodePropertyNameOrValue","category","getUnicodePropertyEscapeSet","isNegative","parts","split","firstPart","set","length","strings","characters","Set","map","str","replace","getUnicodePropertyEscapeCharacterClassData","data","getCharacterClassEmptyData","singleChars","size","longStrings","maybeIncludesStrings","configNeedCaseFoldAscii","config","modifiersData","i","configNeedCaseFoldUnicode","transform","unicodeFlag","Boolean","flags","prototype","iuAddRange","min","max","$this","folded","caseFold","iuRemoveRange","update","pattern","tree","useUnicodeFlag","lookbehind","namedGroups","unicodePropertyEscape","unicodeSet","modifiers","type","wrap","Object","assign","codePoint","includeAscii","includeUnicode","undefined","buildHandler","action","single","cp","regSet","set2","range","start","end","iuRange","nested","nestedData","contains","removeRange","first","intersection","clear","has","delete","characterClassItem","kind","transformed","hasEmptyString","maybeFold","caseFoldAscii","caseFoldUnicode","computeClassStrings","classStrings","regenerateOptions","string","stringifiedString","ch","toString","join","computeCharacterClass","handlePositive","handleNegative","unicodeSetsFlag","body","negative","unicodePropertyEscapes","handler","SyntaxError","processCharacterClass","computed","setStr","slice","astralCharsSet","surrogateOrBMPSetStr","bmpOnly","astralNegativeSetStr","pieces","from","sort","a","b","splice","assertNoUnmatchedReferences","groups","unmatchedReferencesNames","keys","unmatchedReferences","processModifiers","enabling","modifierFlags","disabling","behavior","oldData","flag","term","processTerm","s","dotAllFlag","unicodeSets","lastIndex","name","namesConflicts","index","names","onNamedGroup","call","outerNamesConflicts","create","indexes","raw","m","validateOptions","options","key","hasFlag","includes","rewritePattern","multiline","regjsparserFeatures","test","allDisabledModifiers","itemStack","node","pop","onNewFlags","newFlags","filter","module","exports"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/regexpu-core/rewrite-pattern.js"],"sourcesContent":["'use strict';\n\nconst generate = require('@babel/regjsgen').generate;\nconst parse = require('regjsparser').parse;\nconst regenerate = require('regenerate');\nconst unicodeMatchProperty = require('unicode-match-property-ecmascript');\nconst unicodeMatchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst iuMappings = require('./data/iu-mappings.js');\nconst ESCAPE_SETS = require('./data/character-class-escape-sets.js');\n\nfunction flatMap(array, callback) {\n\tconst result = [];\n\tarray.forEach(item => {\n\t\tconst res = callback(item);\n\t\tif (Array.isArray(res)) {\n\t\t\tresult.push.apply(result, res);\n\t\t} else {\n\t\t\tresult.push(res);\n\t\t}\n\t});\n\treturn result;\n}\n\nconst SPECIAL_CHARS = /([\\\\^$.*+?()[\\]{}|])/g;\n\n// Prepare a Regenerate set containing all code points, used for negative\n// character classes (if any).\nconst UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);\n\nconst ASTRAL_SET = regenerate().addRange(0x10000, 0x10FFFF);\n\nconst NEWLINE_SET = regenerate().add(\n\t// `LineTerminator`s (https://mths.be/es6#sec-line-terminators):\n\t0x000A, // Line Feed <LF>\n\t0x000D, // Carriage Return <CR>\n\t0x2028, // Line Separator <LS>\n\t0x2029  // Paragraph Separator <PS>\n);\n\n// Prepare a Regenerate set containing all code points that are supposed to be\n// matched by `/./u`. https://mths.be/es6#sec-atom\nconst DOT_SET_UNICODE = UNICODE_SET.clone() // all Unicode code points\n\t.remove(NEWLINE_SET);\n\nconst getCharacterClassEscapeSet = (character, unicode, ignoreCase) => {\n\tif (unicode) {\n\t\tif (ignoreCase) {\n\t\t\treturn ESCAPE_SETS.UNICODE_IGNORE_CASE.get(character);\n\t\t}\n\t\treturn ESCAPE_SETS.UNICODE.get(character);\n\t}\n\treturn ESCAPE_SETS.REGULAR.get(character);\n};\n\nconst getUnicodeDotSet = (dotAll) => {\n\treturn dotAll ? UNICODE_SET : DOT_SET_UNICODE;\n};\n\nconst getUnicodePropertyValueSet = (property, value) => {\n\tconst path = value ?\n\t\t`${ property }/${ value }` :\n\t\t`Binary_Property/${ property }`;\n\ttry {\n\t\treturn require(`regenerate-unicode-properties/${ path }.js`);\n\t} catch (exception) {\n\t\tthrow new Error(\n\t\t\t`Failed to recognize value \\`${ value }\\` for property ` +\n\t\t\t`\\`${ property }\\`.`\n\t\t);\n\t}\n};\n\nconst handleLoneUnicodePropertyNameOrValue = (value) => {\n\t// It could be a `General_Category` value or a binary property.\n\t// Note: `unicodeMatchPropertyValue` throws on invalid values.\n\ttry {\n\t\tconst property = 'General_Category';\n\t\tconst category = unicodeMatchPropertyValue(property, value);\n\t\treturn getUnicodePropertyValueSet(property, category);\n\t} catch (exception) {}\n\t// It’s not a `General_Category` value, so check if it’s a property\n\t// of strings.\n\ttry {\n\t\treturn getUnicodePropertyValueSet('Property_of_Strings', value);\n\t} catch (exception) {}\n\t// Lastly, check if it’s a binary property of single code points.\n\t// Note: `unicodeMatchProperty` throws on invalid properties.\n\tconst property = unicodeMatchProperty(value);\n\treturn getUnicodePropertyValueSet(property);\n};\n\nconst getUnicodePropertyEscapeSet = (value, isNegative) => {\n\tconst parts = value.split('=');\n\tconst firstPart = parts[0];\n\tlet set;\n\tif (parts.length == 1) {\n\t\tset = handleLoneUnicodePropertyNameOrValue(firstPart);\n\t} else {\n\t\t// The pattern consists of two parts, i.e. `Property=Value`.\n\t\tconst property = unicodeMatchProperty(firstPart);\n\t\tconst value = unicodeMatchPropertyValue(property, parts[1]);\n\t\tset = getUnicodePropertyValueSet(property, value);\n\t}\n\tif (isNegative) {\n\t\tif (set.strings) {\n\t\t\tthrow new Error('Cannot negate Unicode property of strings');\n\t\t}\n\t\treturn {\n\t\t\tcharacters: UNICODE_SET.clone().remove(set.characters),\n\t\t\tstrings: new Set()\n\t\t};\n\t}\n\treturn {\n\t\tcharacters: set.characters.clone(),\n\t\tstrings: set.strings\n\t\t\t// We need to escape strings like *️⃣ to make sure that they can be safely used in unions.\n\t\t\t? new Set(set.strings.map(str => str.replace(SPECIAL_CHARS, '\\\\$1')))\n\t\t\t: new Set()\n\t};\n};\n\nconst getUnicodePropertyEscapeCharacterClassData = (property, isNegative) => {\n\tconst set = getUnicodePropertyEscapeSet(property, isNegative);\n\tconst data = getCharacterClassEmptyData();\n\tdata.singleChars = set.characters;\n\tif (set.strings.size > 0) {\n\t\tdata.longStrings = set.strings;\n\t\tdata.maybeIncludesStrings = true;\n\t}\n\treturn data;\n};\n\nfunction configNeedCaseFoldAscii() {\n\treturn !!config.modifiersData.i;\n}\n\nfunction configNeedCaseFoldUnicode() {\n\t// config.modifiersData.i : undefined | false\n\tif (config.modifiersData.i === false) return false;\n\tif (!config.transform.unicodeFlag) return false;\n\treturn Boolean(config.modifiersData.i || config.flags.ignoreCase);\n}\n\n// Given a range of code points, add any case-folded code points in that range\n// to a set.\nregenerate.prototype.iuAddRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n\t\tif (folded) {\n\t\t\t$this.add(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\nregenerate.prototype.iuRemoveRange = function(min, max) {\n\tconst $this = this;\n\tdo {\n\t\tconst folded = caseFold(min, configNeedCaseFoldAscii(), configNeedCaseFoldUnicode());\n\t\tif (folded) {\n\t\t\t$this.remove(folded);\n\t\t}\n\t} while (++min <= max);\n\treturn $this;\n};\n\nconst update = (item, pattern) => {\n\tlet tree = parse(pattern, config.useUnicodeFlag ? 'u' : '', {\n\t\tlookbehind: true,\n\t\tnamedGroups: true,\n\t\tunicodePropertyEscape: true,\n\t\tunicodeSet: true,\n\t\tmodifiers: true,\n\t});\n\tswitch (tree.type) {\n\t\tcase 'characterClass':\n\t\tcase 'group':\n\t\tcase 'value':\n\t\t\t// No wrapping needed.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t// Wrap the pattern in a non-capturing group.\n\t\t\ttree = wrap(tree, pattern);\n\t}\n\tObject.assign(item, tree);\n};\n\nconst wrap = (tree, pattern) => {\n\t// Wrap the pattern in a non-capturing group.\n\treturn {\n\t\t'type': 'group',\n\t\t'behavior': 'ignore',\n\t\t'body': [tree],\n\t\t'raw': `(?:${ pattern })`\n\t};\n};\n\nconst caseFold = (codePoint, includeAscii, includeUnicode) => {\n\tlet folded = (includeUnicode ? iuMappings.get(codePoint) : undefined) || [];\n\tif (typeof folded === 'number') folded = [folded];\n\tif (includeAscii) {\n\t\tif (codePoint >= 0x41 && codePoint <= 0x5A) {\n\t\t\tfolded.push(codePoint + 0x20);\n\t\t} else if (codePoint >= 0x61 && codePoint <= 0x7A) {\n\t\t\tfolded.push(codePoint - 0x20);\n\t\t}\n\t}\n\treturn folded.length == 0 ? false : folded;\n};\n\nconst buildHandler = (action) => {\n\tswitch (action) {\n\t\tcase 'union':\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars.add(cp);\n\t\t\t\t},\n\t\t\t\tregSet: (data, set2) => {\n\t\t\t\t\tdata.singleChars.add(set2);\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.addRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars.iuAddRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tdata.singleChars.add(nestedData.singleChars);\n\t\t\t\t\tfor (const str of nestedData.longStrings) data.longStrings.add(str);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) data.maybeIncludesStrings = true;\n\t\t\t\t}\n\t\t\t};\n\t\tcase 'union-negative': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tdata.singleChars = UNICODE_SET.clone().remove(set2).add(data.singleChars);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tconst unicode = UNICODE_SET.clone();\n\t\t\t\t\tdata.singleChars = data.singleChars.contains(cp) ? unicode : unicode.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().removeRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tdata.singleChars = UNICODE_SET.clone().iuRemoveRange(start, end).add(data.singleChars);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\t\t\t\t\tif (nestedData.maybeIncludesStrings) throw new Error('ASSERTION ERROR');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'intersection': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars = set2;\n\t\t\t\telse data.singleChars.intersection(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tdata.singleChars = data.first || data.singleChars.contains(cp) ? regenerate(cp) : regenerate();\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tregSet: (data, set) => {\n\t\t\t\t\tregSet(data, set);\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().addRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.intersection(regenerate().iuAddRange(start, end));\n\t\t\t\t\tdata.longStrings.clear();\n\t\t\t\t\tdata.maybeIncludesStrings = false;\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (!nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!nestedData.maybeIncludesStrings) data.maybeIncludesStrings = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\tcase 'subtraction': {\n\t\t\tconst regSet = (data, set2) => {\n\t\t\t\tif (data.first) data.singleChars.add(set2);\n\t\t\t\telse data.singleChars.remove(set2);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsingle: (data, cp) => {\n\t\t\t\t\tif (data.first) data.singleChars.add(cp);\n\t\t\t\t\telse data.singleChars.remove(cp);\n\t\t\t\t},\n\t\t\t\tregSet: regSet,\n\t\t\t\trange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.addRange(start, end);\n\t\t\t\t\telse data.singleChars.removeRange(start, end);\n\t\t\t\t},\n\t\t\t\tiuRange: (data, start, end) => {\n\t\t\t\t\tif (data.first) data.singleChars.iuAddRange(start, end);\n\t\t\t\t\telse data.singleChars.iuRemoveRange(start, end);\n\t\t\t\t},\n\t\t\t\tnested: (data, nestedData) => {\n\t\t\t\t\tregSet(data, nestedData.singleChars);\n\n\t\t\t\t\tif (data.first) {\n\t\t\t\t\t\tdata.longStrings = nestedData.longStrings;\n\t\t\t\t\t\tdata.maybeIncludesStrings = nestedData.maybeIncludesStrings;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const str of data.longStrings) {\n\t\t\t\t\t\t\tif (nestedData.longStrings.has(str)) data.longStrings.delete(str);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown set action: ${ characterClassItem.kind }`);\n\t}\n};\n\nconst getCharacterClassEmptyData = () => ({\n\ttransformed: config.transform.unicodeFlag,\n\tsingleChars: regenerate(),\n\tlongStrings: new Set(),\n\thasEmptyString: false,\n\tfirst: true,\n\tmaybeIncludesStrings: false\n});\n\nconst maybeFold = (codePoint) => {\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tif (caseFoldAscii || caseFoldUnicode) {\n\t\tconst folded = caseFold(codePoint, caseFoldAscii, caseFoldUnicode);\n\t\tif (folded) {\n\t\t\treturn [codePoint, folded];\n\t\t}\n\t}\n\treturn [codePoint];\n};\n\nconst computeClassStrings = (classStrings, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tfor (const string of classStrings.strings) {\n\t\tif (string.characters.length === 1) {\n\t\t\tmaybeFold(string.characters[0].codePoint).forEach((cp) => {\n\t\t\t\tdata.singleChars.add(cp);\n\t\t\t});\n\t\t} else {\n\t\t\tlet stringifiedString;\n\t\t\tif (caseFoldUnicode || caseFoldAscii) {\n\t\t\t\tstringifiedString = '';\n\t\t\t\tfor (const ch of string.characters) {\n\t\t\t\t\tlet set = regenerate(ch.codePoint);\n\t\t\t\t\tconst folded = maybeFold(ch.codePoint);\n\t\t\t\t\tif (folded) set.add(folded);\n\t\t\t\t\tstringifiedString += set.toString(regenerateOptions);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstringifiedString = string.characters.map(ch => generate(ch)).join('')\n\t\t\t}\n\n\t\t\tdata.longStrings.add(stringifiedString);\n\t\t\tdata.maybeIncludesStrings = true;\n\t\t}\n\t}\n\n\treturn data;\n}\n\nconst computeCharacterClass = (characterClassItem, regenerateOptions) => {\n\tlet data = getCharacterClassEmptyData();\n\n\tlet handlePositive;\n\tlet handleNegative;\n\n\tswitch (characterClassItem.kind) {\n\t\tcase 'union':\n\t\t\thandlePositive = buildHandler('union');\n\t\t\thandleNegative = buildHandler('union-negative');\n\t\t\tbreak;\n\t\tcase 'intersection':\n\t\t\thandlePositive = buildHandler('intersection');\n\t\t\thandleNegative = buildHandler('subtraction');\n\t\t\tif (config.transform.unicodeSetsFlag) data.transformed = true;\n\t\t\tbreak;\n\t\tcase 'subtraction':\n\t\t\thandlePositive = buildHandler('subtraction');\n\t\t\thandleNegative = buildHandler('intersection');\n\t\t\tif (config.transform.unicodeSetsFlag) data.transformed = true;\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown character class kind: ${ characterClassItem.kind }`);\n\t}\n\n\tconst caseFoldAscii = configNeedCaseFoldAscii();\n\tconst caseFoldUnicode = configNeedCaseFoldUnicode();\n\n\tfor (const item of characterClassItem.body) {\n\t\tswitch (item.type) {\n\t\t\tcase 'value':\n\t\t\t\tmaybeFold(item.codePoint).forEach((cp) => {\n\t\t\t\t\thandlePositive.single(data, cp);\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassRange':\n\t\t\t\tconst min = item.min.codePoint;\n\t\t\t\tconst max = item.max.codePoint;\n\t\t\t\thandlePositive.range(data, min, max);\n\t\t\t\tif (caseFoldAscii || caseFoldUnicode) {\n\t\t\t\t\thandlePositive.iuRange(data, min, max);\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'characterClassEscape':\n\t\t\t\thandlePositive.regSet(data, getCharacterClassEscapeSet(\n\t\t\t\t\titem.value,\n\t\t\t\t\tconfig.flags.unicode,\n\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t));\n\t\t\t\tbreak;\n\t\t\tcase 'unicodePropertyEscape':\n\t\t\t\tconst nestedData = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\t\thandlePositive.nested(data, nestedData);\n\t\t\t\tdata.transformed =\n\t\t\t\t\tdata.transformed ||\n\t\t\t\t\tconfig.transform.unicodePropertyEscapes ||\n\t\t\t\t\t(config.transform.unicodeSetsFlag && nestedData.maybeIncludesStrings);\n\t\t\t\tbreak;\n\t\t\tcase 'characterClass':\n\t\t\t\tconst handler = item.negative ? handleNegative : handlePositive;\n\t\t\t\tconst res = computeCharacterClass(item, regenerateOptions);\n\t\t\t\thandler.nested(data, res);\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\tcase 'classStrings':\n\t\t\t\thandlePositive.nested(data, computeClassStrings(item, regenerateOptions));\n\t\t\t\tdata.transformed = true;\n\t\t\t\tbreak;\n\t\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t\t// reached. Code coverage tools should ignore it.\n\t\t\t/* istanbul ignore next */\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t\t}\n\n\t\tdata.first = false;\n\t}\n\n\tif (characterClassItem.negative && data.maybeIncludesStrings) {\n\t\tthrow new SyntaxError('Cannot negate set containing strings');\n\t}\n\n\treturn data;\n}\n\nconst processCharacterClass = (\n\tcharacterClassItem,\n\tregenerateOptions,\n\tcomputed = computeCharacterClass(characterClassItem, regenerateOptions)\n) => {\n\tconst negative = characterClassItem.negative;\n\tconst { singleChars, transformed, longStrings } = computed;\n\tif (transformed) {\n\t\tconst setStr = singleChars.toString(regenerateOptions);\n\n\t\tif (negative) {\n\t\t\tif (config.useUnicodeFlag) {\n\t\t\t\tupdate(characterClassItem, `[^${setStr[0] === '[' ? setStr.slice(1, -1) : setStr}]`)\n\t\t\t} else {\n\t\t\t\tif (config.flags.unicode) {\n\t\t\t\t\tif (config.flags.ignoreCase) {\n\t\t\t\t\t\tconst astralCharsSet = singleChars.clone().intersection(ASTRAL_SET);\n\t\t\t\t\t\t// Assumption: singleChars do not contain lone surrogates.\n\t\t\t\t\t\t// Regex like /[^\\ud800]/u is not supported\n\t\t\t\t\t\tconst surrogateOrBMPSetStr = singleChars\n\t\t\t\t\t\t\t.clone()\n\t\t\t\t\t\t\t.remove(astralCharsSet)\n\t\t\t\t\t\t\t.addRange(0xd800, 0xdfff)\n\t\t\t\t\t\t\t.toString({ bmpOnly: true });\n\t\t\t\t\t\t// Don't generate negative lookahead for astral characters\n\t\t\t\t\t\t// because the case folding is not working anyway as we break\n\t\t\t\t\t\t// code points into surrogate pairs.\n\t\t\t\t\t\tconst astralNegativeSetStr = ASTRAL_SET\n\t\t\t\t\t\t\t.clone()\n\t\t\t\t\t\t\t.remove(astralCharsSet)\n\t\t\t\t\t\t\t.toString(regenerateOptions);\n\t\t\t\t\t\t// The transform here does not support lone surrogates.\n\t\t\t\t\t\tupdate(\n\t\t\t\t\t\t\tcharacterClassItem,\n\t\t\t\t\t\t\t`(?!${surrogateOrBMPSetStr})[\\\\s\\\\S]|${astralNegativeSetStr}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Generate negative set directly when case folding is not involved.\n\t\t\t\t\t\tupdate(\n\t\t\t\t\t\t\tcharacterClassItem,\n\t\t\t\t\t\t\tUNICODE_SET.clone().remove(singleChars).toString(regenerateOptions)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tupdate(characterClassItem, `(?!${setStr})[\\\\s\\\\S]`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst hasEmptyString = longStrings.has('');\n\t\t\tconst pieces = Array.from(longStrings).sort((a, b) => b.length - a.length);\n\n\t\t\tif (setStr !== '[]' || longStrings.size === 0) {\n\t\t\t\tpieces.splice(pieces.length - (hasEmptyString ? 1 : 0), 0, setStr);\n\t\t\t}\n\n\t\t\tupdate(characterClassItem, pieces.join('|'));\n\t\t}\n\t}\n\treturn characterClassItem;\n};\n\nconst assertNoUnmatchedReferences = (groups) => {\n\tconst unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);\n\tif (unmatchedReferencesNames.length > 0) {\n\t\tthrow new Error(`Unknown group names: ${unmatchedReferencesNames}`);\n\t}\n};\n\nconst processModifiers = (item, regenerateOptions, groups) => {\n\tconst enabling = item.modifierFlags.enabling;\n\tconst disabling = item.modifierFlags.disabling;\n\n\tdelete item.modifierFlags;\n\titem.behavior = 'ignore';\n\n\tconst oldData = Object.assign({}, config.modifiersData);\n\n\tenabling.split('').forEach(flag => {\n\t\tconfig.modifiersData[flag] = true;\n\t});\n\tdisabling.split('').forEach(flag => {\n\t\tconfig.modifiersData[flag] = false;\n\t});\n\n\titem.body = item.body.map(term => {\n\t\treturn processTerm(term, regenerateOptions, groups);\n\t});\n\n\tconfig.modifiersData = oldData;\n\n\treturn item;\n}\n\nconst processTerm = (item, regenerateOptions, groups) => {\n\tswitch (item.type) {\n\t\tcase 'dot':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetUnicodeDotSet(config.flags.dotAll || config.modifiersData.s).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t} else if (config.transform.dotAllFlag || config.modifiersData.s) {\n\t\t\t\t// TODO: consider changing this at the regenerate level.\n\t\t\t\tupdate(item, '[\\\\s\\\\S]');\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClass':\n\t\t\titem = processCharacterClass(item, regenerateOptions);\n\t\t\tbreak;\n\t\tcase 'unicodePropertyEscape':\n\t\t\tconst data = getUnicodePropertyEscapeCharacterClassData(item.value, item.negative);\n\t\t\tif (data.maybeIncludesStrings) {\n\t\t\t\tif (!config.flags.unicodeSets) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'Properties of strings are only supported when using the unicodeSets (v) flag.'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\t\t\tdata.transformed = true;\n\t\t\t\t\titem = processCharacterClass(item, regenerateOptions, data);\n\t\t\t\t}\n\t\t\t} else if (config.transform.unicodePropertyEscapes) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tdata.singleChars.toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'characterClassEscape':\n\t\t\tif (config.transform.unicodeFlag) {\n\t\t\t\tupdate(\n\t\t\t\t\titem,\n\t\t\t\t\tgetCharacterClassEscapeSet(\n\t\t\t\t\t\titem.value,\n\t\t\t\t\t\t/* config.transform.unicodeFlag implies config.flags.unicode */ true,\n\t\t\t\t\t\tconfig.flags.ignoreCase\n\t\t\t\t\t).toString(regenerateOptions)\n\t\t\t\t);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'group':\n\t\t\tif (item.behavior == 'normal') {\n\t\t\t\tgroups.lastIndex++;\n\t\t\t}\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\n\t\t\t\tif (groups.namesConflicts[name]) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Group '${ name }' has already been defined in this context.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tgroups.namesConflicts[name] = true;\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tdelete item.name;\n\t\t\t\t}\n\n\t\t\t\tconst index = groups.lastIndex;\n\t\t\t\tif (!groups.names[name]) {\n\t\t\t\t\tgroups.names[name] = [];\n\t\t\t\t}\n\t\t\t\tgroups.names[name].push(index);\n\n\t\t\t\tif (groups.onNamedGroup) {\n\t\t\t\t\tgroups.onNamedGroup.call(null, name, index);\n\t\t\t\t}\n\n\t\t\t\tif (groups.unmatchedReferences[name]) {\n\t\t\t\t\tdelete groups.unmatchedReferences[name];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (item.modifierFlags && config.transform.modifiers) {\n\t\t\t\treturn processModifiers(item, regenerateOptions, groups);\n\t\t\t}\n\t\t\t/* falls through */\n\t\tcase 'quantifier':\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'disjunction':\n\t\t\tconst outerNamesConflicts = groups.namesConflicts;\n\t\t\titem.body = item.body.map(term => {\n\t\t\t\tgroups.namesConflicts = Object.create(outerNamesConflicts);\n\t\t\t\treturn processTerm(term, regenerateOptions, groups);\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'alternative':\n\t\t\titem.body = flatMap(item.body, term => {\n\t\t\t\tconst res = processTerm(term, regenerateOptions, groups);\n\t\t\t\t// Alternatives cannot contain alternatives; flatten them.\n\t\t\t\treturn res.type === 'alternative' ? res.body : res;\n\t\t\t});\n\t\t\tbreak;\n\t\tcase 'value':\n\t\t\tconst codePoint = item.codePoint;\n\t\t\tconst set = regenerate(codePoint);\n\t\t\tconst folded = maybeFold(codePoint);\n\t\t\tset.add(folded);\n\t\t\tupdate(item, set.toString(regenerateOptions));\n\t\t\tbreak;\n\t\tcase 'reference':\n\t\t\tif (item.name) {\n\t\t\t\tconst name = item.name.value;\n\t\t\t\tconst indexes = groups.names[name];\n\t\t\t\tif (!indexes) {\n\t\t\t\t\tgroups.unmatchedReferences[name] = true;\n\t\t\t\t}\n\n\t\t\t\tif (config.transform.namedGroups) {\n\t\t\t\t\tif (indexes) {\n\t\t\t\t\t\tconst body = indexes.map(index => ({\n\t\t\t\t\t\t\t'type': 'reference',\n\t\t\t\t\t\t\t'matchIndex': index,\n\t\t\t\t\t\t\t'raw': '\\\\' + index,\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (body.length === 1) {\n\t\t\t\t\t\t\treturn body[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t'type': 'alternative',\n\t\t\t\t\t\t\t'body': body,\n\t\t\t\t\t\t\t'raw': body.map(term => term.raw).join(''),\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// This named reference comes before the group where it’s defined,\n\t\t\t\t\t// so it’s always an empty match.\n\t\t\t\t\treturn {\n\t\t\t\t\t\t'type': 'group',\n\t\t\t\t\t\t'behavior': 'ignore',\n\t\t\t\t\t\t'body': [],\n\t\t\t\t\t\t'raw': '(?:)',\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'anchor':\n\t\t\tif (config.modifiersData.m) {\n\t\t\t\tif (item.kind == 'start') {\n\t\t\t\t\tupdate(item, `(?:^|(?<=${NEWLINE_SET.toString()}))`);\n\t\t\t\t} else if (item.kind == 'end') {\n\t\t\t\t\tupdate(item, `(?:$|(?=${NEWLINE_SET.toString()}))`);\n\t\t\t\t}\n\t\t\t}\n\t\tcase 'empty':\n\t\t\t// Nothing to do here.\n\t\t\tbreak;\n\t\t// The `default` clause is only here as a safeguard; it should never be\n\t\t// reached. Code coverage tools should ignore it.\n\t\t/* istanbul ignore next */\n\t\tdefault:\n\t\t\tthrow new Error(`Unknown term type: ${ item.type }`);\n\t}\n\treturn item;\n};\n\nconst config = {\n\t'flags': {\n\t\t'ignoreCase': false,\n\t\t'unicode': false,\n\t\t'unicodeSets': false,\n\t\t'dotAll': false,\n\t\t'multiline': false,\n\t},\n\t'transform': {\n\t\t'dotAllFlag': false,\n\t\t'unicodeFlag': false,\n\t\t'unicodeSetsFlag': false,\n\t\t'unicodePropertyEscapes': false,\n\t\t'namedGroups': false,\n\t\t'modifiers': false,\n\t},\n\t'modifiersData': {\n\t\t'i': undefined,\n\t\t's': undefined,\n\t\t'm': undefined,\n\t},\n\tget useUnicodeFlag() {\n\t\treturn (this.flags.unicode || this.flags.unicodeSets) && !this.transform.unicodeFlag;\n\t}\n};\n\nconst validateOptions = (options) => {\n\tif (!options) return;\n\n\tfor (const key of Object.keys(options)) {\n\t\tconst value = options[key];\n\t\tswitch (key) {\n\t\t\tcase 'dotAllFlag':\n\t\t\tcase 'unicodeFlag':\n\t\t\tcase 'unicodePropertyEscapes':\n\t\t\tcase 'namedGroups':\n\t\t\t\tif (value != null && value !== false && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default) or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'modifiers':\n\t\t\tcase 'unicodeSetsFlag':\n\t\t\t\tif (value != null && value !== false && value !== 'parse' && value !== 'transform') {\n\t\t\t\t\tthrow new Error(`.${key} must be false (default), 'parse' or 'transform'.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'onNamedGroup':\n\t\t\tcase 'onNewFlags':\n\t\t\t\tif (value != null && typeof value !== 'function') {\n\t\t\t\t\tthrow new Error(`.${key} must be a function.`);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`.${key} is not a valid regexpu-core option.`);\n\t\t}\n\t}\n};\n\nconst hasFlag = (flags, flag) => flags ? flags.includes(flag) : false;\nconst transform = (options, name) => options ? options[name] === 'transform' : false;\n\nconst rewritePattern = (pattern, flags, options) => {\n\tvalidateOptions(options);\n\n\tconfig.flags.unicode = hasFlag(flags, 'u');\n\tconfig.flags.unicodeSets = hasFlag(flags, 'v');\n\tconfig.flags.ignoreCase = hasFlag(flags, 'i');\n\tconfig.flags.dotAll = hasFlag(flags, 's');\n\tconfig.flags.multiline = hasFlag(flags, 'm');\n\n\tconfig.transform.dotAllFlag = config.flags.dotAll && transform(options, 'dotAllFlag');\n\tconfig.transform.unicodeFlag = (config.flags.unicode || config.flags.unicodeSets) && transform(options, 'unicodeFlag');\n\tconfig.transform.unicodeSetsFlag = config.flags.unicodeSets && transform(options, 'unicodeSetsFlag');\n\n\t// unicodeFlag: 'transform' implies unicodePropertyEscapes: 'transform'\n\tconfig.transform.unicodePropertyEscapes = config.flags.unicode && (\n\t\ttransform(options, 'unicodeFlag') || transform(options, 'unicodePropertyEscapes')\n\t);\n\tconfig.transform.namedGroups = transform(options, 'namedGroups');\n\tconfig.transform.modifiers = transform(options, 'modifiers');\n\n\tconfig.modifiersData.i = undefined;\n\tconfig.modifiersData.s = undefined;\n\tconfig.modifiersData.m = undefined;\n\n\tconst regjsparserFeatures = {\n\t\t'unicodeSet': Boolean(options && options.unicodeSetsFlag),\n\t\t'modifiers': Boolean(options && options.modifiers),\n\n\t\t// Enable every stable RegExp feature by default\n\t\t'unicodePropertyEscape': true,\n\t\t'namedGroups': true,\n\t\t'lookbehind': true,\n\t};\n\n\tconst regenerateOptions = {\n\t\t'hasUnicodeFlag': config.useUnicodeFlag,\n\t\t'bmpOnly': !config.flags.unicode\n\t};\n\n\tconst groups = {\n\t\t'onNamedGroup': options && options.onNamedGroup,\n\t\t'lastIndex': 0,\n\t\t'names': Object.create(null), // { [name]: Array<index> }\n\t\t'namesConflicts': Object.create(null), // { [name]: true }\n\t\t'unmatchedReferences': Object.create(null) // { [name]: true }\n\t};\n\n\tconst tree = parse(pattern, flags, regjsparserFeatures);\n\n\tif (config.transform.modifiers) {\n\t\tif (/\\(\\?[a-z]*-[a-z]+:/.test(pattern)) {\n\t\t\t// the pattern _likely_ contain inline disabled modifiers\n\t\t\t// we need to traverse to make sure that they are actually modifiers and to collect them\n\t\t\tconst allDisabledModifiers = Object.create(null)\n\t\t\tconst itemStack = [tree];\n\t\t\tlet node;\n\t\t\twhile (node = itemStack.pop(), node != undefined) {\n\t\t\t\tif (Array.isArray(node)) {\n\t\t\t\t\tArray.prototype.push.apply(itemStack, node);\n\t\t\t\t} else if (typeof node == 'object' && node != null) {\n\t\t\t\t\tfor (const key of Object.keys(node)) {\n\t\t\t\t\t\tconst value = node[key];\n\t\t\t\t\t\tif (key == 'modifierFlags') {\n\t\t\t\t\t\t\tif (value.disabling.length > 0){\n\t\t\t\t\t\t\t\tvalue.disabling.split('').forEach((flag)=>{\n\t\t\t\t\t\t\t\t\tallDisabledModifiers[flag] = true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof value == 'object' && value != null) {\n\t\t\t\t\t\t\titemStack.push(value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const flag of Object.keys(allDisabledModifiers)) {\n\t\t\t\tconfig.modifiersData[flag] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Note: `processTerm` mutates `tree` and `groups`.\n\tprocessTerm(tree, regenerateOptions, groups);\n\tassertNoUnmatchedReferences(groups);\n\n\tconst onNewFlags = options && options.onNewFlags;\n\tif (onNewFlags) {\n\t\tlet newFlags = flags.split('').filter((flag) => !config.modifiersData[flag]).join('');\n\t\tif (config.transform.unicodeSetsFlag) {\n\t\t\tnewFlags = newFlags.replace('v', 'u');\n\t\t}\n\t\tif (config.transform.unicodeFlag) {\n\t\t\tnewFlags = newFlags.replace('u', '');\n\t\t}\n\t\tif (config.transform.dotAllFlag === 'transform') {\n\t\t\tnewFlags = newFlags.replace('s', '');\n\t\t}\n\t\tonNewFlags(newFlags);\n\t}\n\n\treturn generate(tree);\n};\n\nmodule.exports = rewritePattern;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}