{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _util = require(\"./util.js\");\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar mMap = new WeakMap();\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n  return mMap.get(node);\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    var t = (0, _util.getTypes)();\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    var result = false;\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert[\"default\"].strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n    var keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n    return result;\n  }\n  function predicate(node) {\n    (0, _util.getTypes)().assertNode(node);\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nvar sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);","map":{"version":3,"names":["_interopRequireDefault","require","_assert","_util","mMap","WeakMap","m","node","has","set","get","hasOwn","Object","prototype","hasOwnProperty","makePredicate","propertyName","knownTypes","onlyChildren","t","getTypes","assertNode","result","check","child","Array","isArray","some","isNode","strictEqual","predicate","keys","VISITOR_KEYS","type","i","length","key","meta","call","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","hasSideEffects","containsLeap"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/regenerator-transform/lib/meta.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _assert = _interopRequireDefault(require(\"assert\"));\nvar _util = require(\"./util.js\");\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar mMap = new WeakMap();\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n  return mMap.get(node);\n}\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    var t = (0, _util.getTypes)();\n    t.assertNode(node);\n\n    // Assume no side effects until we find out otherwise.\n    var result = false;\n    function check(child) {\n      if (result) {\n        // Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert[\"default\"].strictEqual(result, false);\n        result = predicate(child);\n      }\n      return result;\n    }\n    var keys = t.VISITOR_KEYS[node.type];\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n    return result;\n  }\n  function predicate(node) {\n    (0, _util.getTypes)().assertNode(node);\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName];\n\n    // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n};\n\n// These types potentially have side effects regardless of what side\n// effects their subexpressions have.\nvar sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n};\n\n// These types are the direct cause of all leaps in control flow.\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n};\n\n// All leap types are also side effect types.\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}