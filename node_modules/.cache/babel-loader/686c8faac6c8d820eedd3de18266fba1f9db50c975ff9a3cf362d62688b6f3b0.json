{"ast":null,"code":"// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n// ----------------------------------------------------------------------------\n\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n\n// Direct proxies can be created via Proxy(target, handler)\n\n// ----------------------------------------------------------------------------\n\n(function (global) {\n  // function-as-module pattern\n  \"use strict\";\n\n  // === Direct Proxies: Invariant Enforcement ===\n\n  // Direct proxies build on non-direct proxies by automatically wrapping\n  // all user-defined proxy handlers in a Validator handler that checks and\n  // enforces ES5 invariants.\n\n  // A direct proxy is a proxy for an existing object called the target object.\n\n  // A Validator handler is a wrapper for a target proxy handler H.\n  // The Validator forwards all operations to H, but additionally\n  // performs a number of integrity checks on the results of some traps,\n  // to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n  // properties and non-extensible, sealed or frozen objects.\n\n  // For each property that H exposes as own, non-configurable\n  // (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n  // the Validator handler defines those properties on the target object.\n  // When the proxy becomes non-extensible, also configurable own properties\n  // are checked against the target.\n  // We will call properties that are defined on the target object\n  // \"fixed properties\".\n\n  // We will name fixed non-configurable properties \"sealed properties\".\n  // We will name fixed non-configurable non-writable properties \"frozen\n  // properties\".\n\n  // The Validator handler upholds the following invariants w.r.t. non-configurability:\n  // - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n  // - getOwnPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property (e.g. reporting a non-configurable\n  //   property as configurable, or reporting a non-configurable, non-writable\n  //   property as writable)\n  // - getPropertyDescriptor cannot report sealed properties as non-existent\n  // - getPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property. It _can_ report incompatible changes\n  //   to the attributes of non-own, inherited properties.\n  // - defineProperty cannot make incompatible changes to the attributes of\n  //   sealed properties\n  // - deleteProperty cannot report a successful deletion of a sealed property\n  // - hasOwn cannot report a sealed property as non-existent\n  // - has cannot report a sealed property as non-existent\n  // - get cannot report inconsistent values for frozen data\n  //   properties, and must report undefined for sealed accessors with an\n  //   undefined getter\n  // - set cannot report a successful assignment for frozen data\n  //   properties or sealed accessors with an undefined setter.\n  // - get{Own}PropertyNames lists all sealed properties of the target.\n  // - keys lists all enumerable sealed properties of the target.\n  // - enumerate lists all enumerable sealed properties of the target.\n  // - if a property of a non-extensible proxy is reported as non-existent,\n  //   then it must forever be reported as non-existent. This applies to\n  //   own and inherited properties and is enforced in the\n  //   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n  //   get{Own}PropertyNames, keys and enumerate traps\n\n  // Violation of any of these invariants by H will result in TypeError being\n  // thrown.\n\n  // Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n  // is invoked on the proxy, the set of own property names for the proxy is\n  // fixed. Any property name that is not fixed is called a 'new' property.\n\n  // The Validator upholds the following invariants regarding extensibility:\n  // - getOwnPropertyDescriptor cannot report new properties as existent\n  //   (it must report them as non-existent by returning undefined)\n  // - defineProperty cannot successfully add a new property (it must reject)\n  // - getOwnPropertyNames cannot list new properties\n  // - hasOwn cannot report true for new properties (it must report false)\n  // - keys cannot list new properties\n\n  // Invariants currently not enforced:\n  // - getOwnPropertyNames lists only own property names\n  // - keys lists only enumerable own property names\n  // Both traps may list more property names than are actually defined on the\n  // target.\n\n  // Invariants with regard to inheritance are currently not enforced.\n  // - a non-configurable potentially inherited property on a proxy with\n  //   non-mutable ancestry cannot be reported as non-existent\n  // (An object with non-mutable ancestry is a non-extensible object whose\n  // [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n  // Changes in Handler API compared to previous harmony:proxies, see:\n  // http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n  // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n  // ----------------------------------------------------------------------------\n\n  // ---- WeakMap polyfill ----\n\n  // TODO: find a proper WeakMap polyfill\n\n  // define an empty WeakMap so that at least the Reflect module code\n  // will work in the absence of WeakMaps. Proxy emulation depends on\n  // actual WeakMaps, so will not work with this little shim.\n  if (typeof WeakMap === \"undefined\") {\n    global.WeakMap = function () {};\n    global.WeakMap.prototype = {\n      get: function (k) {\n        return undefined;\n      },\n      set: function (k, v) {\n        throw new Error(\"WeakMap not supported\");\n      }\n    };\n  }\n\n  // ---- Normalization functions for property descriptors ----\n\n  function isStandardAttribute(name) {\n    return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n  }\n\n  // Adapted from ES5 section 8.10.5\n  function toPropertyDescriptor(obj) {\n    if (Object(obj) !== obj) {\n      throw new TypeError(\"property descriptor should be an Object, given: \" + obj);\n    }\n    var desc = {};\n    if ('enumerable' in obj) {\n      desc.enumerable = !!obj.enumerable;\n    }\n    if ('configurable' in obj) {\n      desc.configurable = !!obj.configurable;\n    }\n    if ('value' in obj) {\n      desc.value = obj.value;\n    }\n    if ('writable' in obj) {\n      desc.writable = !!obj.writable;\n    }\n    if ('get' in obj) {\n      var getter = obj.get;\n      if (getter !== undefined && typeof getter !== \"function\") {\n        throw new TypeError(\"property descriptor 'get' attribute must be \" + \"callable or undefined, given: \" + getter);\n      }\n      desc.get = getter;\n    }\n    if ('set' in obj) {\n      var setter = obj.set;\n      if (setter !== undefined && typeof setter !== \"function\") {\n        throw new TypeError(\"property descriptor 'set' attribute must be \" + \"callable or undefined, given: \" + setter);\n      }\n      desc.set = setter;\n    }\n    if ('get' in desc || 'set' in desc) {\n      if ('value' in desc || 'writable' in desc) {\n        throw new TypeError(\"property descriptor cannot be both a data and an \" + \"accessor descriptor: \" + obj);\n      }\n    }\n    return desc;\n  }\n  function isAccessorDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'get' in desc || 'set' in desc;\n  }\n  function isDataDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'value' in desc || 'writable' in desc;\n  }\n  function isGenericDescriptor(desc) {\n    if (desc === undefined) return false;\n    return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n  }\n  function toCompletePropertyDescriptor(desc) {\n    var internalDesc = toPropertyDescriptor(desc);\n    if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n      if (!('value' in internalDesc)) {\n        internalDesc.value = undefined;\n      }\n      if (!('writable' in internalDesc)) {\n        internalDesc.writable = false;\n      }\n    } else {\n      if (!('get' in internalDesc)) {\n        internalDesc.get = undefined;\n      }\n      if (!('set' in internalDesc)) {\n        internalDesc.set = undefined;\n      }\n    }\n    if (!('enumerable' in internalDesc)) {\n      internalDesc.enumerable = false;\n    }\n    if (!('configurable' in internalDesc)) {\n      internalDesc.configurable = false;\n    }\n    return internalDesc;\n  }\n  function isEmptyDescriptor(desc) {\n    return !('get' in desc) && !('set' in desc) && !('value' in desc) && !('writable' in desc) && !('enumerable' in desc) && !('configurable' in desc);\n  }\n  function isEquivalentDescriptor(desc1, desc2) {\n    return sameValue(desc1.get, desc2.get) && sameValue(desc1.set, desc2.set) && sameValue(desc1.value, desc2.value) && sameValue(desc1.writable, desc2.writable) && sameValue(desc1.enumerable, desc2.enumerable) && sameValue(desc1.configurable, desc2.configurable);\n  }\n\n  // copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n  function sameValue(x, y) {\n    if (x === y) {\n      // 0 === -0, but they are not identical\n      return x !== 0 || 1 / x === 1 / y;\n    }\n\n    // NaN !== NaN, but they are identical.\n    // NaNs are the only non-reflexive value, i.e., if x !== x,\n    // then x is a NaN.\n    // isNaN is broken: it converts its argument to number, so\n    // isNaN(\"foo\") => true\n    return x !== x && y !== y;\n  }\n\n  /**\n   * Returns a fresh property descriptor that is guaranteed\n   * to be complete (i.e. contain all the standard attributes).\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, returns undefined.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n  function normalizeAndCompletePropertyDescriptor(attributes) {\n    if (attributes === undefined) {\n      return undefined;\n    }\n    var desc = toCompletePropertyDescriptor(attributes);\n    // Note: no need to call FromPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    return desc;\n  }\n\n  /**\n   * Returns a fresh property descriptor whose standard\n   * attributes are guaranteed to be data properties of the right type.\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, will throw a TypeError.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n  function normalizePropertyDescriptor(attributes) {\n    var desc = toPropertyDescriptor(attributes);\n    // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n    return desc;\n  }\n\n  // store a reference to the real ES5 primitives before patching them later\n  var prim_preventExtensions = Object.preventExtensions,\n    prim_seal = Object.seal,\n    prim_freeze = Object.freeze,\n    prim_isExtensible = Object.isExtensible,\n    prim_isSealed = Object.isSealed,\n    prim_isFrozen = Object.isFrozen,\n    prim_getPrototypeOf = Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty = Object.defineProperty,\n    prim_defineProperties = Object.defineProperties,\n    prim_keys = Object.keys,\n    prim_getOwnPropertyNames = Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols = Object.getOwnPropertySymbols,\n    prim_assign = Object.assign,\n    prim_isArray = Array.isArray,\n    prim_concat = Array.prototype.concat,\n    prim_isPrototypeOf = Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  // these will point to the patched versions of the respective methods on\n  // Object. They are used within this module as the \"intrinsic\" bindings\n  // of these methods (i.e. the \"original\" bindings as defined in the spec)\n  var Object_isFrozen, Object_isSealed, Object_isExtensible, Object_getPrototypeOf, Object_getOwnPropertyNames;\n\n  /**\n   * A property 'name' is fixed if it is an own property of the target.\n   */\n  function isFixed(name, target) {\n    return {}.hasOwnProperty.call(target, name);\n  }\n  function isSealed(name, target) {\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return false;\n    }\n    return desc.configurable === false;\n  }\n  function isSealedDesc(desc) {\n    return desc !== undefined && desc.configurable === false;\n  }\n\n  /**\n   * Performs all validation that Object.defineProperty performs,\n   * without actually defining the property. Returns a boolean\n   * indicating whether validation succeeded.\n   *\n   * Implementation transliterated from ES5.1 section 8.12.9\n   */\n  function isCompatibleDescriptor(extensible, current, desc) {\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      return true;\n    }\n    if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n      return true;\n    }\n    if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  // ES6 7.3.11 SetIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n  function setIntegrityLevel(target, level) {\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n    if (level === \"sealed\") {\n      var l = +ownProps.length;\n      var k;\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n        try {\n          Object.defineProperty(target, k, {\n            configurable: false\n          });\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    } else {\n      // level === \"frozen\"\n      var l = +ownProps.length;\n      var k;\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n        try {\n          var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n          if (currentDesc !== undefined) {\n            var desc;\n            if (isAccessorDescriptor(currentDesc)) {\n              desc = {\n                configurable: false\n              };\n            } else {\n              desc = {\n                configurable: false,\n                writable: false\n              };\n            }\n            Object.defineProperty(target, k, desc);\n          }\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    }\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n    return Reflect.preventExtensions(target);\n  }\n\n  // ES6 7.3.12 TestIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n  function testIntegrityLevel(target, level) {\n    var isExtensible = Object_isExtensible(target);\n    if (isExtensible) return false;\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n    var configurable = false;\n    var writable = false;\n    var l = +ownProps.length;\n    var k;\n    var currentDesc;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        configurable = configurable || currentDesc.configurable;\n        if (isDataDescriptor(currentDesc)) {\n          writable = writable || currentDesc.writable;\n        }\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n          configurable = true;\n        }\n      }\n    }\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n    if (level === \"frozen\" && writable === true) {\n      return false;\n    }\n    if (configurable === true) {\n      return false;\n    }\n    return true;\n  }\n\n  // ---- The Validator handler wrapper around user handlers ----\n\n  /**\n   * @param target the object wrapped by this proxy.\n   * As long as the proxy is extensible, only non-configurable properties\n   * are checked against the target. Once the proxy becomes non-extensible,\n   * invariants w.r.t. non-extensibility are also enforced.\n   *\n   * @param handler the handler of the direct proxy. The object emulated by\n   * this handler is validated against the target object of the direct proxy.\n   * Any violations that the handler makes against the invariants\n   * of the target will cause a TypeError to be thrown.\n   *\n   * Both target and handler must be proper Objects at initialization time.\n   */\n  function Validator(target, handler) {\n    // for non-revokable proxies, these are const references\n    // for revokable proxies, on revocation:\n    // - this.target is set to null\n    // - this.handler is set to a handler that throws on all traps\n    this.target = target;\n    this.handler = handler;\n  }\n  Validator.prototype = {\n    /**\n     * If getTrap returns undefined, the caller should perform the\n     * default forwarding behavior.\n     * If getTrap returns normally otherwise, the return value\n     * will be a callable trap function. When calling the trap function,\n     * the caller is responsible for binding its |this| to |this.handler|.\n     */\n    getTrap: function (trapName) {\n      var trap = this.handler[trapName];\n      if (trap === undefined) {\n        // the trap was not defined,\n        // perform the default forwarding behavior\n        return undefined;\n      }\n      if (typeof trap !== \"function\") {\n        throw new TypeError(trapName + \" trap is not callable: \" + trap);\n      }\n      return trap;\n    },\n    // === fundamental traps ===\n\n    /**\n     * If name denotes a fixed property, check:\n     *   - whether targetHandler reports it as existent\n     *   - whether the returned descriptor is compatible with the fixed property\n     * If the proxy is non-extensible, check:\n     *   - whether name is not a new property\n     * Additionally, the returned descriptor is normalized and completed.\n     */\n    getOwnPropertyDescriptor: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n      if (trap === undefined) {\n        return Reflect.getOwnPropertyDescriptor(this.target, name);\n      }\n      name = String(name);\n      var desc = trap.call(this.handler, this.target, name);\n      desc = normalizeAndCompletePropertyDescriptor(desc);\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n      if (desc === undefined) {\n        if (isSealedDesc(targetDesc)) {\n          throw new TypeError(\"cannot report non-configurable property '\" + name + \"' as non-existent\");\n        }\n        if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n        return undefined;\n      }\n\n      // at this point, we know (desc !== undefined), i.e.\n      // targetHandler reports 'name' as an existing property\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot report a new own property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n      if (name !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot report incompatible property descriptor \" + \"for property '\" + name + \"'\");\n        }\n      }\n      if (desc.configurable === false) {\n        if (targetDesc === undefined || targetDesc.configurable === true) {\n          // if the property is configurable or non-existent on the target,\n          // but is reported as a non-configurable property, it may later be\n          // reported as configurable or non-existent, which violates the\n          // invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot report a non-configurable descriptor \" + \"for configurable or non-existent property '\" + name + \"'\");\n        }\n        if ('writable' in desc && desc.writable === false) {\n          if (targetDesc.writable === true) {\n            // if the property is non-configurable, writable on the target,\n            // but is reported as non-configurable, non-writable, it may later\n            // be reported as non-configurable, writable again, which violates\n            // the invariant that a non-configurable, non-writable property\n            // may not change state.\n            throw new TypeError(\"cannot report non-configurable, writable property '\" + name + \"' as non-configurable, non-writable\");\n          }\n        }\n      }\n      return desc;\n    },\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, instead\n     * of calling this trap, the get, set, has or enumerate traps are\n     * called instead.\n     *\n     * In this implementation, we \"abuse\" getPropertyDescriptor to\n     * support trapping the get or set traps for proxies-as-prototypes.\n     * We do this by returning a getter/setter pair that invokes\n     * the corresponding traps.\n     *\n     * While this hack works for inherited property access, it has some\n     * quirks:\n     *\n     * In Firefox, this trap is only called after a prior invocation\n     * of the 'has' trap has returned true. Hence, expect the following\n     * behavior:\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * child[name] // triggers handler.has(target, name)\n     * // if that returns true, triggers handler.get(target, name, child)\n     * </code>\n     *\n     * On v8, the 'in' operator, when applied to an object that inherits\n     * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n     * That calls the below getPropertyDescriptor trap on the proxy. The\n     * result of the 'in'-operator is then determined by whether this trap\n     * returns undefined or a property descriptor object. That is why\n     * we first explicitly trigger the 'has' trap to determine whether\n     * the property exists.\n     *\n     * This has the side-effect that when enumerating properties on\n     * an object that inherits from a proxy in v8, only properties\n     * for which 'has' returns true are returned:\n     *\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * for (var prop in child) {\n     *   // only enumerates prop if (prop in child) returns true\n     * }\n     * </code>\n     */\n    getPropertyDescriptor: function (name) {\n      var handler = this;\n      if (!handler.has(name)) return undefined;\n      return {\n        get: function () {\n          return handler.get(this, name);\n        },\n        set: function (val) {\n          if (handler.set(this, name, val)) {\n            return val;\n          } else {\n            throw new TypeError(\"failed assignment to \" + name);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      };\n    },\n    /**\n     * If name denotes a fixed property, check for incompatible changes.\n     * If the proxy is non-extensible, check that new properties are rejected.\n     */\n    defineProperty: function (name, desc) {\n      // TODO(tvcutsem): the current tracemonkey implementation of proxies\n      // auto-completes 'desc', which is not correct. 'desc' should be\n      // normalized, but not completed. Consider:\n      // Object.defineProperty(proxy, 'foo', {enumerable:false})\n      // This trap will receive desc =\n      //  {value:undefined,writable:false,enumerable:false,configurable:false}\n      // This will also set all other attributes to their default value,\n      // which is unexpected and different from [[DefineOwnProperty]].\n      // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n      var trap = this.getTrap(\"defineProperty\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.defineProperty(this.target, name, desc);\n      }\n      name = String(name);\n      var descObj = normalizePropertyDescriptor(desc);\n      var success = trap.call(this.handler, this.target, name, descObj);\n      success = !!success; // coerce to Boolean\n\n      if (success === true) {\n        var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        var extensible = Object.isExtensible(this.target);\n\n        // Note: we could collapse the following two if-tests into a single\n        // test. Separating out the cases to improve error reporting.\n\n        if (!extensible) {\n          if (targetDesc === undefined) {\n            throw new TypeError(\"cannot successfully add a new property '\" + name + \"' to a non-extensible object\");\n          }\n        }\n        if (targetDesc !== undefined) {\n          if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n            throw new TypeError(\"cannot define incompatible property \" + \"descriptor for property '\" + name + \"'\");\n          }\n          if (isDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\"cannot successfully define non-configurable, writable \" + \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n        }\n        if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n          // if the property is configurable or non-existent on the target,\n          // but is successfully being redefined as a non-configurable property,\n          // it may later be reported as configurable or non-existent, which violates\n          // the invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot successfully define a non-configurable \" + \"descriptor for configurable or non-existent property '\" + name + \"'\");\n        }\n      }\n      return success;\n    },\n    /**\n     * On success, check whether the target object is indeed non-extensible.\n     */\n    preventExtensions: function () {\n      var trap = this.getTrap(\"preventExtensions\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.preventExtensions(this.target);\n      }\n      var success = trap.call(this.handler, this.target);\n      success = !!success; // coerce to Boolean\n      if (success) {\n        if (Object_isExtensible(this.target)) {\n          throw new TypeError(\"can't report extensible object as non-extensible: \" + this.target);\n        }\n      }\n      return success;\n    },\n    /**\n     * If name denotes a sealed property, check whether handler rejects.\n     */\n    delete: function (name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"deleteProperty\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.deleteProperty(this.target, name);\n      }\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      var targetDesc;\n      if (res === true) {\n        targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        if (targetDesc !== undefined && targetDesc.configurable === false) {\n          throw new TypeError(\"property '\" + name + \"' is non-configurable \" + \"and can't be deleted\");\n        }\n        if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n          // if the property still exists on a non-extensible target but\n          // is reported as successfully deleted, it may later be reported\n          // as present, which violates the invariant that an own property,\n          // deleted from a non-extensible object cannot reappear.\n          throw new TypeError(\"cannot successfully delete existing property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n      return res;\n    },\n    /**\n     * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n     * which now also returns an array (of strings or symbols) and\n     * which performs the same rigorous invariant checks as getOwnPropertyNames\n     *\n     * See issue #48 on how this trap can still get invoked by external libs\n     * that don't use the patched Object.getOwnPropertyNames function.\n     */\n    getOwnPropertyNames: function () {\n      // Note: removed deprecation warning to avoid dependency on 'console'\n      // (and on node, should anyway use util.deprecate). Deprecation warnings\n      // can also be annoying when they are outside of the user's control, e.g.\n      // when an external library calls unpatched Object.getOwnPropertyNames.\n      // Since there is a clean fallback to `ownKeys`, the fact that the\n      // deprecated method is still called is mostly harmless anyway.\n      // See also issues #65 and #66.\n      // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n      return this.ownKeys();\n    },\n    /**\n     * Checks whether the trap result does not contain any new properties\n     * if the proxy is non-extensible.\n     *\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * Additionally, the trap result is normalized.\n     * Instead of returning the trap result directly:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to a String\n     *\n     * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n     * and Object.keys (the latter filters out only the enumerable own properties).\n     */\n    ownKeys: function () {\n      var trap = this.getTrap(\"ownKeys\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.ownKeys(this.target);\n      }\n      var trapResult = trap.call(this.handler, this.target);\n\n      // propNames is used as a set of strings\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n      for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n        if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n          // non-extensible proxies don't tolerate new own property names\n          throw new TypeError(\"ownKeys trap cannot list a new \" + \"property '\" + s + \"' on a non-extensible object\");\n        }\n        propNames[s] = true;\n        result[i] = s;\n      }\n      var ownProps = Object_getOwnPropertyNames(this.target);\n      var target = this.target;\n      ownProps.forEach(function (ownProp) {\n        if (!propNames[ownProp]) {\n          if (isSealed(ownProp, target)) {\n            throw new TypeError(\"ownKeys trap failed to include \" + \"non-configurable property '\" + ownProp + \"'\");\n          }\n          if (!Object.isExtensible(target) && isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\" + ownProp + \"' as non-existent on a non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n    /**\n     * Checks whether the trap result is consistent with the state of the\n     * wrapped target.\n     */\n    isExtensible: function () {\n      var trap = this.getTrap(\"isExtensible\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.isExtensible(this.target);\n      }\n      var result = trap.call(this.handler, this.target);\n      result = !!result; // coerce to Boolean\n      var state = Object_isExtensible(this.target);\n      if (result !== state) {\n        if (result) {\n          throw new TypeError(\"cannot report non-extensible object as extensible: \" + this.target);\n        } else {\n          throw new TypeError(\"cannot report extensible object as non-extensible: \" + this.target);\n        }\n      }\n      return state;\n    },\n    /**\n     * Check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    getPrototypeOf: function () {\n      var trap = this.getTrap(\"getPrototypeOf\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.getPrototypeOf(this.target);\n      }\n      var allegedProto = trap.call(this.handler, this.target);\n      if (!Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n        if (!sameValue(allegedProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n      return allegedProto;\n    },\n    /**\n     * If target is non-extensible and setPrototypeOf trap returns true,\n     * check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    setPrototypeOf: function (newProto) {\n      var trap = this.getTrap(\"setPrototypeOf\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.setPrototypeOf(this.target, newProto);\n      }\n      var success = trap.call(this.handler, this.target, newProto);\n      success = !!success;\n      if (success && !Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n        if (!sameValue(newProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n      return success;\n    },\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, for-in will\n     * call the enumerate() trap. If that trap is not defined, the\n     * operation is forwarded to the target, no more fallback on this\n     * fundamental trap.\n     */\n    getPropertyNames: function () {\n      throw new TypeError(\"getPropertyNames trap is deprecated\");\n    },\n    // === derived traps ===\n\n    /**\n     * If name denotes a fixed property, check whether the trap returns true.\n     */\n    has: function (name) {\n      var trap = this.getTrap(\"has\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.has(this.target, name);\n      }\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      if (res === false) {\n        if (isSealed(name, this.target)) {\n          throw new TypeError(\"cannot report existing non-configurable own \" + \"property '\" + name + \"' as a non-existent \" + \"property\");\n        }\n        if (!Object.isExtensible(this.target) && isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n      }\n\n      // if res === true, we don't need to check for extensibility\n      // even for a non-extensible proxy that has no own name property,\n      // the property may have been inherited\n\n      return res;\n    },\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check its return value against the previously asserted value of the\n     * fixed property.\n     */\n    get: function (receiver, name) {\n      // experimental support for invoke() trap on platforms that\n      // support __noSuchMethod__\n      /*\n      if (name === '__noSuchMethod__') {\n        var handler = this;\n        return function(name, args) {\n          return handler.invoke(receiver, name, args);\n        }\n      }\n      */\n\n      var trap = this.getTrap(\"get\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.get(this.target, name, receiver);\n      }\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, receiver);\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      // check consistency of the returned value\n      if (fixedDesc !== undefined) {\n        // getting an existing property\n        if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n          // own frozen data property\n          if (!sameValue(res, fixedDesc.value)) {\n            throw new TypeError(\"cannot report inconsistent value for \" + \"non-writable, non-configurable property '\" + name + \"'\");\n          }\n        } else {\n          // it's an accessor property\n          if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.get === undefined) {\n            if (res !== undefined) {\n              throw new TypeError(\"must report undefined for non-configurable \" + \"accessor property '\" + name + \"' without getter\");\n            }\n          }\n        }\n      }\n      return res;\n    },\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check that the trap rejects the assignment.\n     */\n    set: function (receiver, name, val) {\n      var trap = this.getTrap(\"set\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.set(this.target, name, val, receiver);\n      }\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, val, receiver);\n      res = !!res; // coerce to Boolean\n\n      // if success is reported, check whether property is truly assignable\n      if (res === true) {\n        var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        if (fixedDesc !== undefined) {\n          // setting an existing property\n          if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n            if (!sameValue(val, fixedDesc.value)) {\n              throw new TypeError(\"cannot successfully assign to a \" + \"non-writable, non-configurable property '\" + name + \"'\");\n            }\n          } else {\n            if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false &&\n            // non-configurable\n            fixedDesc.set === undefined) {\n              // accessor with undefined setter\n              throw new TypeError(\"setting a property '\" + name + \"' that has \" + \" only a getter\");\n            }\n          }\n        }\n      }\n      return res;\n    },\n    /**\n     * Any own enumerable non-configurable properties of the target that are not\n     * included in the trap result give rise to a TypeError. As such, we check\n     * whether the returned result contains at least all sealed enumerable properties\n     * of the target object.\n     *\n     * The trap should return an iterator.\n     *\n     * However, as implementations of pre-direct proxies still expect enumerate\n     * to return an array of strings, we convert the iterator into an array.\n     */\n    enumerate: function () {\n      var trap = this.getTrap(\"enumerate\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        var trapResult = Reflect.enumerate(this.target);\n        var result = [];\n        var nxt = trapResult.next();\n        while (!nxt.done) {\n          result.push(String(nxt.value));\n          nxt = trapResult.next();\n        }\n        return result;\n      }\n      var trapResult = trap.call(this.handler, this.target);\n      if (trapResult === null || trapResult === undefined || trapResult.next === undefined) {\n        throw new TypeError(\"enumerate trap should return an iterator, got: \" + trapResult);\n      }\n\n      // propNames is used as a set of strings\n      var propNames = Object.create(null);\n\n      // var numProps = +trapResult.length;\n      var result = []; // new Array(numProps);\n\n      // trapResult is supposed to be an iterator\n      // drain iterator to array as current implementations still expect\n      // enumerate to return an array of strings\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        var s = String(nxt.value);\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \" + \"duplicate property '\" + s + \"'\");\n        }\n        propNames[s] = true;\n        result.push(s);\n        nxt = trapResult.next();\n      }\n\n      /*for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \"+\n                              \"duplicate property '\"+s+\"'\");\n        }\n         propNames[s] = true;\n        result[i] = s;\n      } */\n\n      var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"enumerate trap failed to include \" + \"non-configurable enumerable property '\" + ownEnumerableProp + \"'\");\n          }\n          if (!Object.isExtensible(target) && isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\" + ownEnumerableProp + \"' as non-existent on a \" + \"non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n    /**\n     * The iterate trap is deprecated by the enumerate trap.\n     */\n    iterate: Validator.prototype.enumerate,\n    /**\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * The trap result is normalized.\n     * The trap result is not returned directly. Instead:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to String,\n     *  - which does not contain duplicates\n     *\n     * FIXME: keys trap is deprecated\n     */\n    /*\n    keys: function() {\n      var trap = this.getTrap(\"keys\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.keys(this.target);\n      }\n       var trapResult = trap.call(this.handler, this.target);\n       // propNames is used as a set of strings\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n       for (var i = 0; i < numProps; i++) {\n       var s = String(trapResult[i]);\n       if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n                             \"duplicate property '\"+s+\"'\");\n       }\n       if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n                             \"property '\"+s+\"' on a non-extensible object\");\n       }\n        propNames[s] = true;\n       result[i] = s;\n      }\n       var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"keys trap failed to include \"+\n                                \"non-configurable enumerable property '\"+\n                                ownEnumerableProp+\"'\");\n          }\n          if (!Object.isExtensible(target) &&\n              isFixed(ownEnumerableProp, target)) {\n              // if handler is allowed not to report ownEnumerableProp as an own\n              // property, we cannot guarantee that it will never report it as\n              // an own property later. Once a property has been reported as\n              // non-existent on a non-extensible object, it should forever be\n              // reported as non-existent\n              throw new TypeError(\"cannot report existing own property '\"+\n                                  ownEnumerableProp+\"' as non-existent on a \"+\n                                  \"non-extensible object\");\n          }\n        }\n      });\n       return result;\n    },\n    */\n\n    /**\n     * New trap that reifies [[Call]].\n     * If the target is a function, then a call to\n     *   proxy(...args)\n     * Triggers this trap\n     */\n    apply: function (target, thisBinding, args) {\n      var trap = this.getTrap(\"apply\");\n      if (trap === undefined) {\n        return Reflect.apply(target, thisBinding, args);\n      }\n      if (typeof this.target === \"function\") {\n        return trap.call(this.handler, target, thisBinding, args);\n      } else {\n        throw new TypeError(\"apply: \" + target + \" is not a function\");\n      }\n    },\n    /**\n     * New trap that reifies [[Construct]].\n     * If the target is a function, then a call to\n     *   new proxy(...args)\n     * Triggers this trap\n     */\n    construct: function (target, args, newTarget) {\n      var trap = this.getTrap(\"construct\");\n      if (trap === undefined) {\n        return Reflect.construct(target, args, newTarget);\n      }\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"new: \" + target + \" is not a function\");\n      }\n      if (newTarget === undefined) {\n        newTarget = target;\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"new: \" + newTarget + \" is not a function\");\n        }\n      }\n      return trap.call(this.handler, target, args, newTarget);\n    }\n  };\n\n  // ---- end of the Validator handler wrapper handler ----\n\n  // In what follows, a 'direct proxy' is a proxy\n  // whose handler is a Validator. Such proxies can be made non-extensible,\n  // sealed or frozen without losing the ability to trap.\n\n  // maps direct proxies to their Validator handlers\n  var directProxies = new WeakMap();\n\n  // patch Object.{preventExtensions,seal,freeze} so that\n  // they recognize fixable proxies and act accordingly\n  Object.preventExtensions = function (subject) {\n    var vhandler = directProxies.get(subject);\n    if (vhandler !== undefined) {\n      if (vhandler.preventExtensions()) {\n        return subject;\n      } else {\n        throw new TypeError(\"preventExtensions on \" + subject + \" rejected\");\n      }\n    } else {\n      return prim_preventExtensions(subject);\n    }\n  };\n  Object.seal = function (subject) {\n    setIntegrityLevel(subject, \"sealed\");\n    return subject;\n  };\n  Object.freeze = function (subject) {\n    setIntegrityLevel(subject, \"frozen\");\n    return subject;\n  };\n  Object.isExtensible = Object_isExtensible = function (subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      return vHandler.isExtensible();\n    } else {\n      return prim_isExtensible(subject);\n    }\n  };\n  Object.isSealed = Object_isSealed = function (subject) {\n    return testIntegrityLevel(subject, \"sealed\");\n  };\n  Object.isFrozen = Object_isFrozen = function (subject) {\n    return testIntegrityLevel(subject, \"frozen\");\n  };\n  Object.getPrototypeOf = Object_getPrototypeOf = function (subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      return vHandler.getPrototypeOf();\n    } else {\n      return prim_getPrototypeOf(subject);\n    }\n  };\n\n  // patch Object.getOwnPropertyDescriptor to directly call\n  // the Validator.prototype.getOwnPropertyDescriptor trap\n  // This is to circumvent an assertion in the built-in Proxy\n  // trapping mechanism of v8, which disallows that trap to\n  // return non-configurable property descriptors (as per the\n  // old Proxy design)\n  Object.getOwnPropertyDescriptor = function (subject, name) {\n    var vhandler = directProxies.get(subject);\n    if (vhandler !== undefined) {\n      return vhandler.getOwnPropertyDescriptor(name);\n    } else {\n      return prim_getOwnPropertyDescriptor(subject, name);\n    }\n  };\n\n  // patch Object.defineProperty to directly call\n  // the Validator.prototype.defineProperty trap\n  // This is to circumvent two issues with the built-in\n  // trap mechanism:\n  // 1) the current tracemonkey implementation of proxies\n  // auto-completes 'desc', which is not correct. 'desc' should be\n  // normalized, but not completed. Consider:\n  // Object.defineProperty(proxy, 'foo', {enumerable:false})\n  // This trap will receive desc =\n  //  {value:undefined,writable:false,enumerable:false,configurable:false}\n  // This will also set all other attributes to their default value,\n  // which is unexpected and different from [[DefineOwnProperty]].\n  // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n  // 2) the current spidermonkey implementation does not\n  // throw an exception when this trap returns 'false', but instead silently\n  // ignores the operation (this is regardless of strict-mode)\n  // 2a) v8 does throw an exception for this case, but includes the rather\n  //     unhelpful error message:\n  // 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n  Object.defineProperty = function (subject, name, desc) {\n    var vhandler = directProxies.get(subject);\n    if (vhandler !== undefined) {\n      var normalizedDesc = normalizePropertyDescriptor(desc);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\" + name + \"'\");\n      }\n      return subject;\n    } else {\n      return prim_defineProperty(subject, name, desc);\n    }\n  };\n  Object.defineProperties = function (subject, descs) {\n    var vhandler = directProxies.get(subject);\n    if (vhandler !== undefined) {\n      var names = Object.keys(descs);\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n        var success = vhandler.defineProperty(name, normalizedDesc);\n        if (success === false) {\n          throw new TypeError(\"can't redefine property '\" + name + \"'\");\n        }\n      }\n      return subject;\n    } else {\n      return prim_defineProperties(subject, descs);\n    }\n  };\n  Object.keys = function (subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      var ownKeys = vHandler.ownKeys();\n      var result = [];\n      for (var i = 0; i < ownKeys.length; i++) {\n        var k = String(ownKeys[i]);\n        var desc = Object.getOwnPropertyDescriptor(subject, k);\n        if (desc !== undefined && desc.enumerable === true) {\n          result.push(k);\n        }\n      }\n      return result;\n    } else {\n      return prim_keys(subject);\n    }\n  };\n  Object.getOwnPropertyNames = Object_getOwnPropertyNames = function (subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      return vHandler.ownKeys();\n    } else {\n      return prim_getOwnPropertyNames(subject);\n    }\n  };\n\n  // fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n  // throws an error)\n  if (prim_getOwnPropertySymbols !== undefined) {\n    Object.getOwnPropertySymbols = function (subject) {\n      var vHandler = directProxies.get(subject);\n      if (vHandler !== undefined) {\n        // as this shim does not support symbols, a Proxy never advertises\n        // any symbol-valued own properties\n        return [];\n      } else {\n        return prim_getOwnPropertySymbols(subject);\n      }\n    };\n  }\n\n  // fixes issue #72 ('Illegal access' error when using Object.assign)\n  // Object.assign polyfill based on a polyfill posted on MDN: \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n  //  Global_Objects/Object/assign\n  // Note that this polyfill does not support Symbols, but this Proxy Shim\n  // does not support Symbols anyway.\n  if (prim_assign !== undefined) {\n    Object.assign = function (target) {\n      // check if any argument is a proxy object\n      var noProxies = true;\n      for (var i = 0; i < arguments.length; i++) {\n        var vHandler = directProxies.get(arguments[i]);\n        if (vHandler !== undefined) {\n          noProxies = false;\n          break;\n        }\n      }\n      if (noProxies) {\n        // not a single argument is a proxy, perform built-in algorithm\n        return prim_assign.apply(Object, arguments);\n      }\n\n      // there is at least one proxy argument, use the polyfill\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n      var output = Object(target);\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  }\n\n  // returns whether an argument is a reference to an object,\n  // which is legal as a WeakMap key.\n  function isObject(arg) {\n    var type = typeof arg;\n    return type === 'object' && arg !== null || type === 'function';\n  }\n  ;\n\n  // a wrapper for WeakMap.get which returns the undefined value\n  // for keys that are not objects (in which case the underlying\n  // WeakMap would have thrown a TypeError).\n  function safeWeakMapGet(map, key) {\n    return isObject(key) ? map.get(key) : undefined;\n  }\n  ;\n\n  // returns a new function of zero arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a zero-argument method\n  // that uses its |this|-binding.\n  function makeUnwrapping0ArgMethod(primitive) {\n    return function builtin() {\n      var vHandler = safeWeakMapGet(directProxies, this);\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target);\n      } else {\n        return primitive.call(this);\n      }\n    };\n  }\n  ;\n\n  // returns a new function of 1 arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a 1-argument method\n  // that uses its |this|-binding.\n  function makeUnwrapping1ArgMethod(primitive) {\n    return function builtin(arg) {\n      var vHandler = safeWeakMapGet(directProxies, this);\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target, arg);\n      } else {\n        return primitive.call(this, arg);\n      }\n    };\n  }\n  ;\n  Object.prototype.valueOf = makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n  Object.prototype.toString = makeUnwrapping0ArgMethod(Object.prototype.toString);\n  Function.prototype.toString = makeUnwrapping0ArgMethod(Function.prototype.toString);\n  Date.prototype.toString = makeUnwrapping0ArgMethod(Date.prototype.toString);\n  Object.prototype.isPrototypeOf = function builtin(arg) {\n    // bugfix thanks to Bill Mark:\n    // built-in isPrototypeOf does not unwrap proxies used\n    // as arguments. So, we implement the builtin ourselves,\n    // based on the ECMAScript 6 spec. Our encoding will\n    // make sure that if a proxy is used as an argument,\n    // its getPrototypeOf trap will be called.\n    while (true) {\n      var vHandler2 = safeWeakMapGet(directProxies, arg);\n      if (vHandler2 !== undefined) {\n        arg = vHandler2.getPrototypeOf();\n        if (arg === null) {\n          return false;\n        } else if (sameValue(arg, this)) {\n          return true;\n        }\n      } else {\n        return prim_isPrototypeOf.call(this, arg);\n      }\n    }\n  };\n  Array.isArray = function (subject) {\n    var vHandler = safeWeakMapGet(directProxies, subject);\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    } else {\n      return prim_isArray(subject);\n    }\n  };\n  function isProxyArray(arg) {\n    var vHandler = safeWeakMapGet(directProxies, arg);\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    }\n    return false;\n  }\n\n  // Array.prototype.concat internally tests whether one of its\n  // arguments is an Array, by checking whether [[Class]] == \"Array\"\n  // As such, it will fail to recognize proxies-for-arrays as arrays.\n  // We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n  // by making a copy. This will trigger the exact same sequence of\n  // traps on the proxy-for-array as if we would not have unwrapped it.\n  // See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n  Array.prototype.concat = function /*...args*/\n  () {\n    var length;\n    for (var i = 0; i < arguments.length; i++) {\n      if (isProxyArray(arguments[i])) {\n        length = arguments[i].length;\n        arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n      }\n    }\n    return prim_concat.apply(this, arguments);\n  };\n\n  // setPrototypeOf support on platforms that support __proto__\n\n  var prim_setPrototypeOf = Object.setPrototypeOf;\n\n  // patch and extract original __proto__ setter\n  var __proto__setter = function () {\n    var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype, '__proto__');\n    if (protoDesc === undefined || typeof protoDesc.set !== \"function\") {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    }\n\n    // see if we can actually mutate a prototype with the generic setter\n    // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n    try {\n      protoDesc.set.call({}, {});\n    } catch (e) {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    }\n    prim_defineProperty(Object.prototype, '__proto__', {\n      set: function (newProto) {\n        return Object.setPrototypeOf(this, Object(newProto));\n      }\n    });\n    return protoDesc.set;\n  }();\n  Object.setPrototypeOf = function (target, newProto) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      if (handler.setPrototypeOf(newProto)) {\n        return target;\n      } else {\n        throw new TypeError(\"proxy rejected prototype mutation\");\n      }\n    } else {\n      if (!Object_isExtensible(target)) {\n        throw new TypeError(\"can't set prototype on non-extensible object: \" + target);\n      }\n      if (prim_setPrototypeOf) return prim_setPrototypeOf(target, newProto);\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n        // throw new TypeError(\"prototype must be an object or null\")\n      }\n\n      __proto__setter.call(target, newProto);\n      return target;\n    }\n  };\n  Object.prototype.hasOwnProperty = function (name) {\n    var handler = safeWeakMapGet(directProxies, this);\n    if (handler !== undefined) {\n      var desc = handler.getOwnPropertyDescriptor(name);\n      return desc !== undefined;\n    } else {\n      return prim_hasOwnProperty.call(this, name);\n    }\n  };\n\n  // ============= Reflection module =============\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n  var Reflect = {\n    getOwnPropertyDescriptor: function (target, name) {\n      return Object.getOwnPropertyDescriptor(target, name);\n    },\n    defineProperty: function (target, name, desc) {\n      // if target is a proxy, invoke its \"defineProperty\" trap\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.defineProperty(target, name, desc);\n      }\n\n      // Implementation transliterated from [[DefineOwnProperty]]\n      // see ES5.1 section 8.12.9\n      // this is the _exact same algorithm_ as the isCompatibleDescriptor\n      // algorithm defined above, except that at every place it\n      // returns true, this algorithm actually does define the property.\n      var current = Object.getOwnPropertyDescriptor(target, name);\n      var extensible = Object.isExtensible(target);\n      if (current === undefined && extensible === false) {\n        return false;\n      }\n      if (current === undefined && extensible === true) {\n        Object.defineProperty(target, name, desc); // should never fail\n        return true;\n      }\n      if (isEmptyDescriptor(desc)) {\n        return true;\n      }\n      if (isEquivalentDescriptor(current, desc)) {\n        return true;\n      }\n      if (current.configurable === false) {\n        if (desc.configurable === true) {\n          return false;\n        }\n        if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n          return false;\n        }\n      }\n      if (isGenericDescriptor(desc)) {\n        // no further validation necessary\n      } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          return false;\n        }\n      } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          if (current.writable === false && desc.writable === true) {\n            return false;\n          }\n          if (current.writable === false) {\n            if ('value' in desc && !sameValue(desc.value, current.value)) {\n              return false;\n            }\n          }\n        }\n      } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n        if (current.configurable === false) {\n          if ('set' in desc && !sameValue(desc.set, current.set)) {\n            return false;\n          }\n          if ('get' in desc && !sameValue(desc.get, current.get)) {\n            return false;\n          }\n        }\n      }\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    },\n    deleteProperty: function (target, name) {\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.delete(name);\n      }\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n      if (desc === undefined) {\n        return true;\n      }\n      if (desc.configurable === true) {\n        delete target[name];\n        return true;\n      }\n      return false;\n    },\n    getPrototypeOf: function (target) {\n      return Object.getPrototypeOf(target);\n    },\n    setPrototypeOf: function (target, newProto) {\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.setPrototypeOf(newProto);\n      }\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n      }\n      if (!Object_isExtensible(target)) {\n        return false;\n      }\n      var current = Object.getPrototypeOf(target);\n      if (sameValue(current, newProto)) {\n        return true;\n      }\n      if (prim_setPrototypeOf) {\n        try {\n          prim_setPrototypeOf(target, newProto);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      __proto__setter.call(target, newProto);\n      return true;\n    },\n    preventExtensions: function (target) {\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.preventExtensions();\n      }\n      prim_preventExtensions(target);\n      return true;\n    },\n    isExtensible: function (target) {\n      return Object.isExtensible(target);\n    },\n    has: function (target, name) {\n      return name in target;\n    },\n    get: function (target, name, receiver) {\n      receiver = receiver || target;\n\n      // if target is a proxy, invoke its \"get\" trap\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.get(receiver, name);\n      }\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n      if (desc === undefined) {\n        var proto = Object.getPrototypeOf(target);\n        if (proto === null) {\n          return undefined;\n        }\n        return Reflect.get(proto, name, receiver);\n      }\n      if (isDataDescriptor(desc)) {\n        return desc.value;\n      }\n      var getter = desc.get;\n      if (getter === undefined) {\n        return undefined;\n      }\n      return desc.get.call(receiver);\n    },\n    // Reflect.set implementation based on latest version of [[SetP]] at\n    // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n    set: function (target, name, value, receiver) {\n      receiver = receiver || target;\n\n      // if target is a proxy, invoke its \"set\" trap\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.set(receiver, name, value);\n      }\n\n      // first, check whether target has a non-writable property\n      // shadowing name on receiver\n      var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n      if (ownDesc === undefined) {\n        // name is not defined in target, search target's prototype\n        var proto = Object.getPrototypeOf(target);\n        if (proto !== null) {\n          // continue the search in target's prototype\n          return Reflect.set(proto, name, value, receiver);\n        }\n\n        // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n        // target was the last prototype, now we know that 'name' is not shadowed\n        // by an existing (accessor or data) property, so we can add the property\n        // to the initial receiver object\n        // (this branch will intentionally fall through to the code below)\n        ownDesc = {\n          value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      }\n\n      // we now know that ownDesc !== undefined\n      if (isAccessorDescriptor(ownDesc)) {\n        var setter = ownDesc.set;\n        if (setter === undefined) return false;\n        setter.call(receiver, value); // assumes Function.prototype.call\n        return true;\n      }\n      // otherwise, isDataDescriptor(ownDesc) must be true\n      if (ownDesc.writable === false) return false;\n      // we found an existing writable data property on the prototype chain.\n      // Now update or add the data property on the receiver, depending on\n      // whether the receiver already defines the property or not.\n      var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n      if (existingDesc !== undefined) {\n        var updateDesc = {\n          value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable: existingDesc.writable,\n          enumerable: existingDesc.enumerable,\n          configurable: existingDesc.configurable\n        };\n        Object.defineProperty(receiver, name, updateDesc);\n        return true;\n      } else {\n        if (!Object.isExtensible(receiver)) return false;\n        var newDesc = {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n        Object.defineProperty(receiver, name, newDesc);\n        return true;\n      }\n    },\n    /*invoke: function(target, name, args, receiver) {\n      receiver = receiver || target;\n       var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.invoke(receiver, name, args);\n      }\n       var fun = Reflect.get(target, name, receiver);\n      return Function.prototype.apply.call(fun, receiver, args);\n    },*/\n    enumerate: function (target) {\n      var handler = directProxies.get(target);\n      var result;\n      if (handler !== undefined) {\n        // handler.enumerate should return an iterator directly, but the\n        // iterator gets converted to an array for backward-compat reasons,\n        // so we must re-iterate over the array\n        result = handler.enumerate(handler.target);\n      } else {\n        result = [];\n        for (var name in target) {\n          result.push(name);\n        }\n        ;\n      }\n      var l = +result.length;\n      var idx = 0;\n      return {\n        next: function () {\n          if (idx === l) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: result[idx++]\n          };\n        }\n      };\n    },\n    // imperfect ownKeys implementation: in ES6, should also include\n    // symbol-keyed properties.\n    ownKeys: function (target) {\n      return Object_getOwnPropertyNames(target);\n    },\n    apply: function (target, receiver, args) {\n      // target.apply(receiver, args)\n      return Function.prototype.apply.call(target, receiver, args);\n    },\n    construct: function (target, args, newTarget) {\n      // return new target(...args);\n\n      // if target is a proxy, invoke its \"construct\" trap\n      var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.construct(handler.target, args, newTarget);\n      }\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"target is not a function: \" + target);\n      }\n      if (newTarget === undefined || newTarget === target) {\n        // If newTarget is undefined, then newTarget is set to `target` and\n        // `Reflect.construct(target, ...args)` becomes equivalent to\n        // `new target(...args)`\n        // if `target` is an ES2015 Class constructor, it must be called using\n        // the `new` operator. Hence we use the new operator on a bound function\n        // to trigger the [[Construct]] internal method. This technique will work \n        // for both plain constructor functions and ES2015 classes\n        return new (Function.prototype.bind.apply(target, [null].concat(args)))();\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"newTarget is not a function: \" + target);\n        }\n        // if newTarget is a *different* constructor function, we need to\n        // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n        // new instance inheriting from newTarget.prototype\n        // Unfortunately this won't work if target is an ES2015 Constructor\n        // function, whose [[Call]] method throws an error (it must be invoked\n        // using the `new` operator)\n        var proto = newTarget.prototype;\n        var instance = Object(proto) === proto ? Object.create(proto) : {};\n        var result = Function.prototype.apply.call(target, instance, args);\n        return Object(result) === result ? result : instance;\n      }\n    }\n  };\n\n  // feature-test whether the Reflect global exists\n  if (global.Reflect !== undefined) {\n    // Reflect exists, add/override the shimmed methods\n    Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n      global.Reflect[key] = Reflect[key];\n    });\n  } else {\n    // Reflect doesn't exist, define it as the shimmed Reflect object\n    global.Reflect = Reflect;\n  }\n\n  // feature-test whether the Proxy global exists, with\n  // the harmony-era Proxy.create API\n  if (typeof Proxy !== \"undefined\" && typeof Proxy.create !== \"undefined\") {\n    var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n    var revokedHandler = primCreate({\n      get: function () {\n        throw new TypeError(\"proxy is revoked\");\n      }\n    });\n    global.Proxy = function (target, handler) {\n      // check that target is an Object\n      if (Object(target) !== target) {\n        throw new TypeError(\"Proxy target must be an Object, given \" + target);\n      }\n      // check that handler is an Object\n      if (Object(handler) !== handler) {\n        throw new TypeError(\"Proxy handler must be an Object, given \" + handler);\n      }\n      var vHandler = new Validator(target, handler);\n      var proxy;\n      if (typeof target === \"function\") {\n        proxy = primCreateFunction(vHandler,\n        // call trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n      } else {\n        proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n      }\n      directProxies.set(proxy, vHandler);\n      return proxy;\n    };\n    global.Proxy.revocable = function (target, handler) {\n      var proxy = new Proxy(target, handler);\n      var revoke = function () {\n        var vHandler = directProxies.get(proxy);\n        if (vHandler !== null) {\n          vHandler.target = null;\n          vHandler.handler = revokedHandler;\n        }\n        return undefined;\n      };\n      return {\n        proxy: proxy,\n        revoke: revoke\n      };\n    };\n\n    // add the old Proxy.create and Proxy.createFunction methods\n    // so old code that still depends on the harmony-era Proxy object\n    // is not broken. Also ensures that multiple versions of this\n    // library should load fine\n    global.Proxy.create = primCreate;\n    global.Proxy.createFunction = primCreateFunction;\n  } else {\n    // Proxy global not defined, or old API not available\n    if (typeof Proxy === \"undefined\") {\n      // Proxy global not defined, add a Proxy function stub\n      global.Proxy = function (_target, _handler) {\n        throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n      };\n    }\n    // Proxy global defined but old API not available\n    // presumably Proxy global already supports new API, leave untouched\n  }\n\n  // for node.js modules, export every property in the Reflect object\n  // as part of the module interface\n  if (typeof exports !== 'undefined') {\n    Object.keys(Reflect).forEach(function (key) {\n      exports[key] = Reflect[key];\n    });\n  }\n\n  // function-as-module pattern\n})(typeof exports !== 'undefined' ? global : this);","map":{"version":3,"names":["global","WeakMap","prototype","get","k","undefined","set","v","Error","isStandardAttribute","name","test","toPropertyDescriptor","obj","Object","TypeError","desc","enumerable","configurable","value","writable","getter","setter","isAccessorDescriptor","isDataDescriptor","isGenericDescriptor","toCompletePropertyDescriptor","internalDesc","isEmptyDescriptor","isEquivalentDescriptor","desc1","desc2","sameValue","x","y","normalizeAndCompletePropertyDescriptor","attributes","defineProperty","normalizePropertyDescriptor","prim_preventExtensions","preventExtensions","prim_seal","seal","prim_freeze","freeze","prim_isExtensible","isExtensible","prim_isSealed","isSealed","prim_isFrozen","isFrozen","prim_getPrototypeOf","getPrototypeOf","prim_getOwnPropertyDescriptor","getOwnPropertyDescriptor","prim_defineProperty","prim_defineProperties","defineProperties","prim_keys","keys","prim_getOwnPropertyNames","getOwnPropertyNames","prim_getOwnPropertySymbols","getOwnPropertySymbols","prim_assign","assign","prim_isArray","Array","isArray","prim_concat","concat","prim_isPrototypeOf","isPrototypeOf","prim_hasOwnProperty","hasOwnProperty","Object_isFrozen","Object_isSealed","Object_isExtensible","Object_getPrototypeOf","Object_getOwnPropertyNames","isFixed","target","call","isSealedDesc","isCompatibleDescriptor","extensible","current","setIntegrityLevel","level","ownProps","pendingException","l","length","i","String","e","currentDesc","Reflect","testIntegrityLevel","Validator","handler","getTrap","trapName","trap","targetDesc","getPropertyDescriptor","has","val","descObj","success","delete","deleteProperty","res","ownKeys","trapResult","propNames","create","numProps","result","s","forEach","ownProp","state","allegedProto","actualProto","setPrototypeOf","newProto","getPropertyNames","receiver","fixedDesc","enumerate","nxt","next","done","push","ownEnumerableProps","ownEnumerableProp","iterate","apply","thisBinding","args","construct","newTarget","directProxies","subject","vhandler","vHandler","normalizedDesc","descs","names","noProxies","arguments","output","index","source","nextKey","isObject","arg","type","safeWeakMapGet","map","key","makeUnwrapping0ArgMethod","primitive","builtin","makeUnwrapping1ArgMethod","valueOf","toString","Function","Date","vHandler2","isProxyArray","slice","prim_setPrototypeOf","__proto__setter","protoDesc","proto","ownDesc","existingDesc","updateDesc","newDesc","idx","bind","instance","Proxy","primCreate","primCreateFunction","createFunction","revokedHandler","proxy","revocable","revoke","_target","_handler","exports"],"sources":["/Users/serteriyigunlu/Desktop/travel-log-app/node_modules/harmony-reflect/reflect.js"],"sourcesContent":["// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n\n // ----------------------------------------------------------------------------\n\n // This file is a polyfill for the upcoming ECMAScript Reflect API,\n // including support for Proxies. See the draft specification at:\n // http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n // For an implementation of the Handler API, see handlers.js, which implements:\n // http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n\n // This implementation supersedes the earlier polyfill at:\n // code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n\n // This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n // The code also works correctly on\n //   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n\n // Language Dependencies:\n //  - ECMAScript 5/strict\n //  - \"old\" (i.e. non-direct) Harmony Proxies\n //  - Harmony WeakMaps\n // Patches:\n //  - Object.{freeze,seal,preventExtensions}\n //  - Object.{isFrozen,isSealed,isExtensible}\n //  - Object.getPrototypeOf\n //  - Object.keys\n //  - Object.prototype.valueOf\n //  - Object.prototype.isPrototypeOf\n //  - Object.prototype.toString\n //  - Object.prototype.hasOwnProperty\n //  - Object.getOwnPropertyDescriptor\n //  - Object.defineProperty\n //  - Object.defineProperties\n //  - Object.getOwnPropertyNames\n //  - Object.getOwnPropertySymbols\n //  - Object.getPrototypeOf\n //  - Object.setPrototypeOf\n //  - Object.assign\n //  - Function.prototype.toString\n //  - Date.prototype.toString\n //  - Array.isArray\n //  - Array.prototype.concat\n //  - Proxy\n // Adds new globals:\n //  - Reflect\n\n // Direct proxies can be created via Proxy(target, handler)\n\n // ----------------------------------------------------------------------------\n\n(function(global){ // function-as-module pattern\n\"use strict\";\n\n// === Direct Proxies: Invariant Enforcement ===\n\n// Direct proxies build on non-direct proxies by automatically wrapping\n// all user-defined proxy handlers in a Validator handler that checks and\n// enforces ES5 invariants.\n\n// A direct proxy is a proxy for an existing object called the target object.\n\n// A Validator handler is a wrapper for a target proxy handler H.\n// The Validator forwards all operations to H, but additionally\n// performs a number of integrity checks on the results of some traps,\n// to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n// properties and non-extensible, sealed or frozen objects.\n\n// For each property that H exposes as own, non-configurable\n// (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n// the Validator handler defines those properties on the target object.\n// When the proxy becomes non-extensible, also configurable own properties\n// are checked against the target.\n// We will call properties that are defined on the target object\n// \"fixed properties\".\n\n// We will name fixed non-configurable properties \"sealed properties\".\n// We will name fixed non-configurable non-writable properties \"frozen\n// properties\".\n\n// The Validator handler upholds the following invariants w.r.t. non-configurability:\n// - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n// - getOwnPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property (e.g. reporting a non-configurable\n//   property as configurable, or reporting a non-configurable, non-writable\n//   property as writable)\n// - getPropertyDescriptor cannot report sealed properties as non-existent\n// - getPropertyDescriptor cannot report incompatible changes to the\n//   attributes of a sealed property. It _can_ report incompatible changes\n//   to the attributes of non-own, inherited properties.\n// - defineProperty cannot make incompatible changes to the attributes of\n//   sealed properties\n// - deleteProperty cannot report a successful deletion of a sealed property\n// - hasOwn cannot report a sealed property as non-existent\n// - has cannot report a sealed property as non-existent\n// - get cannot report inconsistent values for frozen data\n//   properties, and must report undefined for sealed accessors with an\n//   undefined getter\n// - set cannot report a successful assignment for frozen data\n//   properties or sealed accessors with an undefined setter.\n// - get{Own}PropertyNames lists all sealed properties of the target.\n// - keys lists all enumerable sealed properties of the target.\n// - enumerate lists all enumerable sealed properties of the target.\n// - if a property of a non-extensible proxy is reported as non-existent,\n//   then it must forever be reported as non-existent. This applies to\n//   own and inherited properties and is enforced in the\n//   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n//   get{Own}PropertyNames, keys and enumerate traps\n\n// Violation of any of these invariants by H will result in TypeError being\n// thrown.\n\n// Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n// is invoked on the proxy, the set of own property names for the proxy is\n// fixed. Any property name that is not fixed is called a 'new' property.\n\n// The Validator upholds the following invariants regarding extensibility:\n// - getOwnPropertyDescriptor cannot report new properties as existent\n//   (it must report them as non-existent by returning undefined)\n// - defineProperty cannot successfully add a new property (it must reject)\n// - getOwnPropertyNames cannot list new properties\n// - hasOwn cannot report true for new properties (it must report false)\n// - keys cannot list new properties\n\n// Invariants currently not enforced:\n// - getOwnPropertyNames lists only own property names\n// - keys lists only enumerable own property names\n// Both traps may list more property names than are actually defined on the\n// target.\n\n// Invariants with regard to inheritance are currently not enforced.\n// - a non-configurable potentially inherited property on a proxy with\n//   non-mutable ancestry cannot be reported as non-existent\n// (An object with non-mutable ancestry is a non-extensible object whose\n// [[Prototype]] is either null or an object with non-mutable ancestry.)\n\n// Changes in Handler API compared to previous harmony:proxies, see:\n// http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n\n// ----------------------------------------------------------------------------\n\n// ---- WeakMap polyfill ----\n\n// TODO: find a proper WeakMap polyfill\n\n// define an empty WeakMap so that at least the Reflect module code\n// will work in the absence of WeakMaps. Proxy emulation depends on\n// actual WeakMaps, so will not work with this little shim.\nif (typeof WeakMap === \"undefined\") {\n  global.WeakMap = function(){};\n  global.WeakMap.prototype = {\n    get: function(k) { return undefined; },\n    set: function(k,v) { throw new Error(\"WeakMap not supported\"); }\n  };\n}\n\n// ---- Normalization functions for property descriptors ----\n\nfunction isStandardAttribute(name) {\n  return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n}\n\n// Adapted from ES5 section 8.10.5\nfunction toPropertyDescriptor(obj) {\n  if (Object(obj) !== obj) {\n    throw new TypeError(\"property descriptor should be an Object, given: \"+\n                        obj);\n  }\n  var desc = {};\n  if ('enumerable' in obj) { desc.enumerable = !!obj.enumerable; }\n  if ('configurable' in obj) { desc.configurable = !!obj.configurable; }\n  if ('value' in obj) { desc.value = obj.value; }\n  if ('writable' in obj) { desc.writable = !!obj.writable; }\n  if ('get' in obj) {\n    var getter = obj.get;\n    if (getter !== undefined && typeof getter !== \"function\") {\n      throw new TypeError(\"property descriptor 'get' attribute must be \"+\n                          \"callable or undefined, given: \"+getter);\n    }\n    desc.get = getter;\n  }\n  if ('set' in obj) {\n    var setter = obj.set;\n    if (setter !== undefined && typeof setter !== \"function\") {\n      throw new TypeError(\"property descriptor 'set' attribute must be \"+\n                          \"callable or undefined, given: \"+setter);\n    }\n    desc.set = setter;\n  }\n  if ('get' in desc || 'set' in desc) {\n    if ('value' in desc || 'writable' in desc) {\n      throw new TypeError(\"property descriptor cannot be both a data and an \"+\n                          \"accessor descriptor: \"+obj);\n    }\n  }\n  return desc;\n}\n\nfunction isAccessorDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('get' in desc || 'set' in desc);\n}\nfunction isDataDescriptor(desc) {\n  if (desc === undefined) return false;\n  return ('value' in desc || 'writable' in desc);\n}\nfunction isGenericDescriptor(desc) {\n  if (desc === undefined) return false;\n  return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n}\n\nfunction toCompletePropertyDescriptor(desc) {\n  var internalDesc = toPropertyDescriptor(desc);\n  if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n    if (!('value' in internalDesc)) { internalDesc.value = undefined; }\n    if (!('writable' in internalDesc)) { internalDesc.writable = false; }\n  } else {\n    if (!('get' in internalDesc)) { internalDesc.get = undefined; }\n    if (!('set' in internalDesc)) { internalDesc.set = undefined; }\n  }\n  if (!('enumerable' in internalDesc)) { internalDesc.enumerable = false; }\n  if (!('configurable' in internalDesc)) { internalDesc.configurable = false; }\n  return internalDesc;\n}\n\nfunction isEmptyDescriptor(desc) {\n  return !('get' in desc) &&\n         !('set' in desc) &&\n         !('value' in desc) &&\n         !('writable' in desc) &&\n         !('enumerable' in desc) &&\n         !('configurable' in desc);\n}\n\nfunction isEquivalentDescriptor(desc1, desc2) {\n  return sameValue(desc1.get, desc2.get) &&\n         sameValue(desc1.set, desc2.set) &&\n         sameValue(desc1.value, desc2.value) &&\n         sameValue(desc1.writable, desc2.writable) &&\n         sameValue(desc1.enumerable, desc2.enumerable) &&\n         sameValue(desc1.configurable, desc2.configurable);\n}\n\n// copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\nfunction sameValue(x, y) {\n  if (x === y) {\n    // 0 === -0, but they are not identical\n    return x !== 0 || 1 / x === 1 / y;\n  }\n\n  // NaN !== NaN, but they are identical.\n  // NaNs are the only non-reflexive value, i.e., if x !== x,\n  // then x is a NaN.\n  // isNaN is broken: it converts its argument to number, so\n  // isNaN(\"foo\") => true\n  return x !== x && y !== y;\n}\n\n/**\n * Returns a fresh property descriptor that is guaranteed\n * to be complete (i.e. contain all the standard attributes).\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, returns undefined.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizeAndCompletePropertyDescriptor(attributes) {\n  if (attributes === undefined) { return undefined; }\n  var desc = toCompletePropertyDescriptor(attributes);\n  // Note: no need to call FromPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n/**\n * Returns a fresh property descriptor whose standard\n * attributes are guaranteed to be data properties of the right type.\n * Additionally, any non-standard enumerable properties of\n * attributes are copied over to the fresh descriptor.\n *\n * If attributes is undefined, will throw a TypeError.\n *\n * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n */\nfunction normalizePropertyDescriptor(attributes) {\n  var desc = toPropertyDescriptor(attributes);\n  // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n  // \"internal\" property descriptors as proper Objects from the start\n  for (var name in attributes) {\n    if (!isStandardAttribute(name)) {\n      Object.defineProperty(desc, name,\n        { value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true });\n    }\n  }\n  return desc;\n}\n\n// store a reference to the real ES5 primitives before patching them later\nvar prim_preventExtensions =        Object.preventExtensions,\n    prim_seal =                     Object.seal,\n    prim_freeze =                   Object.freeze,\n    prim_isExtensible =             Object.isExtensible,\n    prim_isSealed =                 Object.isSealed,\n    prim_isFrozen =                 Object.isFrozen,\n    prim_getPrototypeOf =           Object.getPrototypeOf,\n    prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    prim_defineProperty =           Object.defineProperty,\n    prim_defineProperties =         Object.defineProperties,\n    prim_keys =                     Object.keys,\n    prim_getOwnPropertyNames =      Object.getOwnPropertyNames,\n    prim_getOwnPropertySymbols =    Object.getOwnPropertySymbols,\n    prim_assign =                   Object.assign,\n    prim_isArray =                  Array.isArray,\n    prim_concat =                   Array.prototype.concat,\n    prim_isPrototypeOf =            Object.prototype.isPrototypeOf,\n    prim_hasOwnProperty =           Object.prototype.hasOwnProperty;\n\n// these will point to the patched versions of the respective methods on\n// Object. They are used within this module as the \"intrinsic\" bindings\n// of these methods (i.e. the \"original\" bindings as defined in the spec)\nvar Object_isFrozen,\n    Object_isSealed,\n    Object_isExtensible,\n    Object_getPrototypeOf,\n    Object_getOwnPropertyNames;\n\n/**\n * A property 'name' is fixed if it is an own property of the target.\n */\nfunction isFixed(name, target) {\n  return ({}).hasOwnProperty.call(target, name);\n}\nfunction isSealed(name, target) {\n  var desc = Object.getOwnPropertyDescriptor(target, name);\n  if (desc === undefined) { return false; }\n  return desc.configurable === false;\n}\nfunction isSealedDesc(desc) {\n  return desc !== undefined && desc.configurable === false;\n}\n\n/**\n * Performs all validation that Object.defineProperty performs,\n * without actually defining the property. Returns a boolean\n * indicating whether validation succeeded.\n *\n * Implementation transliterated from ES5.1 section 8.12.9\n */\nfunction isCompatibleDescriptor(extensible, current, desc) {\n  if (current === undefined && extensible === false) {\n    return false;\n  }\n  if (current === undefined && extensible === true) {\n    return true;\n  }\n  if (isEmptyDescriptor(desc)) {\n    return true;\n  }\n  if (isEquivalentDescriptor(current, desc)) {\n    return true;\n  }\n  if (current.configurable === false) {\n    if (desc.configurable === true) {\n      return false;\n    }\n    if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n      return false;\n    }\n  }\n  if (isGenericDescriptor(desc)) {\n    return true;\n  }\n  if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      return false;\n    }\n    return true;\n  }\n  if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n    if (current.configurable === false) {\n      if (current.writable === false && desc.writable === true) {\n        return false;\n      }\n      if (current.writable === false) {\n        if ('value' in desc && !sameValue(desc.value, current.value)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n    if (current.configurable === false) {\n      if ('set' in desc && !sameValue(desc.set, current.set)) {\n        return false;\n      }\n      if ('get' in desc && !sameValue(desc.get, current.get)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// ES6 7.3.11 SetIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction setIntegrityLevel(target, level) {\n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  if (level === \"sealed\") {\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        Object.defineProperty(target, k, { configurable: false });\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  } else {\n    // level === \"frozen\"\n    var l = +ownProps.length;\n    var k;\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n      try {\n        var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        if (currentDesc !== undefined) {\n          var desc;\n          if (isAccessorDescriptor(currentDesc)) {\n            desc = { configurable: false }\n          } else {\n            desc = { configurable: false, writable: false }\n          }\n          Object.defineProperty(target, k, desc);\n        }        \n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n        }\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  return Reflect.preventExtensions(target);\n}\n\n// ES6 7.3.12 TestIntegrityLevel\n// level is one of \"sealed\" or \"frozen\"\nfunction testIntegrityLevel(target, level) {\n  var isExtensible = Object_isExtensible(target);\n  if (isExtensible) return false;\n  \n  var ownProps = Object_getOwnPropertyNames(target);\n  var pendingException = undefined;\n  var configurable = false;\n  var writable = false;\n  \n  var l = +ownProps.length;\n  var k;\n  var currentDesc;\n  for (var i = 0; i < l; i++) {\n    k = String(ownProps[i]);\n    try {\n      currentDesc = Object.getOwnPropertyDescriptor(target, k);\n      configurable = configurable || currentDesc.configurable;\n      if (isDataDescriptor(currentDesc)) {\n        writable = writable || currentDesc.writable;\n      }\n    } catch (e) {\n      if (pendingException === undefined) {\n        pendingException = e;\n        configurable = true;\n      }\n    }\n  }\n  if (pendingException !== undefined) {\n    throw pendingException;\n  }\n  if (level === \"frozen\" && writable === true) {\n    return false;\n  }\n  if (configurable === true) {\n    return false;\n  }\n  return true;\n}\n\n// ---- The Validator handler wrapper around user handlers ----\n\n/**\n * @param target the object wrapped by this proxy.\n * As long as the proxy is extensible, only non-configurable properties\n * are checked against the target. Once the proxy becomes non-extensible,\n * invariants w.r.t. non-extensibility are also enforced.\n *\n * @param handler the handler of the direct proxy. The object emulated by\n * this handler is validated against the target object of the direct proxy.\n * Any violations that the handler makes against the invariants\n * of the target will cause a TypeError to be thrown.\n *\n * Both target and handler must be proper Objects at initialization time.\n */\nfunction Validator(target, handler) {\n  // for non-revokable proxies, these are const references\n  // for revokable proxies, on revocation:\n  // - this.target is set to null\n  // - this.handler is set to a handler that throws on all traps\n  this.target  = target;\n  this.handler = handler;\n}\n\nValidator.prototype = {\n\n  /**\n   * If getTrap returns undefined, the caller should perform the\n   * default forwarding behavior.\n   * If getTrap returns normally otherwise, the return value\n   * will be a callable trap function. When calling the trap function,\n   * the caller is responsible for binding its |this| to |this.handler|.\n   */\n  getTrap: function(trapName) {\n    var trap = this.handler[trapName];\n    if (trap === undefined) {\n      // the trap was not defined,\n      // perform the default forwarding behavior\n      return undefined;\n    }\n\n    if (typeof trap !== \"function\") {\n      throw new TypeError(trapName + \" trap is not callable: \"+trap);\n    }\n\n    return trap;\n  },\n\n  // === fundamental traps ===\n\n  /**\n   * If name denotes a fixed property, check:\n   *   - whether targetHandler reports it as existent\n   *   - whether the returned descriptor is compatible with the fixed property\n   * If the proxy is non-extensible, check:\n   *   - whether name is not a new property\n   * Additionally, the returned descriptor is normalized and completed.\n   */\n  getOwnPropertyDescriptor: function(name) {\n    \"use strict\";\n\n    var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n    if (trap === undefined) {\n      return Reflect.getOwnPropertyDescriptor(this.target, name);\n    }\n\n    name = String(name);\n    var desc = trap.call(this.handler, this.target, name);\n    desc = normalizeAndCompletePropertyDescriptor(desc);\n\n    var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    var extensible = Object.isExtensible(this.target);\n\n    if (desc === undefined) {\n      if (isSealedDesc(targetDesc)) {\n        throw new TypeError(\"cannot report non-configurable property '\"+name+\n                            \"' as non-existent\");\n      }\n      if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n      return undefined;\n    }\n\n    // at this point, we know (desc !== undefined), i.e.\n    // targetHandler reports 'name' as an existing property\n\n    // Note: we could collapse the following two if-tests into a single\n    // test. Separating out the cases to improve error reporting.\n\n    if (!extensible) {\n      if (targetDesc === undefined) {\n        throw new TypeError(\"cannot report a new own property '\"+\n                            name + \"' on a non-extensible object\");\n      }\n    }\n\n    if (name !== undefined) {\n      if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n        throw new TypeError(\"cannot report incompatible property descriptor \"+\n                            \"for property '\"+name+\"'\");\n      }\n    }\n    \n    if (desc.configurable === false) {\n      if (targetDesc === undefined || targetDesc.configurable === true) {\n        // if the property is configurable or non-existent on the target,\n        // but is reported as a non-configurable property, it may later be\n        // reported as configurable or non-existent, which violates the\n        // invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot report a non-configurable descriptor \" +\n          \"for configurable or non-existent property '\" + name + \"'\");\n      }\n      if ('writable' in desc && desc.writable === false) {\n        if (targetDesc.writable === true) {\n          // if the property is non-configurable, writable on the target,\n          // but is reported as non-configurable, non-writable, it may later\n          // be reported as non-configurable, writable again, which violates\n          // the invariant that a non-configurable, non-writable property\n          // may not change state.\n          throw new TypeError(\n            \"cannot report non-configurable, writable property '\" + name +\n            \"' as non-configurable, non-writable\");\n        }\n      }\n    }\n\n    return desc;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, instead\n   * of calling this trap, the get, set, has or enumerate traps are\n   * called instead.\n   *\n   * In this implementation, we \"abuse\" getPropertyDescriptor to\n   * support trapping the get or set traps for proxies-as-prototypes.\n   * We do this by returning a getter/setter pair that invokes\n   * the corresponding traps.\n   *\n   * While this hack works for inherited property access, it has some\n   * quirks:\n   *\n   * In Firefox, this trap is only called after a prior invocation\n   * of the 'has' trap has returned true. Hence, expect the following\n   * behavior:\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * child[name] // triggers handler.has(target, name)\n   * // if that returns true, triggers handler.get(target, name, child)\n   * </code>\n   *\n   * On v8, the 'in' operator, when applied to an object that inherits\n   * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n   * That calls the below getPropertyDescriptor trap on the proxy. The\n   * result of the 'in'-operator is then determined by whether this trap\n   * returns undefined or a property descriptor object. That is why\n   * we first explicitly trigger the 'has' trap to determine whether\n   * the property exists.\n   *\n   * This has the side-effect that when enumerating properties on\n   * an object that inherits from a proxy in v8, only properties\n   * for which 'has' returns true are returned:\n   *\n   * <code>\n   * var child = Object.create(Proxy(target, handler));\n   * for (var prop in child) {\n   *   // only enumerates prop if (prop in child) returns true\n   * }\n   * </code>\n   */\n  getPropertyDescriptor: function(name) {\n    var handler = this;\n\n    if (!handler.has(name)) return undefined;\n\n    return {\n      get: function() {\n        return handler.get(this, name);\n      },\n      set: function(val) {\n        if (handler.set(this, name, val)) {\n          return val;\n        } else {\n          throw new TypeError(\"failed assignment to \"+name);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    };\n  },\n\n  /**\n   * If name denotes a fixed property, check for incompatible changes.\n   * If the proxy is non-extensible, check that new properties are rejected.\n   */\n  defineProperty: function(name, desc) {\n    // TODO(tvcutsem): the current tracemonkey implementation of proxies\n    // auto-completes 'desc', which is not correct. 'desc' should be\n    // normalized, but not completed. Consider:\n    // Object.defineProperty(proxy, 'foo', {enumerable:false})\n    // This trap will receive desc =\n    //  {value:undefined,writable:false,enumerable:false,configurable:false}\n    // This will also set all other attributes to their default value,\n    // which is unexpected and different from [[DefineOwnProperty]].\n    // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n\n    var trap = this.getTrap(\"defineProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.defineProperty(this.target, name, desc);\n    }\n\n    name = String(name);\n    var descObj = normalizePropertyDescriptor(desc);\n    var success = trap.call(this.handler, this.target, name, descObj);\n    success = !!success; // coerce to Boolean\n\n    if (success === true) {\n\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot successfully add a new property '\"+\n                              name + \"' to a non-extensible object\");\n        }\n      }\n\n      if (targetDesc !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot define incompatible property \"+\n                              \"descriptor for property '\"+name+\"'\");\n        }\n        if (isDataDescriptor(targetDesc) &&\n            targetDesc.configurable === false &&\n            targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\n                \"cannot successfully define non-configurable, writable \" +\n                \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n      }\n\n      if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n        // if the property is configurable or non-existent on the target,\n        // but is successfully being redefined as a non-configurable property,\n        // it may later be reported as configurable or non-existent, which violates\n        // the invariant that if the property might change or disappear, the\n        // configurable attribute must be true.\n        throw new TypeError(\n          \"cannot successfully define a non-configurable \" +\n          \"descriptor for configurable or non-existent property '\" +\n          name + \"'\");\n      }\n\n    }\n\n    return success;\n  },\n\n  /**\n   * On success, check whether the target object is indeed non-extensible.\n   */\n  preventExtensions: function() {\n    var trap = this.getTrap(\"preventExtensions\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.preventExtensions(this.target);\n    }\n\n    var success = trap.call(this.handler, this.target);\n    success = !!success; // coerce to Boolean\n    if (success) {\n      if (Object_isExtensible(this.target)) {\n        throw new TypeError(\"can't report extensible object as non-extensible: \"+\n                            this.target);\n      }\n    }\n    return success;\n  },\n\n  /**\n   * If name denotes a sealed property, check whether handler rejects.\n   */\n  delete: function(name) {\n    \"use strict\";\n    var trap = this.getTrap(\"deleteProperty\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.deleteProperty(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    var targetDesc;\n    if (res === true) {\n      targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (targetDesc !== undefined && targetDesc.configurable === false) {\n        throw new TypeError(\"property '\" + name + \"' is non-configurable \"+\n                            \"and can't be deleted\");\n      }\n      if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n        // if the property still exists on a non-extensible target but\n        // is reported as successfully deleted, it may later be reported\n        // as present, which violates the invariant that an own property,\n        // deleted from a non-extensible object cannot reappear.\n        throw new TypeError(\n          \"cannot successfully delete existing property '\" + name +\n          \"' on a non-extensible object\");\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n   * which now also returns an array (of strings or symbols) and\n   * which performs the same rigorous invariant checks as getOwnPropertyNames\n   *\n   * See issue #48 on how this trap can still get invoked by external libs\n   * that don't use the patched Object.getOwnPropertyNames function.\n   */\n  getOwnPropertyNames: function() {\n    // Note: removed deprecation warning to avoid dependency on 'console'\n    // (and on node, should anyway use util.deprecate). Deprecation warnings\n    // can also be annoying when they are outside of the user's control, e.g.\n    // when an external library calls unpatched Object.getOwnPropertyNames.\n    // Since there is a clean fallback to `ownKeys`, the fact that the\n    // deprecated method is still called is mostly harmless anyway.\n    // See also issues #65 and #66.\n    // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n    return this.ownKeys();\n  },\n\n  /**\n   * Checks whether the trap result does not contain any new properties\n   * if the proxy is non-extensible.\n   *\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * Additionally, the trap result is normalized.\n   * Instead of returning the trap result directly:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to a String\n   *\n   * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n   * and Object.keys (the latter filters out only the enumerable own properties).\n   */\n  ownKeys: function() {\n    var trap = this.getTrap(\"ownKeys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.ownKeys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n        // non-extensible proxies don't tolerate new own property names\n        throw new TypeError(\"ownKeys trap cannot list a new \"+\n                            \"property '\"+s+\"' on a non-extensible object\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    }\n\n    var ownProps = Object_getOwnPropertyNames(this.target);\n    var target = this.target;\n    ownProps.forEach(function (ownProp) {\n      if (!propNames[ownProp]) {\n        if (isSealed(ownProp, target)) {\n          throw new TypeError(\"ownKeys trap failed to include \"+\n                              \"non-configurable property '\"+ownProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\"+\n                                ownProp+\"' as non-existent on a non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * Checks whether the trap result is consistent with the state of the\n   * wrapped target.\n   */\n  isExtensible: function() {\n    var trap = this.getTrap(\"isExtensible\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.isExtensible(this.target);\n    }\n\n    var result = trap.call(this.handler, this.target);\n    result = !!result; // coerce to Boolean\n    var state = Object_isExtensible(this.target);\n    if (result !== state) {\n      if (result) {\n        throw new TypeError(\"cannot report non-extensible object as extensible: \"+\n                             this.target);\n      } else {\n        throw new TypeError(\"cannot report extensible object as non-extensible: \"+\n                             this.target);\n      }\n    }\n    return state;\n  },\n\n  /**\n   * Check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  getPrototypeOf: function() {\n    var trap = this.getTrap(\"getPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.getPrototypeOf(this.target);\n    }\n\n    var allegedProto = trap.call(this.handler, this.target);\n\n    if (!Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(allegedProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return allegedProto;\n  },\n\n  /**\n   * If target is non-extensible and setPrototypeOf trap returns true,\n   * check whether the trap result corresponds to the target's [[Prototype]]\n   */\n  setPrototypeOf: function(newProto) {\n    var trap = this.getTrap(\"setPrototypeOf\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.setPrototypeOf(this.target, newProto);\n    }\n\n    var success = trap.call(this.handler, this.target, newProto);\n\n    success = !!success;\n    if (success && !Object_isExtensible(this.target)) {\n      var actualProto = Object_getPrototypeOf(this.target);\n      if (!sameValue(newProto, actualProto)) {\n        throw new TypeError(\"prototype value does not match: \" + this.target);\n      }\n    }\n\n    return success;\n  },\n\n  /**\n   * In the direct proxies design with refactored prototype climbing,\n   * this trap is deprecated. For proxies-as-prototypes, for-in will\n   * call the enumerate() trap. If that trap is not defined, the\n   * operation is forwarded to the target, no more fallback on this\n   * fundamental trap.\n   */\n  getPropertyNames: function() {\n    throw new TypeError(\"getPropertyNames trap is deprecated\");\n  },\n\n  // === derived traps ===\n\n  /**\n   * If name denotes a fixed property, check whether the trap returns true.\n   */\n  has: function(name) {\n    var trap = this.getTrap(\"has\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.has(this.target, name);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name);\n    res = !!res; // coerce to Boolean\n\n    if (res === false) {\n      if (isSealed(name, this.target)) {\n        throw new TypeError(\"cannot report existing non-configurable own \"+\n                            \"property '\"+ name + \"' as a non-existent \"+\n                            \"property\");\n      }\n      if (!Object.isExtensible(this.target) &&\n          isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\"+name+\n                              \"' as non-existent on a non-extensible object\");\n      }\n    }\n\n    // if res === true, we don't need to check for extensibility\n    // even for a non-extensible proxy that has no own name property,\n    // the property may have been inherited\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check its return value against the previously asserted value of the\n   * fixed property.\n   */\n  get: function(receiver, name) {\n\n    // experimental support for invoke() trap on platforms that\n    // support __noSuchMethod__\n    /*\n    if (name === '__noSuchMethod__') {\n      var handler = this;\n      return function(name, args) {\n        return handler.invoke(receiver, name, args);\n      }\n    }\n    */\n\n    var trap = this.getTrap(\"get\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.get(this.target, name, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, receiver);\n\n    var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n    // check consistency of the returned value\n    if (fixedDesc !== undefined) { // getting an existing property\n      if (isDataDescriptor(fixedDesc) &&\n          fixedDesc.configurable === false &&\n          fixedDesc.writable === false) { // own frozen data property\n        if (!sameValue(res, fixedDesc.value)) {\n          throw new TypeError(\"cannot report inconsistent value for \"+\n                              \"non-writable, non-configurable property '\"+\n                              name+\"'\");\n        }\n      } else { // it's an accessor property\n        if (isAccessorDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.get === undefined) {\n          if (res !== undefined) {\n            throw new TypeError(\"must report undefined for non-configurable \"+\n                                \"accessor property '\"+name+\"' without getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * If name denotes a fixed non-configurable, non-writable data property,\n   * check that the trap rejects the assignment.\n   */\n  set: function(receiver, name, val) {\n    var trap = this.getTrap(\"set\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.set(this.target, name, val, receiver);\n    }\n\n    name = String(name);\n    var res = trap.call(this.handler, this.target, name, val, receiver);\n    res = !!res; // coerce to Boolean\n\n    // if success is reported, check whether property is truly assignable\n    if (res === true) {\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      if (fixedDesc !== undefined) { // setting an existing property\n        if (isDataDescriptor(fixedDesc) &&\n            fixedDesc.configurable === false &&\n            fixedDesc.writable === false) {\n          if (!sameValue(val, fixedDesc.value)) {\n            throw new TypeError(\"cannot successfully assign to a \"+\n                                \"non-writable, non-configurable property '\"+\n                                name+\"'\");\n          }\n        } else {\n          if (isAccessorDescriptor(fixedDesc) &&\n              fixedDesc.configurable === false && // non-configurable\n              fixedDesc.set === undefined) {      // accessor with undefined setter\n            throw new TypeError(\"setting a property '\"+name+\"' that has \"+\n                                \" only a getter\");\n          }\n        }\n      }\n    }\n\n    return res;\n  },\n\n  /**\n   * Any own enumerable non-configurable properties of the target that are not\n   * included in the trap result give rise to a TypeError. As such, we check\n   * whether the returned result contains at least all sealed enumerable properties\n   * of the target object.\n   *\n   * The trap should return an iterator.\n   *\n   * However, as implementations of pre-direct proxies still expect enumerate\n   * to return an array of strings, we convert the iterator into an array.\n   */\n  enumerate: function() {\n    var trap = this.getTrap(\"enumerate\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      var trapResult = Reflect.enumerate(this.target);\n      var result = [];\n      var nxt = trapResult.next();\n      while (!nxt.done) {\n        result.push(String(nxt.value));\n        nxt = trapResult.next();\n      }\n      return result;\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n    \n    if (trapResult === null ||\n        trapResult === undefined ||\n        trapResult.next === undefined) {\n      throw new TypeError(\"enumerate trap should return an iterator, got: \"+\n                          trapResult);    \n    }\n    \n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    \n    // var numProps = +trapResult.length;\n    var result = []; // new Array(numProps);\n    \n    // trapResult is supposed to be an iterator\n    // drain iterator to array as current implementations still expect\n    // enumerate to return an array of strings\n    var nxt = trapResult.next();\n    \n    while (!nxt.done) {\n      var s = String(nxt.value);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n      propNames[s] = true;\n      result.push(s);\n      nxt = trapResult.next();\n    }\n    \n    /*for (var i = 0; i < numProps; i++) {\n      var s = String(trapResult[i]);\n      if (propNames[s]) {\n        throw new TypeError(\"enumerate trap cannot list a \"+\n                            \"duplicate property '\"+s+\"'\");\n      }\n\n      propNames[s] = true;\n      result[i] = s;\n    } */\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"enumerate trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n\n  /**\n   * The iterate trap is deprecated by the enumerate trap.\n   */\n  iterate: Validator.prototype.enumerate,\n\n  /**\n   * Any own non-configurable properties of the target that are not included\n   * in the trap result give rise to a TypeError. As such, we check whether the\n   * returned result contains at least all sealed properties of the target\n   * object.\n   *\n   * The trap result is normalized.\n   * The trap result is not returned directly. Instead:\n   *  - create and return a fresh Array,\n   *  - of which each element is coerced to String,\n   *  - which does not contain duplicates\n   *\n   * FIXME: keys trap is deprecated\n   */\n  /*\n  keys: function() {\n    var trap = this.getTrap(\"keys\");\n    if (trap === undefined) {\n      // default forwarding behavior\n      return Reflect.keys(this.target);\n    }\n\n    var trapResult = trap.call(this.handler, this.target);\n\n    // propNames is used as a set of strings\n    var propNames = Object.create(null);\n    var numProps = +trapResult.length;\n    var result = new Array(numProps);\n\n    for (var i = 0; i < numProps; i++) {\n     var s = String(trapResult[i]);\n     if (propNames[s]) {\n       throw new TypeError(\"keys trap cannot list a \"+\n                           \"duplicate property '\"+s+\"'\");\n     }\n     if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n       // non-extensible proxies don't tolerate new own property names\n       throw new TypeError(\"keys trap cannot list a new \"+\n                           \"property '\"+s+\"' on a non-extensible object\");\n     }\n\n     propNames[s] = true;\n     result[i] = s;\n    }\n\n    var ownEnumerableProps = Object.keys(this.target);\n    var target = this.target;\n    ownEnumerableProps.forEach(function (ownEnumerableProp) {\n      if (!propNames[ownEnumerableProp]) {\n        if (isSealed(ownEnumerableProp, target)) {\n          throw new TypeError(\"keys trap failed to include \"+\n                              \"non-configurable enumerable property '\"+\n                              ownEnumerableProp+\"'\");\n        }\n        if (!Object.isExtensible(target) &&\n            isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\"+\n                                ownEnumerableProp+\"' as non-existent on a \"+\n                                \"non-extensible object\");\n        }\n      }\n    });\n\n    return result;\n  },\n  */\n  \n  /**\n   * New trap that reifies [[Call]].\n   * If the target is a function, then a call to\n   *   proxy(...args)\n   * Triggers this trap\n   */\n  apply: function(target, thisBinding, args) {\n    var trap = this.getTrap(\"apply\");\n    if (trap === undefined) {\n      return Reflect.apply(target, thisBinding, args);\n    }\n\n    if (typeof this.target === \"function\") {\n      return trap.call(this.handler, target, thisBinding, args);\n    } else {\n      throw new TypeError(\"apply: \"+ target + \" is not a function\");\n    }\n  },\n\n  /**\n   * New trap that reifies [[Construct]].\n   * If the target is a function, then a call to\n   *   new proxy(...args)\n   * Triggers this trap\n   */\n  construct: function(target, args, newTarget) {\n    var trap = this.getTrap(\"construct\");\n    if (trap === undefined) {\n      return Reflect.construct(target, args, newTarget);\n    }\n\n    if (typeof target !== \"function\") {\n      throw new TypeError(\"new: \"+ target + \" is not a function\");\n    }\n\n    if (newTarget === undefined) {\n      newTarget = target;\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"new: \"+ newTarget + \" is not a function\");\n      }      \n    }\n    return trap.call(this.handler, target, args, newTarget);\n  }\n};\n\n// ---- end of the Validator handler wrapper handler ----\n\n// In what follows, a 'direct proxy' is a proxy\n// whose handler is a Validator. Such proxies can be made non-extensible,\n// sealed or frozen without losing the ability to trap.\n\n// maps direct proxies to their Validator handlers\nvar directProxies = new WeakMap();\n\n// patch Object.{preventExtensions,seal,freeze} so that\n// they recognize fixable proxies and act accordingly\nObject.preventExtensions = function(subject) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    if (vhandler.preventExtensions()) {\n      return subject;\n    } else {\n      throw new TypeError(\"preventExtensions on \"+subject+\" rejected\");\n    }\n  } else {\n    return prim_preventExtensions(subject);\n  }\n};\nObject.seal = function(subject) {\n  setIntegrityLevel(subject, \"sealed\");\n  return subject;\n};\nObject.freeze = function(subject) {\n  setIntegrityLevel(subject, \"frozen\");\n  return subject;\n};\nObject.isExtensible = Object_isExtensible = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.isExtensible();\n  } else {\n    return prim_isExtensible(subject);\n  }\n};\nObject.isSealed = Object_isSealed = function(subject) {\n  return testIntegrityLevel(subject, \"sealed\");\n};\nObject.isFrozen = Object_isFrozen = function(subject) {\n  return testIntegrityLevel(subject, \"frozen\");\n};\nObject.getPrototypeOf = Object_getPrototypeOf = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.getPrototypeOf();\n  } else {\n    return prim_getPrototypeOf(subject);\n  }\n};\n\n// patch Object.getOwnPropertyDescriptor to directly call\n// the Validator.prototype.getOwnPropertyDescriptor trap\n// This is to circumvent an assertion in the built-in Proxy\n// trapping mechanism of v8, which disallows that trap to\n// return non-configurable property descriptors (as per the\n// old Proxy design)\nObject.getOwnPropertyDescriptor = function(subject, name) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    return vhandler.getOwnPropertyDescriptor(name);\n  } else {\n    return prim_getOwnPropertyDescriptor(subject, name);\n  }\n};\n\n// patch Object.defineProperty to directly call\n// the Validator.prototype.defineProperty trap\n// This is to circumvent two issues with the built-in\n// trap mechanism:\n// 1) the current tracemonkey implementation of proxies\n// auto-completes 'desc', which is not correct. 'desc' should be\n// normalized, but not completed. Consider:\n// Object.defineProperty(proxy, 'foo', {enumerable:false})\n// This trap will receive desc =\n//  {value:undefined,writable:false,enumerable:false,configurable:false}\n// This will also set all other attributes to their default value,\n// which is unexpected and different from [[DefineOwnProperty]].\n// Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n// 2) the current spidermonkey implementation does not\n// throw an exception when this trap returns 'false', but instead silently\n// ignores the operation (this is regardless of strict-mode)\n// 2a) v8 does throw an exception for this case, but includes the rather\n//     unhelpful error message:\n// 'Proxy handler #<Object> returned false from 'defineProperty' trap'\nObject.defineProperty = function(subject, name, desc) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var normalizedDesc = normalizePropertyDescriptor(desc);\n    var success = vhandler.defineProperty(name, normalizedDesc);\n    if (success === false) {\n      throw new TypeError(\"can't redefine property '\"+name+\"'\");\n    }\n    return subject;\n  } else {\n    return prim_defineProperty(subject, name, desc);\n  }\n};\n\nObject.defineProperties = function(subject, descs) {\n  var vhandler = directProxies.get(subject);\n  if (vhandler !== undefined) {\n    var names = Object.keys(descs);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\"+name+\"'\");\n      }\n    }\n    return subject;\n  } else {\n    return prim_defineProperties(subject, descs);\n  }\n};\n\nObject.keys = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    var ownKeys = vHandler.ownKeys();\n    var result = [];\n    for (var i = 0; i < ownKeys.length; i++) {\n      var k = String(ownKeys[i]);\n      var desc = Object.getOwnPropertyDescriptor(subject, k);\n      if (desc !== undefined && desc.enumerable === true) {\n        result.push(k);\n      }\n    }\n    return result;\n  } else {\n    return prim_keys(subject);\n  }\n}\n\nObject.getOwnPropertyNames = Object_getOwnPropertyNames = function(subject) {\n  var vHandler = directProxies.get(subject);\n  if (vHandler !== undefined) {\n    return vHandler.ownKeys();\n  } else {\n    return prim_getOwnPropertyNames(subject);\n  }\n}\n\n// fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n// throws an error)\nif (prim_getOwnPropertySymbols !== undefined) {\n  Object.getOwnPropertySymbols = function(subject) {\n    var vHandler = directProxies.get(subject);\n    if (vHandler !== undefined) {\n      // as this shim does not support symbols, a Proxy never advertises\n      // any symbol-valued own properties\n      return [];\n    } else {\n      return prim_getOwnPropertySymbols(subject);\n    }\n  };\n}\n\n// fixes issue #72 ('Illegal access' error when using Object.assign)\n// Object.assign polyfill based on a polyfill posted on MDN: \n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n//  Global_Objects/Object/assign\n// Note that this polyfill does not support Symbols, but this Proxy Shim\n// does not support Symbols anyway.\nif (prim_assign !== undefined) {\n  Object.assign = function (target) {\n    \n    // check if any argument is a proxy object\n    var noProxies = true;\n    for (var i = 0; i < arguments.length; i++) {\n      var vHandler = directProxies.get(arguments[i]);\n      if (vHandler !== undefined) {\n        noProxies = false;\n        break;\n      }\n    }\n    if (noProxies) {\n      // not a single argument is a proxy, perform built-in algorithm\n      return prim_assign.apply(Object, arguments);\n    }\n    \n    // there is at least one proxy argument, use the polyfill\n    \n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n    return output;\n  };\n}\n\n// returns whether an argument is a reference to an object,\n// which is legal as a WeakMap key.\nfunction isObject(arg) {\n  var type = typeof arg;\n  return (type === 'object' && arg !== null) || (type === 'function');\n};\n\n// a wrapper for WeakMap.get which returns the undefined value\n// for keys that are not objects (in which case the underlying\n// WeakMap would have thrown a TypeError).\nfunction safeWeakMapGet(map, key) {\n  return isObject(key) ? map.get(key) : undefined;\n};\n\n// returns a new function of zero arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a zero-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping0ArgMethod(primitive) {\n  return function builtin() {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target);\n    } else {\n      return primitive.call(this);\n    }\n  }\n};\n\n// returns a new function of 1 arguments that recursively\n// unwraps any proxies specified as the |this|-value.\n// The primitive is assumed to be a 1-argument method\n// that uses its |this|-binding.\nfunction makeUnwrapping1ArgMethod(primitive) {\n  return function builtin(arg) {\n    var vHandler = safeWeakMapGet(directProxies, this);\n    if (vHandler !== undefined) {\n      return builtin.call(vHandler.target, arg);\n    } else {\n      return primitive.call(this, arg);\n    }\n  }\n};\n\nObject.prototype.valueOf =\n  makeUnwrapping0ArgMethod(Object.prototype.valueOf);\nObject.prototype.toString =\n  makeUnwrapping0ArgMethod(Object.prototype.toString);\nFunction.prototype.toString =\n  makeUnwrapping0ArgMethod(Function.prototype.toString);\nDate.prototype.toString =\n  makeUnwrapping0ArgMethod(Date.prototype.toString);\n\nObject.prototype.isPrototypeOf = function builtin(arg) {\n  // bugfix thanks to Bill Mark:\n  // built-in isPrototypeOf does not unwrap proxies used\n  // as arguments. So, we implement the builtin ourselves,\n  // based on the ECMAScript 6 spec. Our encoding will\n  // make sure that if a proxy is used as an argument,\n  // its getPrototypeOf trap will be called.\n  while (true) {\n    var vHandler2 = safeWeakMapGet(directProxies, arg);\n    if (vHandler2 !== undefined) {\n      arg = vHandler2.getPrototypeOf();\n      if (arg === null) {\n        return false;\n      } else if (sameValue(arg, this)) {\n        return true;\n      }\n    } else {\n      return prim_isPrototypeOf.call(this, arg);\n    }\n  }\n};\n\nArray.isArray = function(subject) {\n  var vHandler = safeWeakMapGet(directProxies, subject);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  } else {\n    return prim_isArray(subject);\n  }\n};\n\nfunction isProxyArray(arg) {\n  var vHandler = safeWeakMapGet(directProxies, arg);\n  if (vHandler !== undefined) {\n    return Array.isArray(vHandler.target);\n  }\n  return false;\n}\n\n// Array.prototype.concat internally tests whether one of its\n// arguments is an Array, by checking whether [[Class]] == \"Array\"\n// As such, it will fail to recognize proxies-for-arrays as arrays.\n// We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n// by making a copy. This will trigger the exact same sequence of\n// traps on the proxy-for-array as if we would not have unwrapped it.\n// See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\nArray.prototype.concat = function(/*...args*/) {\n  var length;\n  for (var i = 0; i < arguments.length; i++) {\n    if (isProxyArray(arguments[i])) {\n      length = arguments[i].length;\n      arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n    }\n  }\n  return prim_concat.apply(this, arguments);\n};\n\n// setPrototypeOf support on platforms that support __proto__\n\nvar prim_setPrototypeOf = Object.setPrototypeOf;\n\n// patch and extract original __proto__ setter\nvar __proto__setter = (function() {\n  var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype,'__proto__');\n  if (protoDesc === undefined ||\n      typeof protoDesc.set !== \"function\") {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  // see if we can actually mutate a prototype with the generic setter\n  // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n  try {\n    protoDesc.set.call({},{});\n  } catch (e) {\n    return function() {\n      throw new TypeError(\"setPrototypeOf not supported on this platform\");\n    }\n  }\n\n  prim_defineProperty(Object.prototype, '__proto__', {\n    set: function(newProto) {\n      return Object.setPrototypeOf(this, Object(newProto));\n    }\n  });\n\n  return protoDesc.set;\n}());\n\nObject.setPrototypeOf = function(target, newProto) {\n  var handler = directProxies.get(target);\n  if (handler !== undefined) {\n    if (handler.setPrototypeOf(newProto)) {\n      return target;\n    } else {\n      throw new TypeError(\"proxy rejected prototype mutation\");\n    }\n  } else {\n    if (!Object_isExtensible(target)) {\n      throw new TypeError(\"can't set prototype on non-extensible object: \" +\n                          target);\n    }\n    if (prim_setPrototypeOf)\n      return prim_setPrototypeOf(target, newProto);\n\n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n      // throw new TypeError(\"prototype must be an object or null\")\n    }\n    __proto__setter.call(target, newProto);\n    return target;\n  }\n}\n\nObject.prototype.hasOwnProperty = function(name) {\n  var handler = safeWeakMapGet(directProxies, this);\n  if (handler !== undefined) {\n    var desc = handler.getOwnPropertyDescriptor(name);\n    return desc !== undefined;\n  } else {\n    return prim_hasOwnProperty.call(this, name);\n  }\n}\n\n// ============= Reflection module =============\n// see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\nvar Reflect = {\n  getOwnPropertyDescriptor: function(target, name) {\n    return Object.getOwnPropertyDescriptor(target, name);\n  },\n  defineProperty: function(target, name, desc) {\n\n    // if target is a proxy, invoke its \"defineProperty\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.defineProperty(target, name, desc);\n    }\n\n    // Implementation transliterated from [[DefineOwnProperty]]\n    // see ES5.1 section 8.12.9\n    // this is the _exact same algorithm_ as the isCompatibleDescriptor\n    // algorithm defined above, except that at every place it\n    // returns true, this algorithm actually does define the property.\n    var current = Object.getOwnPropertyDescriptor(target, name);\n    var extensible = Object.isExtensible(target);\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n    if (current === undefined && extensible === true) {\n      Object.defineProperty(target, name, desc); // should never fail\n      return true;\n    }\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n    if (isGenericDescriptor(desc)) {\n      // no further validation necessary\n    } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n    } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n    } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n    Object.defineProperty(target, name, desc); // should never fail\n    return true;\n  },\n  deleteProperty: function(target, name) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.delete(name);\n    }\n    \n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      return true;\n    }\n    if (desc.configurable === true) {\n      delete target[name];\n      return true;\n    }\n    return false;    \n  },\n  getPrototypeOf: function(target) {\n    return Object.getPrototypeOf(target);\n  },\n  setPrototypeOf: function(target, newProto) {\n    \n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.setPrototypeOf(newProto);\n    }\n    \n    if (Object(newProto) !== newProto || newProto === null) {\n      throw new TypeError(\"Object prototype may only be an Object or null: \" +\n                         newProto);\n    }\n    \n    if (!Object_isExtensible(target)) {\n      return false;\n    }\n    \n    var current = Object.getPrototypeOf(target);\n    if (sameValue(current, newProto)) {\n      return true;\n    }\n    \n    if (prim_setPrototypeOf) {\n      try {\n        prim_setPrototypeOf(target, newProto);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    __proto__setter.call(target, newProto);\n    return true;\n  },\n  preventExtensions: function(target) {\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.preventExtensions();\n    }\n    prim_preventExtensions(target);\n    return true;\n  },\n  isExtensible: function(target) {\n    return Object.isExtensible(target);\n  },\n  has: function(target, name) {\n    return name in target;\n  },\n  get: function(target, name, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"get\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.get(receiver, name);\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n    if (desc === undefined) {\n      var proto = Object.getPrototypeOf(target);\n      if (proto === null) {\n        return undefined;\n      }\n      return Reflect.get(proto, name, receiver);\n    }\n    if (isDataDescriptor(desc)) {\n      return desc.value;\n    }\n    var getter = desc.get;\n    if (getter === undefined) {\n      return undefined;\n    }\n    return desc.get.call(receiver);\n  },\n  // Reflect.set implementation based on latest version of [[SetP]] at\n  // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n  set: function(target, name, value, receiver) {\n    receiver = receiver || target;\n\n    // if target is a proxy, invoke its \"set\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.set(receiver, name, value);\n    }\n\n    // first, check whether target has a non-writable property\n    // shadowing name on receiver\n    var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (ownDesc === undefined) {\n      // name is not defined in target, search target's prototype\n      var proto = Object.getPrototypeOf(target);\n\n      if (proto !== null) {\n        // continue the search in target's prototype\n        return Reflect.set(proto, name, value, receiver);\n      }\n\n      // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n      // target was the last prototype, now we know that 'name' is not shadowed\n      // by an existing (accessor or data) property, so we can add the property\n      // to the initial receiver object\n      // (this branch will intentionally fall through to the code below)\n      ownDesc =\n        { value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n    }\n\n    // we now know that ownDesc !== undefined\n    if (isAccessorDescriptor(ownDesc)) {\n      var setter = ownDesc.set;\n      if (setter === undefined) return false;\n      setter.call(receiver, value); // assumes Function.prototype.call\n      return true;\n    }\n    // otherwise, isDataDescriptor(ownDesc) must be true\n    if (ownDesc.writable === false) return false;\n    // we found an existing writable data property on the prototype chain.\n    // Now update or add the data property on the receiver, depending on\n    // whether the receiver already defines the property or not.\n    var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n    if (existingDesc !== undefined) {\n      var updateDesc =\n        { value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable:     existingDesc.writable,\n          enumerable:   existingDesc.enumerable,\n          configurable: existingDesc.configurable };\n      Object.defineProperty(receiver, name, updateDesc);\n      return true;\n    } else {\n      if (!Object.isExtensible(receiver)) return false;\n      var newDesc =\n        { value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true };\n      Object.defineProperty(receiver, name, newDesc);\n      return true;\n    }\n  },\n  /*invoke: function(target, name, args, receiver) {\n    receiver = receiver || target;\n\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.invoke(receiver, name, args);\n    }\n\n    var fun = Reflect.get(target, name, receiver);\n    return Function.prototype.apply.call(fun, receiver, args);\n  },*/\n  enumerate: function(target) {\n    var handler = directProxies.get(target);\n    var result;\n    if (handler !== undefined) {\n      // handler.enumerate should return an iterator directly, but the\n      // iterator gets converted to an array for backward-compat reasons,\n      // so we must re-iterate over the array\n      result = handler.enumerate(handler.target);\n    } else {\n      result = [];\n      for (var name in target) { result.push(name); };      \n    }\n    var l = +result.length;\n    var idx = 0;\n    return {\n      next: function() {\n        if (idx === l) return { done: true };\n        return { done: false, value: result[idx++] };\n      }\n    };\n  },\n  // imperfect ownKeys implementation: in ES6, should also include\n  // symbol-keyed properties.\n  ownKeys: function(target) {\n    return Object_getOwnPropertyNames(target);\n  },\n  apply: function(target, receiver, args) {\n    // target.apply(receiver, args)\n    return Function.prototype.apply.call(target, receiver, args);\n  },\n  construct: function(target, args, newTarget) {\n    // return new target(...args);\n\n    // if target is a proxy, invoke its \"construct\" trap\n    var handler = directProxies.get(target);\n    if (handler !== undefined) {\n      return handler.construct(handler.target, args, newTarget);\n    }\n    \n    if (typeof target !== \"function\") {\n      throw new TypeError(\"target is not a function: \" + target);\n    }\n    if (newTarget === undefined || newTarget === target) {\n      // If newTarget is undefined, then newTarget is set to `target` and\n      // `Reflect.construct(target, ...args)` becomes equivalent to\n      // `new target(...args)`\n      // if `target` is an ES2015 Class constructor, it must be called using\n      // the `new` operator. Hence we use the new operator on a bound function\n      // to trigger the [[Construct]] internal method. This technique will work \n      // for both plain constructor functions and ES2015 classes\n      return new (Function.prototype.bind.apply(target, [null].concat(args)));\n    } else {\n      if (typeof newTarget !== \"function\") {\n        throw new TypeError(\"newTarget is not a function: \" + target);\n      }\n      // if newTarget is a *different* constructor function, we need to\n      // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n      // new instance inheriting from newTarget.prototype\n      // Unfortunately this won't work if target is an ES2015 Constructor\n      // function, whose [[Call]] method throws an error (it must be invoked\n      // using the `new` operator)\n      var proto = newTarget.prototype;\n      var instance = (Object(proto) === proto) ? Object.create(proto) : {};\n      var result = Function.prototype.apply.call(target, instance, args);\n      return Object(result) === result ? result : instance;\n    }\n  }\n};\n\n// feature-test whether the Reflect global exists\nif (global.Reflect !== undefined) {\n  // Reflect exists, add/override the shimmed methods\n  Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n    global.Reflect[key] = Reflect[key];\n  });\n} else {\n  // Reflect doesn't exist, define it as the shimmed Reflect object\n  global.Reflect = Reflect;\n}\n\n// feature-test whether the Proxy global exists, with\n// the harmony-era Proxy.create API\nif (typeof Proxy !== \"undefined\" &&\n    typeof Proxy.create !== \"undefined\") {\n\n  var primCreate = Proxy.create,\n      primCreateFunction = Proxy.createFunction;\n\n  var revokedHandler = primCreate({\n    get: function() { throw new TypeError(\"proxy is revoked\"); }\n  });\n\n  global.Proxy = function(target, handler) {\n    // check that target is an Object\n    if (Object(target) !== target) {\n      throw new TypeError(\"Proxy target must be an Object, given \"+target);\n    }\n    // check that handler is an Object\n    if (Object(handler) !== handler) {\n      throw new TypeError(\"Proxy handler must be an Object, given \"+handler);\n    }\n\n    var vHandler = new Validator(target, handler);\n    var proxy;\n    if (typeof target === \"function\") {\n      proxy = primCreateFunction(vHandler,\n        // call trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        },\n        // construct trap\n        function() {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n    } else {\n      proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n    }\n    directProxies.set(proxy, vHandler);\n    return proxy;\n  };\n\n  global.Proxy.revocable = function(target, handler) {\n    var proxy = new Proxy(target, handler);\n    var revoke = function() {\n      var vHandler = directProxies.get(proxy);\n      if (vHandler !== null) {\n        vHandler.target  = null;\n        vHandler.handler = revokedHandler;\n      }\n      return undefined;\n    };\n    return {proxy: proxy, revoke: revoke};\n  }\n  \n  // add the old Proxy.create and Proxy.createFunction methods\n  // so old code that still depends on the harmony-era Proxy object\n  // is not broken. Also ensures that multiple versions of this\n  // library should load fine\n  global.Proxy.create = primCreate;\n  global.Proxy.createFunction = primCreateFunction;\n\n} else {\n  // Proxy global not defined, or old API not available\n  if (typeof Proxy === \"undefined\") {\n    // Proxy global not defined, add a Proxy function stub\n    global.Proxy = function(_target, _handler) {\n      throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n    };\n  }\n  // Proxy global defined but old API not available\n  // presumably Proxy global already supports new API, leave untouched\n}\n\n// for node.js modules, export every property in the Reflect object\n// as part of the module interface\nif (typeof exports !== 'undefined') {\n  Object.keys(Reflect).forEach(function (key) {\n    exports[key] = Reflect[key];\n  });\n}\n\n// function-as-module pattern\n}(typeof exports !== 'undefined' ? global : this));"],"mappings":"AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACD;AACC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,WAASA,MAAM,EAAC;EAAE;EACnB,YAAY;;EAEZ;;EAEA;EACA;EACA;;EAEA;;EAEA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;;EAEA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;;EAEA;;EAEA;;EAEA;;EAEA;EACA;EACA;EACA,IAAI,OAAOC,OAAO,KAAK,WAAW,EAAE;IAClCD,MAAM,CAACC,OAAO,GAAG,YAAU,CAAC,CAAC;IAC7BD,MAAM,CAACC,OAAO,CAACC,SAAS,GAAG;MACzBC,GAAG,EAAE,SAAAA,CAASC,CAAC,EAAE;QAAE,OAAOC,SAAS;MAAE,CAAC;MACtCC,GAAG,EAAE,SAAAA,CAASF,CAAC,EAACG,CAAC,EAAE;QAAE,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;MAAE;IACjE,CAAC;EACH;;EAEA;;EAEA,SAASC,mBAAmBA,CAACC,IAAI,EAAE;IACjC,OAAO,oDAAo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"},"metadata":{},"sourceType":"script","externalDependencies":[]}